<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL基础</title>
      <link href="2022/03/02/MySQL%E9%9D%A2%E8%AF%95/"/>
      <url>2022/03/02/MySQL%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h5 id=""><a href="#" class="headerlink" title=""></a></h5><center>本篇文章从存储引擎架构、索引、事务、锁及 MVCC 等方面详细介绍面试中常见的问题。</center><a id="more"></a><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="1-MySQL-逻辑架构"><a href="#1-MySQL-逻辑架构" class="headerlink" title="1. MySQL 逻辑架构"></a>1. MySQL 逻辑架构</h3><p>主要分为三层：<strong>连接层、服务层、引擎层。</strong>其中存储层就是文件，不属于逻辑架构。</p><p><strong>连接层</strong>：客户端访问 MySQL 服务器前，做的第一件事就是 TCP 连接。</p><p><strong>服务层</strong>：</p><ul><li>SQL 接口：接收 SQL 命令，并返回数据。</li><li>解析器： 对 SQL 语法分析、语义分析。并创建语法树</li><li>查询优化器：确定 SQL 对执行路径，生成一个执行计划</li><li>查询缓存组建：内部有 Cache 和 Buffer ，如果查到直接返回。一般作用不大，<strong>8.0去掉了缓存</strong>。</li></ul><p><strong>引擎层</strong>：与数据库文件打交道，负责数据的存储和读取</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220210222236950-20220325211339500.png" alt="image-20220210222236950"></p><h3 id="2-SQL-的执行流程"><a href="#2-SQL-的执行流程" class="headerlink" title="2. SQL 的执行流程"></a>2. SQL 的执行流程</h3><ol><li><p>在 SQL 查询之前，需要建立 TCP 连接</p></li><li><p>连接以后， MySQL 服务器对传输过来的账号密码进行验证，验证通过则继续，不通过返回。</p></li><li><p>然后接受 SQL 命令，首先 MySQL 8.0 之前的版本，先查询缓存，如果发现了这条 SQL 语句，则返回，结束查询。没有发现则继续。</p></li><li><p>没有命中缓存则进入解析器，进行语法解析，判断是不是语法正确，正确就生成解析树。</p></li><li><p>然后进行优化器，确定 SQL 的执行路径，生成一个执行计划。</p></li><li><p>执行计划给到执行器，判断用户是不是有权限，如果没有返回错误，如果有调用存储引擎</p></li><li><p>执行引擎执行 SQL 查询并返回结果，然后将结果放回查询缓存当中。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220304101115541.png" alt="image-20220304101115541" style="zoom:50%;" /></li></ol><h3 id="3-MySqL-存储引擎-MyISAM-与-InnoDB-区别？"><a href="#3-MySqL-存储引擎-MyISAM-与-InnoDB-区别？" class="headerlink" title="3. MySqL 存储引擎 MyISAM 与 InnoDB 区别？"></a>3. MySqL 存储引擎 MyISAM 与 InnoDB 区别？</h3><p><strong>Innodb 引擎</strong>：Innodb 引擎提供了对数据库 <strong>ACID 事务</strong>的支持。并且还提供了<strong>行级锁</strong>和<strong>外键</strong>的约束。它的设计的目标就是处理大数据容量的数据库系统。<br><strong>MyIASM 引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。<br><strong>MEMORY 引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p><ol><li>InnoDB 是聚簇索引、而 MyISAM 是非聚簇索引。</li><li>InnoDB 数据与索引保存在一起（.ibd）, 而 MyISAM 分为三个文件(.frm 表结构)(.myi 索引)(.myd 数据)</li><li>InnoDB 支持<strong>行级锁、事务、外键</strong>。而 MyISAM 都不支持。</li><li>InnoDB 更新更优， MyISAM 查询更优</li><li>Select count(*) MyISAM 更快，因为它维护了一个计数器。</li></ol><ul><li>在选择存储引擎方面，如果没有特殊要求，我们就选 InnoDB ，如果多数都在读操作，并且清楚明白没有事务，数据崩溃等缺点，也可以使用 MyISAM，如果需要事务，并且需要高并发，经常进行写操作，那么就使用 InnoDB。</li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220228170105898.png" alt="image-20220228170105898"></p><p>注意⚠️：Innodb 5.6 之后支持全文索引、并且还有自适应的 hash 索引</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1. 什么是索引？"></a>1. 什么是索引？</h3><p>索引就是一种能帮助 MySql 高效获取数据的数据结构(排好序的快速查找的数据结构)，能实现快速查找。</p><h3 id="2-索引的优缺点？"><a href="#2-索引的优缺点？" class="headerlink" title="2. 索引的优缺点？"></a>2. 索引的优缺点？</h3><p>优点：</p><ul><li><p>提高数据检索效率，降低数据库的 IO 成本。(主要原因)</p></li><li><p>因为索引已经帮我们排好序了，这样我们查询数据时服务器能避免排序。</p></li></ul><p>缺点：</p><ul><li>时间方面：创建索引和维护索引需要额外的时间，对表进行增删改的时候，索引也要动态的维护。降低效率。</li><li>空间方面：索引还会占用一定的物理存储空间。</li></ul><h3 id="3-索引的分类？"><a href="#3-索引的分类？" class="headerlink" title="3. 索引的分类？"></a>3. 索引的分类？</h3><p>索引包括<strong>普通索引、唯一索引、全文索引、单列索引、多列索引、和空间索引。</strong></p><p>从功能逻辑上：索引分为四类：<strong>普通索引、唯一索引、主键索引、全文索引</strong>。</p><p>从物理实现方式上：分为聚簇索引和非聚簇索引。</p><p>按照作用字段来说：分为单列索引和联合索引。</p><p>主键索引：数据列不允许重复，不允许为 null，一个表只有一个主键索引。</p><p>唯一索引：数据列不允许重复，允许为 null，一个表可以由多个唯一索引。</p><p>普通索引：没有唯一性和 null 值要求。</p><p>全文索引：（先空着吧）</p><h3 id="4-索引的数据结构？"><a href="#4-索引的数据结构？" class="headerlink" title="4. 索引的数据结构？"></a>4. 索引的数据结构？</h3><h4 id="Hash-amp-B-树"><a href="#Hash-amp-B-树" class="headerlink" title="Hash &amp; B+树"></a>Hash &amp; B+树</h4><p>Hash表查询数据时间复杂度为 O(1)，但是无法进行范围查询。并且查出类的数据也不一定对。</p><h5 id="Hash-表存在的缺点"><a href="#Hash-表存在的缺点" class="headerlink" title="Hash 表存在的缺点"></a>Hash 表存在的缺点</h5><ul><li>Hash 冲突问题</li><li>Hash 索引不支持顺序查找和范围查找</li></ul><h4 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h4><h5 id="B-树和-B-树的异同？"><a href="#B-树和-B-树的异同？" class="headerlink" title="B 树和 B+ 树的异同？"></a>B 树和 B+ 树的异同？</h5><ul><li>B 树的非叶子节点既存放键也存放数据，然而 B+ 树的数据只存在叶子节点中。</li><li>B 树中叶子节点时独立的，而 B+ 树有链表指向邻居节点。</li><li>B 树的查找是二分查找，可能没有找到叶子节点查找就结束了，而 B+ 树任何查找都是从根节点到叶子节点的查找。</li></ul><h3 id="5-索引的设计原则？"><a href="#5-索引的设计原则？" class="headerlink" title="5. 索引的设计原则？"></a>5. 索引的设计原则？</h3><h5 id="那些情况下适合创建索引？"><a href="#那些情况下适合创建索引？" class="headerlink" title="那些情况下适合创建索引？"></a>那些情况下适合创建索引？</h5><ol><li><p>字段的数值有唯一性的限制</p></li><li><p>频繁作为 where 查询条件的字段</p></li><li><p>经常使用 Group by 和 Order by 的字段</p></li><li><p>Update 和 Delete 的 Where 条件列，</p><p>因为如果没有给 Where 条件列添加索引，那么需要进行全表扫描后查出数据再进行更新或者删除操作。但是加上索引后，查询就快了，再进行对他更新或者删除。</p></li><li><p>DISTINCT 字段需要创建索引</p></li><li><p>多表 JOIN 连接操作时，对 Where 条件所需的字段</p></li><li><p>使用列的类型小的创建索引</p><p>使用列的类型小的创建索引，那么占用的物理空间就少，就能够多放数据，可能就能让 B+ 树更扁平，降低 IO。</p></li><li><p>使用字符串前缀创建索引</p></li><li><p>区分度高(散列性高)的列适合作为索引</p></li><li><p>使用最频繁的列放到联合索引的左侧</p></li><li><p>在多个字段都要创建索引的情况下，联合索引优于单值索引。</p></li></ol><h5 id="哪些情况不适合创建索引？"><a href="#哪些情况不适合创建索引？" class="headerlink" title="哪些情况不适合创建索引？"></a>哪些情况不适合创建索引？</h5><ol><li>在 where 中使用不到的字段，不要设置索引。</li><li>数据量小的表最好不要使用索引</li><li>有大量重复数据的列上不要建立索引</li><li>避免对经常更新的表创建过多的索引</li><li>不建议用无序的值作为索引</li><li>删除不再使用或者很少使用的索引</li><li>不要定义冗余或重复的索引</li></ol><h3 id="6-联合索引是什么？为什么需要注意联合索引的顺序？"><a href="#6-联合索引是什么？为什么需要注意联合索引的顺序？" class="headerlink" title="6. 联合索引是什么？为什么需要注意联合索引的顺序？"></a>6. 联合索引是什么？为什么需要注意联合索引的顺序？</h3><p>联合索引就是为多个字段建立索引，如果想要命中索引，就需要按照建立索引时的字段顺序挨个使用，不这样就命中不了。一般情况下，我们会把查询频繁的字段或者选择性高的字段放在前面。</p><h3 id="7-非聚簇索引一定会回表查询吗？"><a href="#7-非聚簇索引一定会回表查询吗？" class="headerlink" title="7. 非聚簇索引一定会回表查询吗？"></a>7. 非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p><p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p><h3 id="8-什么是最左前缀原则？"><a href="#8-什么是最左前缀原则？" class="headerlink" title="8. 什么是最左前缀原则？"></a>8. 什么是最左前缀原则？</h3><p>在 MySQL 建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，如果第一个索引字段没有使用，那就不会使用该索引。</p><h3 id="9-百万级别或以上的数据如何删除？"><a href="#9-百万级别或以上的数据如何删除？" class="headerlink" title="9. 百万级别或以上的数据如何删除？"></a>9. 百万级别或以上的数据如何删除？</h3><p>如果直接删除，那么删除数据的时候还要维护索引，就意味着额外的 IO，会降低效率，所以，我们可以先记录已经创建的索引，在删除数据之前先删除索引，在删除数据，最后再建立相应的索引。</p><h3 id="10-COUNT-和-COUNT-具体字段-效率？"><a href="#10-COUNT-和-COUNT-具体字段-效率？" class="headerlink" title="10. COUNT(*) 和 COUNT(具体字段) 效率？"></a>10. COUNT(*) 和 COUNT(具体字段) 效率？</h3><p>在 MySQL 中统计数据表的行数，有三种方式，select count(*)、select count(1)、select count(具体字段)。但是他们的效率如何的呢？</p><p>环节1: COUNT(*) 和 COUNT(1) 都是对所有结果进行 COUNT，COUNT(※) 和 COUNT(1) 本质上并没有区别(二者执行时间可能略有差别，不过你还是可以把它俩的执行效率看成是相等的)。如果有 WHERE 子句，则是对所有符合筛选条件的数据行进行统计；如果没有 WHERE 子句，则是对数据表的数据行数进行统计。</p><p>环节2: 如果是 MylSAM 存储引擎，统计数据表的行数只需要 O(1) 的复杂度，这是因为每张 MyISAM 的数据表都有一个 meta 信息存储了 row_count 值，而一致性则由表级锁来保证。如果是 InnoDB 存储引擎，因为 InnoDB 支持事务，采用行级锁和 MVCC 机制，所以无法像 MyISAM 一样，维护一个 row_count 变量，因此需要采用扫描全表，O(n)复杂度。进行<strong>循环＋计数</strong>的方式来完成统计。</p><p>环节3: 在 InnoDB 引擎中，如果采用 COUNT(具体字段) 来统计数据行数，要尽量采用二级索引。因为主键采用的索引是聚簇索引，聚簇索引包含的信息多，明显会大于二级索引（非聚簇索引)。对于 COUNT(*) 和 COUNT(1) 来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计。</p><p>如果有多个二级索引，会使用 key_len 小的二级索引进行扫描。当没有二级索引的时候，才会采用主键索引来进行统计。</p><h3 id="11-关于-select"><a href="#11-关于-select" class="headerlink" title="11. 关于 select(*)"></a>11. 关于 select(*)</h3><p>尽量不要写 select(*)，推荐使用 select&lt;字段列表&gt; 查询。</p><p>原因：</p><p>①.MySQL 在解析的过程中，会通过查寻数据字典将*按序转化为所有列名，这会大大耗费资源和时间。</p><p>②. 无法使用<strong>覆盖索引</strong>。</p><h3 id="12-limit-1-对于优化的影响"><a href="#12-limit-1-对于优化的影响" class="headerlink" title="12. limit 1 对于优化的影响"></a>12. limit 1 对于优化的影响</h3><p>针对的是全表扫描的 SQL 语句，如果你可以确定结果集只有一条，那么加上 limit1 的时候，当找到一条结果的时候，就不会继续扫描了，这样会加快查询速度。</p><p>如果数据表已经对字段建立了索引，那么就会通过索引进行扫描，就不用家 limit1 了。</p><h3 id="13-创建索引的三种方式"><a href="#13-创建索引的三种方式" class="headerlink" title="13.创建索引的三种方式"></a>13.创建索引的三种方式</h3><ul><li>在创建表的时候创建索引</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">id INT auto_increment PRIMARY KEY,</span><br><span class="line">first_name VARCHAR (16),</span><br><span class="line">last_name VARCHAR (16),</span><br><span class="line">id_card VARCHAR (18),</span><br><span class="line">information text,</span><br><span class="line">KEY name (first_name, last_name),</span><br><span class="line">FULLTEXT KEY (information),</span><br><span class="line">UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>使用 ALTER TABLE 命令去增加索引</li><li>使用 CREATE INDEX 命令创建</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h3><p>事务就是指程序中一系列的严密操作，而且所有的操作必须全部成功，否则所有的操作必须全部撤销，通俗理解为：要么全部执行完，要么全部执行失败。</p><h3 id="2-事务的四个特性？"><a href="#2-事务的四个特性？" class="headerlink" title="2. 事务的四个特性？"></a>2. 事务的四个特性？</h3><ul><li><p>原子性(Atomicity)</p><p>原子性是指一个事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。</p></li><li><p>一致性(Consistency)</p><p>是指事务执行前后，数据从一个合法性状态转为另一个合法性状态。</p></li><li><p>隔离性(Isolation)</p><p>事务的隔离性是指一个事务在执行的过程中，不能被其他事务干扰，即是一个事务内部的操作及使用数据对并发的其他事务是隔离性的，并发的事务相互之间不能相互干扰。</p></li><li><p>持久性(Durability)</p><p>持久性是指一个事务一旦被提交，他对数据库的改变就是永久性的，接下来的其他数据库操作或者数据库的故障都能不能对其有任何影响。</p></li></ul><h3 id="3-redo-log-和-undo-log"><a href="#3-redo-log-和-undo-log" class="headerlink" title="3. redo log 和 undo log"></a>3. redo log 和 undo log</h3><p>首先，我们介绍了事务的四种特性，那么到底是基于什么样的原理实现的呢？</p><p>事务的隔离性由<strong>锁机制</strong>实现</p><p>事务的原子性、一致性、持久性由事务的 <strong>redo log</strong> 和 <strong>undo log</strong> 实现。</p><p> <strong>redo log</strong> 称为重做日志，提供<strong>再写入功能</strong>、恢复提交事务修改的页操作，保证事务的持久性。</p><p> **undo log **称为回滚日志，回滚行记录到指定的某个版本，保证事务的原子性、一致性。</p><p>解决的问题：如果一个事务没有提交，那么突然断电也就算了，反正你也没提交，但是如果我提交了，然后断电了，此时数据还没有被刷新到磁盘，那么我们怎么办呢？这时候就需要 redo log 日志了。redo log 只是记录了一下修改的表空间哪一个页面的哪一条数据，改了写什么。如果这个时候在发生问题，我们之间拿过来 redo log 就怼到 bug 脸上 。</p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305093142998.png" alt="image-20220305093142998" style="zoom:50%;" /><p>这里有一种技术 <strong>WAL</strong>（Write-Ahead Log）预先日志持久化技术，面试经常问噢，然后我们说的刷盘，一般指的就是上面的步骤3，只要我们把 redo log buffer 写入 redo log file 中，断电崩溃你随意。</p><p>注意⚠️：在redo log buffer 写入 redo log file 中，并不是直接刷到磁盘的，只是刷入了 page cache（文件系统缓存）中。由我们的操作系统来决定，具体由 <strong>innodb_flush_log_at_trx_commit</strong> 参数决定。由于面试不会问，这里就不写了。</p><h4 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h4><p>undo log 是事务原子性的保证，在<strong>增删改</strong>的操作下，是一定要记录的，查询不用记录，因为没有修改数据。</p><p>如果遇到服务器本身错误、操作系统错误、或者程序员进行了 ROLLBACK，都是进行回滚。符合一致性操作。不过 undo log 还有一种作用：就是做 <strong>MVCC</strong>（重点）。</p><p>下面👇是修改数据是的具体流程</p><ol><li>首先，修改数据，数据库缓冲池中没有数据</li><li>从磁盘加载</li><li>加载后，先记录 undo log 中。</li><li>然后在缓冲池中更新数据。</li><li>把更新的数据写入 Redo Log Buffer</li><li>Redo Log Buffer再写入到 Redo Log 文件</li><li>然后写入到 Binlog 文件中，方便主从复制，从机可以知道你做了什么操作了，实现主从同步。</li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305101744576.png" alt="image-20220305101744576" style="zoom:50%;" /><h3 id="4-事务的并发问题"><a href="#4-事务的并发问题" class="headerlink" title="4. 事务的并发问题"></a>4. 事务的并发问题</h3><ul><li><p>脏写</p><p>脏写就是两个事务，一个事务A，一个事务B，如果事务A修改了另一个事务B未提交但修改过的数据，事务A提交了，但是事务B回滚了，这就意味着脏写。（这种问题太严重了，所有的隔离级别都解决了这种问题）</p></li><li><p>脏读</p><p>所谓脏读，就是指一个事务 A 读取了事务 B 修改后，但是还没有提交的数据，这时候事务B又把数据回滚了，此时事务A读取到的数据就是脏的，所以称其为脏读。</p></li><li><p>不可重复读</p><p>两个事务，事务A读取了数据，事务B修改了数据并且提交了，此时，事务A再次读取数据时发现数据变了，造成了两次读取数据不一样，就是不可重复读。</p></li><li><p>幻读</p><p>两个事务，事务A从表中读取一个不存在的字段，但是这个时候事务B插入了数据，并且正好是事务A刚刚读过的数据，此时事务A也想插入数据，发现插入失败，出现幻读。</p></li></ul><h3 id="5-SQL-的隔离级别"><a href="#5-SQL-的隔离级别" class="headerlink" title="5. SQL 的隔离级别"></a>5. SQL 的隔离级别</h3><ul><li>read-uncommitted：读未提交</li></ul><p>此种隔离级别下，只能解决脏写，不能解决脏读、不可重复读、幻读。</p><ul><li>read-committed：读已提交</li></ul><p>也就是说事务只可以看的已经提交的数据，可以解决脏读，但是不可以解决不可重复读和幻读。Oracle 默认是此隔离级别。</p><ul><li>repeatable-read：可重复读</li></ul><p>事务A在读取一条数据时，事务B修改并提交了数据后，事务A再次读取此数据，读到的还是原来的内容，可以避免脏读、不可重复读，但是解决不了幻读问题。（MySQL 默认此种隔离级别）</p><ul><li>serializable：可串行化</li></ul><p>确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他食物对该表进行插入、更新、和删除操作。能避免所有问题，但是效率比较低。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>前提：锁的出现是为了保证事务的隔离型。数据库 MySQL 并发访问相同记录主要有以下三种情况，分别是：读-读、读-写(或者写-读)、写-写。读-读的情况可以并发进行，写-写的情况加锁就可以了，但是写-读或者读-写这种情况就有点难办。不过也有办法，主要有两种，第一种就是加锁，无论是读还是写，第二种就是读操作利用多版本并发控制（MVCC）这个后面讲到，这里主要讲锁。</p><p>锁的分类：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220304133246932.png" alt="image-20220304133246932" style="zoom:50%;" /><p>读锁：就是可以进行读操作，也就是都来进行加读锁，但是不可以加写锁，<strong>被称为共享读</strong>。</p><p>写锁：只能我来写，其他锁（无论读锁还是写锁都阻塞）阻塞。</p><p>表级别的锁：<strong>S 锁、X 锁、意向锁、自增锁、MDL 锁</strong>（这里特别指出，MyIASM 只支持表级别的 S、X 锁）</p><p>行级别的锁：<strong>记录锁、间隙锁、临键锁、插入意向锁</strong>（不是意向锁）</p><p>页级锁：（顺便问一下自己，一个数据页里面的结构掌握了吗？？）</p><h3 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h3><p><strong>意向锁：</strong></p><p>意向锁的出现原因：如果我们对标中的某一行加了 X 锁，之后又有一个事务加表级别的 X 锁，那这个时候就出了问题，除非在插入表级别的锁的时候进行，对所有行进行遍历，如果数据特别多，那真有点惨，所以出现了意向锁。主要协调表级锁与行级锁的关系。</p><p>所谓的意向锁。就是在行级别加 X 锁的时候，自动对页进行加锁，为 IX 锁（意向排他锁）。顺序一般为：先获取表的对应意向锁，然后再获取行的锁。</p><p>锁之间的关系</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220304141828616.png" alt="image-20220304141828616"></p><p>这里的<strong>意向锁和排他锁是表级别的锁</strong>。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220304141849723.png" alt="image-20220304141849723"></p><p><strong>自增锁：</strong>（了解）</p><p>在我们插入数据的时候，有的时候没有指定主键也能插入成功，是因为系统自动增加的，这里插入数据分为三种情况：简单插入、批量插入、混合模式插入。</p><p>简单插入：能确定插入的行数，能在系统中获取下一个的主键值就可以了。</p><p>批量插入：如果事先不清楚插入的行，那么需要在处理每一行数据的时候，为 AUTO-INCREMENT 列分配一个新值。</p><p>混合模式插入：有的指定了自增的值，有的没有指定。（限于篇幅，先不扩展，面试问到再说！）</p><p><strong>元数据锁（MDL 锁）：</strong></p><p>当一个表在进行增删查改的时候，加 MDL 锁，当对表结构进行变更的时候，加 MDL 锁。</p><h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>记录锁：行锁也是记录锁，记录锁有 X 型记录锁和 S 型记录锁。</p><p>间隙锁（Gap Locks）：间隙锁的提出<strong>主要解决幻读问题的</strong>。</p><p>临键锁（Next-Key Locks）：既锁定了某条记录，又阻止其他事务在该记录的间隙插入新纪录。</p><p>插入意向锁：插入意向锁是间隙锁，产生的主要原因是判断插入的位置是不是被别人加了间隙锁或者临键锁。如果在此之前加入了间隙锁，如果这时候还有两个事务，都在这个间隙里面插入数据，且插入的的数据不一样（指id），那么这个时候插入意向锁是可以共存的。</p><h3 id="乐观锁、悲观锁"><a href="#乐观锁、悲观锁" class="headerlink" title="乐观锁、悲观锁"></a>乐观锁、悲观锁</h3><p>悲观锁：就是做最坏的打算，每次拿数据的时候都认为别人会修改，所以每次的时候都上锁。Java 中的 synchronized 和 ReentrantLock 等就是悲观类型的锁。</p><p>乐观锁：他认为对同一操作的数据不会总发生，不用美词对别人进行行锁，但是在更新数据的时候会判断一下在此期间别人有没有更新过这个数据，可以采用<strong>版本号机制</strong>或者 <strong>CAS 机制</strong>。</p><p>适合使用的场景：</p><p>乐观锁：适用于多读场景，可以提高吞吐量。</p><p>悲观锁：适用于多写的场景。</p><h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC(多版本并发控制)"></a>MVCC(多版本并发控制)</h2><p>前提：数据库 MySQL 并发访问相同记录主要有以下三种情况，分别是：读-读、读-写(或者写-读)、写-写。读-读的情况可以并发进行，写-写的情况加锁就可以了，但是写-读或者读-写这种情况就有点难办。不过也有办法，主要有两种，第一种就是加锁，无论是读还是写，第二种就是读操作利用多版本并发控制（MVCC），写操作用锁解决。</p><p>那么为什么不用第一种方法呢？因为第一种都加锁并发效率低了。所以引入问题，MVCC怎么实现？</p><p>MVCC 依赖于 <strong>隐藏字段、Undo Log、Read View。</strong>多版本通过 Undo Log 实现，控制通过 Read View 实现。</p><p>一致性读就是快照读，解决读问题，<strong>当前读</strong>解决写操作问题。一致性读保证能看到之前到值，那么查询到时候就不用等到另一个事务释放锁就可以读取数据了，这不是提高了效率了吗？另外加锁的场景都是当前读。</p><h4 id="隐藏字段："><a href="#隐藏字段：" class="headerlink" title="隐藏字段："></a><strong>隐藏字段：</strong></h4><p>首先，回顾一下行记录的字段，行记录前三列是隐藏列，分别是 row- id、trx-id、roll-pointer.</p><p>row- id：如果没有主键，那么 MySQL 会生成一个主键，那个主键就是它，不过他在 MVCC 里面没有用。</p><p>trx-id：记录每一次 事务对他改动的<strong>事务号</strong>，每一个事务都会有事务号。</p><p>roll-pointer：是一个指针，每次对数据进行改动时，都会把旧版本的数据写入到 undo log ，然后这个指针就指向之前的记录。</p><p>后面的两个字段我们需要使用！</p><h4 id="undo-log-1"><a href="#undo-log-1" class="headerlink" title="undo log"></a><strong>undo log</strong></h4><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305111106465.png" alt="image-20220305111106465" style="zoom:50%;" /><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a><strong>ReadView</strong></h4><p>ReadView 就是事务在使用 MVCC 机制进行快照读操作产生的读视图。产生一个数组，来记录<strong>当前时刻活跃的事务ID</strong>，活跃就是启动还没有提交。</p><p>MVCC 针对的是 read-committed 和 repeatable-read 隔离级别，其他的隔离级别用不到。</p><h5 id="ReadView包含的内容"><a href="#ReadView包含的内容" class="headerlink" title="ReadView包含的内容"></a>ReadView包含的内容</h5><p>creator_trx_id ：创建这个 Read View 的事务 ID。</p><p>trx_ids ：表示在生成 ReadView 时当前系统中活跃的读写事务的事务id列表 。</p><p>up_limit_id ：活跃的事务中最小的事务 ID。</p><p>low_limit_id ：表示生成 ReadView 时系统中应该分配给下一个事务的 id 值。low_limit_id 是系 统最大的事务 id 值，这里要注意是系统中的事务 id，需要区别于正在活跃的事务 ID。</p><h5 id="ReadView-的规则"><a href="#ReadView-的规则" class="headerlink" title="ReadView 的规则"></a>ReadView 的规则</h5><ul><li><p>如果被访问版本的trx_id属性值与ReadView中的 creator_trx_id 值相同，意味着当前事务在访问 它自己修改过的记录，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值小于ReadView中的 up_limit_id 值，表明生成该版本的事务在当前 事务生成ReadView前已经提交，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值大于或等于ReadView中的 low_limit_id 值，表明生成该版本的事 务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的trx_id属性值在ReadView的 up_limit_id 和 low_limit_id 之间，那就需要判 断一下trx_id属性值是不是在 trx_ids 列表中。</p><ul><li>如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。 </li><li>如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。</li></ul></li></ul><h4 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h4><p>在  read-committed：**每次读取数据前都生成一个 **ReadView。</p><p>假如现在 student 表中只有一条由 事务id 为 8 的事务插入的数据：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305112310163.png" alt="image-20220305112310163" style="zoom: 50%;" /><p>系统里有两个 事务id 分别为 10 、 20 的事务在执行:</p><p>注意⚠️：如果是增删改，事务是分配的，如果是查询的话事务 id 为0；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;李四&quot; WHERE id&#x3D;1; UPDATE student SET name&#x3D;&quot;王五&quot; WHERE id&#x3D;1;</span><br><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录 ...</span><br></pre></td></tr></table></figure><p>此时就是下图表示的样子：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305112705688.png" alt="image-20220305112705688" style="zoom:50%;" /><p>注意⚠️：现在是在 READ COMMITTED 级别下</p><p>现在有一个事务来进行查询（事务ID为0），ReadView里面是【10、20】，因为0&lt;10，因为是读已提交，所以读出来是”张三”等信息。</p><p>具体步骤：</p><p>步骤1∶在执行 SELECT 语句时会先生成一个 ReadView，ReadView 的 trx_ids 列表的内容就是[10，20]，up_limit_id为10, low_limit_id为21,  creator_trx_id 为0。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’王五’，该版本的 trx_id 值为 10，在trx_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</p><p>步骤3:下一个版本的列 name 的内容是’李四’，该版本的 trx_id 值也为 10，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’张三’，该版本的trx_id值为8（说明已经提交了），小于ReadView中的up_limit_id值10，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’张三’的记录。</p><p>之后，首先事务10被提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 10</span><br><span class="line">BEGIN;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;李四&quot; WHERE id&#x3D;1;</span><br><span class="line">UPDATE student SET name&#x3D;&quot;王五&quot; WHERE id&#x3D;1; COMMIT;</span><br></pre></td></tr></table></figure><p>然后事务ID为 20操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Transaction 20</span><br><span class="line">BEGIN;</span><br><span class="line"># 更新了一些别的表的记录</span><br><span class="line">...</span><br><span class="line">UPDATE student SET name&#x3D;&quot;钱七&quot; WHERE id&#x3D;1; UPDATE student SET name&#x3D;&quot;宋八&quot; WHERE id&#x3D;1;</span><br></pre></td></tr></table></figure><p>然后就是下图的情况：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305113642314.png" alt="image-20220305113642314" style="zoom:50%;" /><p>然后，我们依旧进行读操作，每读一次就生成一个 ReadView。这里因为是读所以还是0；</p><p>具体步骤如下：</p><p>步骤1∶在执行 SELECT 语句时会又会单独生成一个 ReadView，该 ReadView 的 trx_ids 列表的内容就是 [20] ,up_limit_id 为20，low_limit_id 为 21，creator_trx_id 为 0。</p><p>步骤2:从版本链中挑选可见的记录，从图中看出，最新版本的列name的内容是’宋八’，该版本的 trx_id 值为 20，在 trx_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</p><p>步骤3:下一个版本的列 name 的内容是’钱七’，该版本的trx_id值为20，也在trx_ids列表内，所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’王五’，该版本的trx_id值为10，小于ReadView中的up_limit_id值为20，所以这个版本是符合要求的，最后返回给用户的版本就是这条列name为’王五’的记录。</p><p>其实也就创建了问题：不可以重复读，两次读出来的数据不一样。</p><h4 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h4><p>在 repeatable-read 隔离级别下，第二次使用的还是之前的 ReadView，这样读出来还是”张三”。</p><p>具体执行步骤：</p><p>步骤1∶因为当前事务的隔离级别为 REPEATABLE READ ，而之前在执行 SELECT1 时已经生成过 ReadView 了，所比时直接复用之前的 ReadView，之前的 ReadView 的 trx_ids 列表的内容就是 [10，20]，up_limit_id10 ， low_limit_id为21， creator_trx_id为0。</p><p>步骤2:然后从版本链中挑选可见的记录，从图中可以看出，最新版本的列name的内容是’宋八’，该版本的 trx_id 值为 20，在trx_ids 列表内，所以不符合可见性要求，根据 roll_pointer 跳到下一个版本。</p><p>步骤3:下一个版本的列 name 的内容是’钱七’，该版本的 trx_id值为20，也在 trx_ids 列表内所以也不符合要求，继续跳到下一个版本。</p><p>步骤4:下一个版本的列name的内容是’王五’，该版本的 trx_id 值为10，而 trx_ids 列表中是包含值为 10 的事务 id 的，所以该版本也不符合要求，同理下一个列 name 的内容是’李四’的版本也不符合要求。继续跳到下一个版本。</p><p>步骤5:下一个版本的列 name 的内容是’张三’，该版本的 trx_id 值为 80，小于 ReadView中 的 up_limit_id 值 10，所以这个版本是符合要求的，最后返回给用户的版本就是为’张三’的记录。</p><h4 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h4><p>如果是解决幻读问题，那么一定是在 repeatable-read 隔离级别下（前提）。</p><p>假设现在表 student 中只有一条数据，数据内容中，主键 id=1，隐藏的 trx_id=10，它的 undo log 如下表所示。</p><table><thead><tr><th>trx_id</th><th>data</th><th>roll_pointer</th></tr></thead><tbody><tr><td>10</td><td>id = 1，name = ‘张三’</td><td>NULL</td></tr></tbody></table><p>假设现在有事务 A 和事务 B 并发执行， 事务 A 的id 为20 ，事务 B 的事务 id 为30 。 </p><p>步骤1:事务 A 开始第一次查询数据，查询的 SQL 语句如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student where id &gt;&#x3D; 1;</span><br></pre></td></tr></table></figure><p>在开始查询之前，MySQL 会为事务 A 产生一个 ReadView ，此时 ReadView 的内容如下: trx_ids=[20,30]，up_limit_id=20，low_limit_id=31，creator_trx_id=20。</p><p>由于此时表 student 中只有一条数据，且符合where id&gt;=1条件，因此会查询出来。然后根据ReacView机制，发现该行数据的trx_id=10，小于事务 A 的 ReadView 里 up_limit_id ，这表示这条数据是事务A开启之前，其他事务就已经提交了的数据，因此事务A可以读取到’张三’这条数据。</p><p>步骤2∶接着事务B(trx_id=30)，往表student中新插入两条数据，并提交事务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into student( id , name) values(2,&#39;李四&#39;);</span><br><span class="line">insert into student ( id , name) values(3, &#39;王五&#39;);</span><br></pre></td></tr></table></figure><p>此时表student中就有三条数据了，对应的undo log 如下图所示:</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305123355941.png" alt="image-20220305123355941" style="zoom:50%;" /><p>步骤3:接着事务 A 开启第二次查询，根据可重复读隔离级别的规则，此时事务 A <strong>并不会再重新生成</strong> ReadView。此时表 student 中的 3 条数据都满足 where id&gt;=1 的条件，因此会先查出来。然后根据 ReadView 机制，判断每条数据是不是都可以被事务 A 看到。</p><ol><li>首先 id=1 的这条数据，前面已经说过了，可以被事务 A 看到。</li><li>然后是 id=2 的数据，它的 trx_id=30，此时事务 A 发现，这个值处于 up_limit_id 和 low_limit_id 之 间，因此还需要再判断 30 是否处于 trx_ids 数组内。由于事务 A 的 trx_ids=[20,30]，因此在数组内，这表 示 id=2 的这条数据是与事务 A 在同一时刻启动的其他事务提交的，所以这条数据不能让事务 A 看到。</li><li>同理，id=3 的这条数据，trx_id 也为 30，因此也不能被事务 A 看见。</li></ol><p>如图所示：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220305123543108.png" alt="image-20220305123543108" style="zoom:50%;" /><p>这不就解决幻读了咩！</p>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC（java 并发编程）</title>
      <link href="2022/02/17/JUC/"/>
      <url>2022/02/17/JUC/</url>
      
        <content type="html"><![CDATA[<center>持续性的学习才不会退步</center><a id="more"></a><h3 id="关于并发与多线程的一些思考"><a href="#关于并发与多线程的一些思考" class="headerlink" title="关于并发与多线程的一些思考"></a>关于并发与多线程的一些思考</h3><p>并发与多线程之间的关系就是目的与手段之间的关系。并发（Concurrent）的反面是串行。串行好比多个车辆行驶在一股车道上，它们只能“鱼贯而行”。而并发好比多个车辆行驶在多股车道上，它们可以“并驾齐驱”。并发的极致就是并行（Parallel）。多线程就是将原本可能是串行的计算“改为”并发（并行）的一种手段、途径或者模型。因此，有时我们也称多线程编程为并发编程。当然，目的与手段之间常常是一对多的关系。并发编程还有其他的实现途径，例如函数式（Functional programming）编程。多线程编程往往是其他并发编程模型的基础，所以多线程编程的重要性不言而喻。</p><p>关于 Java并发编程的主线：</p><p><strong>主线</strong>：线程与进程的关系，深挖就是单线程与多线程的关系，那么单线程怎么创建？有几种方式？有四种，那为什么有四种方式？这四种方式有什么不一样吗？然后多线程有什么问题？怎么保证线程安全？那什么是线程安全？保证线程安全需要锁，加锁有几种方式？（两种），那这两种是什么，一个是 Synchronized，一个是 JDK 提供的 Lock 的。这又是两条线，Synchronized能保证线程安全，还有什么关键字和他类似，Volatile，那他和 Synchronized 有什么区别？能保证线程安全？(不能)，那为什么不能保证？有什么机制？你什么时候使用过 Volatile，单例模式？那你手写一个单例？双重检查？其他类型的你会吗？刚刚你说到了Synchronized，那底层实现机制是什么？有多少锁？这几种锁有什么区别？锁机制是如何升级的？</p><p>在单线程与多线程之间，多线程主要是为了解决单线程运行的慢，而多线程能更好的让程序运行的更快，但是也不是一定变快的。</p><h2 id="1-并发编程带来的问题？"><a href="#1-并发编程带来的问题？" class="headerlink" title="1.并发编程带来的问题？"></a>1.并发编程带来的问题？</h2><ol><li>上下文切换</li><li>死锁</li><li>硬件和软件资源的限制</li></ol><p>上下文切换，就是线程用完CPU分配的时间片，然后保存当前状态，以便下次可以再切换回来，这就是上下文切换</p><p>死锁：就是两个线程分别等待对方释放锁，从而造成死锁。</p><h4 id="1-1如何减少上下文切换？"><a href="#1-1如何减少上下文切换？" class="headerlink" title="1.1如何减少上下文切换？"></a>1.1如何减少上下文切换？</h4><p>无锁并发编程</p><p>CAS 算法</p><p>使用最少线程</p><p>协程</p><h4 id="1-2-线程、进程、协程的区别？"><a href="#1-2-线程、进程、协程的区别？" class="headerlink" title="1.2 线程、进程、协程的区别？"></a>1.2 线程、进程、协程的区别？</h4><h2 id="2-Java-并发机制底层原理"><a href="#2-Java-并发机制底层原理" class="headerlink" title="2. Java 并发机制底层原理"></a>2. Java 并发机制底层原理</h2><p>Java并发机制底层依赖于 JVM 和 CPU指令。</p><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p><p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>]]></content>
      
      
      <categories>
          
          <category> JUC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM (Java 虚拟机)</title>
      <link href="2022/02/17/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>2022/02/17/%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>​        本篇文章主要在Java内存结构、垃圾收集器、类文件结构、类加载机制四个方面进行总结，能有效清晰的帮助在读的各位了解 Java 内存结构，Java 文件编译后是如何加载的、及如何管理虚拟机中的垃圾的。</p><a id="more"></a><h1 id="深度理解Java虚拟机"><a href="#深度理解Java虚拟机" class="headerlink" title="深度理解Java虚拟机"></a>深度理解Java虚拟机</h1><h2 id="一、Java内存结构"><a href="#一、Java内存结构" class="headerlink" title="一、Java内存结构"></a>一、Java内存结构</h2><h3 id="1-JVM内存结构"><a href="#1-JVM内存结构" class="headerlink" title="1. JVM内存结构"></a>1. JVM内存结构</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210905150636105.png" alt="image-20210905150636105"></p><ol><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>堆</li><li>方法区</li><li>运行时常量池（属于方法区）</li><li>直接内存（不属于 Java 内存结构）</li></ol><ul><li><strong>程序计数器</strong></li></ul><p>程序计数器属于线程私有的内存，</p><p>程序计数器主要有两个作用：</p><ol><li>当前线程所执行的字节码的行号指示器，通过改变它实现代码的流程控制，如：顺序执行、选择、循环、异常处理.</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> (OOM)的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><ul><li><strong>虚拟机栈</strong></li></ul><p>java虚拟机栈也是线程私有的，其生命周期与线程的相同。Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><p>Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表、操作数栈、动态链接、方法出口</strong>信息。每一次函数调用都会有一个对应的栈帧被压入虚拟机栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>局部变量表存放的是编译期可知的Java虚拟机基本数据类型、对象引用、returnAddress类型。</p><ul><li><strong>本地方法栈</strong></li></ul><p>虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈则是为虚拟机使用本地方法进行服务。HotSpot虚拟机直接把本地方法栈和虚拟机栈进行了合二为一，也会抛出<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</p><ul><li><strong>堆</strong></li></ul><p>在内存中占的位置最大，所有线程共享，此内存区域的存放的就是 <strong>对象实例</strong>，但是随着实现角度，并不是所有的对象都存在堆中。</p><p>Java 堆可以细分为：新生代（Eden 空间、From Survivor、To Survivor 空间）和老年代、永久代。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>通过 -Xms设定程序启动时占用内存大小，通过 -Xmx 设定程序运行期间最大可占用的内存大小。如果程序运行需要占用更多的内存，超出了这个设置值，就会抛出OutOfMemory异常。</p><ul><li><strong>方法区</strong></li></ul><p>方法区是<strong>所有线程</strong>共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区逻辑上属于堆的一部分。针对此部分回收目标主要是：<strong>常量池的回收</strong>和<strong>类型的卸载</strong></p><ol><li>永久代</li></ol><p>方法区是 JVM 的规范，而永久代（PermGen）是方法区的一种实现方式，并且只有 HotSpot 有永久代。而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。</p><ol start="2"><li>元空间</li></ol><p>JDK 1.8 的时候，HotSpot 的永久代被彻底移除了，使用元空间替代。元空间的本质和永久代类似，都是对JVM规范中方法区的实现。两者最大的区别在于：元空间并不在虚拟机中，而是使用直接内存。</p><p>为什么要将永久代替换为元空间呢?</p><p>永久代内存受限于 JVM 可用内存，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是相比永久代内存溢出的概率更小。</p><ul><li><strong>运行时常量池</strong></li></ul><p><strong>运行时常量池是方法区的一部分</strong>，在类加载之后，会将编译器生成的各种字面量和符号引号放到运行时常量池。在运行期间动态生成的常量，如 String 类的 intern()方法，也会被放入运行时常量池。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesstring-new.png" alt="img"></p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesstring-intern.png" alt="img"></p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesstring-equal.png" alt="img"></p><ul><li><strong>直接内存</strong></li></ul><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</p><p>NIO的Buffer提供了DirectBuffer，可以直接访问系统物理内存，避免堆内内存到堆外内存的数据拷贝操作，提高效率。DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制，不受最大堆内存的限制。</p><p>直接内存的读写操作比堆内存快，可以提升程序I/O操作的性能。通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到直接内存。</p><h3 id="2-对象的创建流程"><a href="#2-对象的创建流程" class="headerlink" title="2. 对象的创建流程"></a>2. 对象的创建流程</h3><p>当遇见 new 的时候</p><ol><li><p>先检查能否在常量池中定位到类的符号引用并且检查这个符号代表的类是不是已经被加载、解析和初始化过，有则说明初始化过，没有进行下一步。</p></li><li><p>为对象分配内存，有两种方式，<strong>指针碰撞和空闲列表</strong>。具体那种看采用了那种垃圾回收算法。</p><p>（这里引申出一个问题，多线程的时候如何解决内存分配时的并发问题？？见下面）</p></li><li><p>内存分配完成后，内存空间初始化为0，对象头除外。</p></li><li><p>设置对象头，这里需要设置这个对象时那个类的实例、如何才能找到类的元信息，对象的哈希码、对象的分代年龄等内容。</p></li><li><p>在执行class中初始化的方法，进行初始化。</p></li></ol><h3 id="3-如何解决分配内存时的并发问题？"><a href="#3-如何解决分配内存时的并发问题？" class="headerlink" title="3. 如何解决分配内存时的并发问题？"></a>3. 如何解决分配内存时的并发问题？</h3><ol><li>对分配内存空间的动作进行同步处理，实际上采用CAS失败重试的方式保证操作的原子性</li><li>给每个线程预先分配小的内存，成为本地内存缓冲（TLAB）本地内存缓冲完了，在新的缓存区时在进行同步锁定。</li></ol><h3 id="4-对象的内存布局（未整理）"><a href="#4-对象的内存布局（未整理）" class="headerlink" title="4. 对象的内存布局（未整理）"></a>4. 对象的内存布局（未整理）</h3><h3 id="5-Java对象的定位方式"><a href="#5-Java对象的定位方式" class="headerlink" title="5. Java对象的定位方式"></a>5. Java对象的定位方式</h3><p>Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有使用句柄和直接指针两种：</p><ul><li>如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。 </li><li>直接指针。reference 中存储的直接就是对象的地址。对象包含到对象类型数据的指针，通过这个指针可以访问对象类型数据。使用直接指针访问方式最大的好处就是访问对象速度快，它节省了一次指针定位的时间开销，虚拟机hotspot主要是使用直接指针来访问对象。</li></ul><h3 id="6-堆栈的区别"><a href="#6-堆栈的区别" class="headerlink" title="6. 堆栈的区别"></a>6. 堆栈的区别</h3><p><strong>物理地址</strong></p><p>堆的物理地址分配对对象是不连续的。在GC的时候需要考虑到不连续的分配，性能较慢。</p><p>栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。性能快。</p><p><strong>存放的内容</strong></p><p>堆存放的是对象的实例和数组。</p><p>栈存放：局部变量，操作数栈，返回结果。</p><p><strong>程序的可见度</strong></p><p>堆对于整个应用程序都是共享、可见的。</p><p>栈只对于线程是可见的，线程私有。</p><h3 id="7-什么情况下会发生栈溢出"><a href="#7-什么情况下会发生栈溢出" class="headerlink" title="7. 什么情况下会发生栈溢出"></a>7. 什么情况下会发生栈溢出</h3><p>当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常。通过调整参数<code>-xss</code>可以调整JVM栈的大小。</p><h2 id="二、垃圾收集器"><a href="#二、垃圾收集器" class="headerlink" title="二、垃圾收集器"></a>二、垃圾收集器</h2><h3 id="1-如何判断垃圾？有几种方法？"><a href="#1-如何判断垃圾？有几种方法？" class="headerlink" title="1. 如何判断垃圾？有几种方法？"></a>1. 如何判断垃圾？有几种方法？</h3><p>首先，内存中不再使用的就是垃圾，判断垃圾的方法有两种：<strong>引用计数法</strong>和<strong>可达性分析算法</strong>。</p><p>引用计数器中的算法存在弊端：很难解决互相引用的的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObjA.instance = ObjB</span><br><span class="line">ObjB.instance = ObjA</span><br></pre></td></tr></table></figure><p>可达性分析算法是从 GC Roots 开始向下搜索，如果一个对象没有被搜索到，那么这个对象就会被判定为死亡。</p><h3 id="2-可被作为-GC-Roots-对象的有哪些？"><a href="#2-可被作为-GC-Roots-对象的有哪些？" class="headerlink" title="2. 可被作为 GC Roots 对象的有哪些？"></a>2. 可被作为 GC Roots 对象的有哪些？</h3><ol><li>虚拟机栈(栈帧中本地变量表)中引用的对象，比如堆栈中使用到的参数、局部变量、临时变量。</li><li>在方法区中类的静态属性引用的对象，比如引用类型的静态变量。</li><li>在方法区中常量引用的对象，比如字符串常量池中引用的对象。</li><li>在本地方法栈中引用的对象。</li><li>还有一些基本数据类型对应的 Class 对象，一些异常对象，系统类加载器。</li><li>所以被同步锁持有的对象。</li><li>除了以上这些还有其他不确定的对象，比如只针对新生代进行垃圾回收，那么其他区域中引用新生代的都被列为 GC Roots。</li></ol><h3 id="3-强引用、软引用、弱引用、虚引用？"><a href="#3-强引用、软引用、弱引用、虚引用？" class="headerlink" title="3.强引用、软引用、弱引用、虚引用？"></a>3.强引用、软引用、弱引用、虚引用？</h3><ol><li><p>强引用就是最传统引用的定义。无论何种情况，垃圾收集器都不会回收掉这些被引用的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object A = <span class="keyword">new</span> Object()</span><br></pre></td></tr></table></figure></li><li><p>软引用引用着一些有用、但是不是必须的，如果内存空间足够就不会回收，但是空间不够，就要进行回收。</p></li><li><p>弱引用比软引用还弱。被关联的对象只能活到下一次垃圾收集之前，无论内存是否充足都会回收。</p></li><li><p>虚引用被称为“幽灵引用”或“幻影引用”，为一个对象设置虚引用的目的就是在垃圾回收的时候能够收到通知。</p></li></ol><h3 id="4-垃圾回收器的有哪些类别？"><a href="#4-垃圾回收器的有哪些类别？" class="headerlink" title="4.垃圾回收器的有哪些类别？"></a>4.垃圾回收器的有哪些类别？</h3><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220324095546407.png" alt="image-20220324095546407" style="zoom: 33%;" /><p>注意⚠️：上图 Parallel Old 是多线程，标记错了。</p><ol><li><p>Serial 收集器（新生代）</p><p>Serial收集器是一个<strong>单线程的收集器</strong>(采用的是<strong>复制算法</strong>暂停用户的线程)，这里单线程强调的是在进行垃圾回收前，必须进行暂停其他所有工作的线程（<strong>STW</strong>），优点就是简单而高效，没有线程交互的开销，能够专心做垃圾收集。只要是不频繁进行垃圾回收，那么用户是感觉不出来的，也是可以接受的。</p></li><li><p>ParNew 收集器（新生代）</p><p>是 Serial 收集器的并行版本。重复使用了 Serial 收集器的大部分代码，能与 CMS 收集器进行配合工作。采用的<strong>复制算法</strong></p></li><li><p>Parallel Scavenge 收集器（新生代）</p><p>和 ParNew 收集器非常相似，采用的<strong>复制算法</strong>，不同之处：他的目标是为了控制吞吐量</p></li><li><p>Serial Old 收集器（老年代）</p><p>采用的是<strong>标记-整理算法</strong>暂停用户的线程，但是是<strong>多线程</strong>的。</p></li><li><p>Parallel Old 收集器</p><p>是Parallel Scavenge的老年代版本，使用多线程，标记-整理算法。</p></li><li><p>CMS 收集器（老年代）（标记清除算法）</p><p>首次实现了让垃圾回收器和用户线程同时工作。</p><p>目的是<strong>为了获得最短停顿时间的收集器</strong></p></li><li><p>G1 收集器</p><p>面向全堆的收集器。</p></li></ol><h3 id="5-CMS垃圾收集器"><a href="#5-CMS垃圾收集器" class="headerlink" title="5. CMS垃圾收集器"></a>5. CMS垃圾收集器</h3><p>CMS(Consurrent Mark Sweep)收集器：以获取<strong>最短回收停顿时间</strong>为目标的收集器，采用<strong>标记-清除</strong>的算法实现的。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220322132430846.png" alt="image-20220322132430846"></p><p>四个过程：</p><ul><li>初始标记</li><li>并发标记</li><li>重新标记</li><li>并发清除</li></ul><p>其中初始标记和重新标记是STW（stop the world），而并发标记还有并发清楚耗时最长。</p><p>过程：</p><ol><li>初始标记主要是标记GC Roots能直接关联的对象，速度很快。</li><li>并发标记就是从GC Roots上直接关联的对象开始，遍历整个对象图，耗时较长但是不需要进行停顿用户线程。</li><li>重新标记是为了修正并发标记时间内，因用户线程继续运作而导致标记产生变动的那一部分标记记录。比并发标记时间短。</li><li>并发清除主要是清理删掉标记阶段被判断为死亡的对象。</li></ol><p>主要缺点：</p><ul><li>CMS收集器<strong>对处理器的资源非常敏感</strong>，(其实所有的收集器对处理器资源都比较敏感)，因为：如果处理器少了，在并发阶段，CMS对用户程序的影响就会变得很大。</li><li>CMS收集器无法处理<strong>浮动垃圾</strong>，“浮动垃圾”就是在并发标记和并发清除阶段，由用户线程继续运行产生的新的垃圾对象，只能等下次回收。</li><li>CMS收集器不能等老年代几乎被填满了再去收集，必须留一部分空间供并发阶段使用，可以进行参数设置。</li><li>因为CMS是标记-清除的，所以收集结束后会有大量空间碎片产生，这样可能会给大对象直接进入老年代产生影响，这时候就有可能会触发Full GC 。</li></ul><h3 id="6-G1-收集器"><a href="#6-G1-收集器" class="headerlink" title="6. G1 收集器"></a>6. G1 收集器</h3><p>G1收集器是<strong>面向全堆</strong>的垃圾收集器，它的目标就是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20211115164112865.png" alt="image-20211115164112865"></p><p>G1是基于Region的堆内存布局，但是还是遵循分代收集理论的。</p><p>停顿时间模型：在一个长度为M毫秒的时间片段内，消耗在垃圾回收的时间大概率不超过n毫秒。</p><h4 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h4><ul><li>Region中存在跨Region引用的对象怎么解决？</li></ul><p>使用记忆集来避免对全堆进行扫描，每个Region中都有记忆集，记忆集中都存在着指向自己的指针，也记录了自己指向谁，解决了这个问题，但是带来的缺点就是G1垃圾收集器比其他的垃圾收集器有着更高的内存负担，<strong>G1收集器</strong>要占用堆容量的10%-20%。</p><ul><li>并发阶段如何保证收集线程与用户线程互不干扰的进行？</li></ul><ol><li>G1垃圾收集器使用的是<strong>原始快照</strong>的方式来保证用户线程在并发阶段改变对象引用时，不会出现错误。</li><li>G1 为每一个 Region 区域设计了两个名为 TAMS（Top at Mark Start）的指针， 从 Region 区域划出一部分空间用于记录并发回收过程中的新对象。这样的对象认为它们是存活的，不纳入垃圾回收范围。</li></ol><ul><li>怎样建立起可靠的停等预测模型？</li></ul><p>G1收集器记录每个Region 的回收耗时，根据Region中记忆集记录的脏卡信息计算要花费的成本，然后确定那些Region回收在不超过期望停顿时间的约束下获得最高的收益。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20211115175101252.png" alt="image-20211115175101252"></p><h4 id="G1回收过程"><a href="#G1回收过程" class="headerlink" title="G1回收过程"></a>G1回收过程</h4><ol><li>初始标记：标记 GC Roots 能直接关联的对象，并修改 TAMS 的指针。</li><li>并发标记：从 GC Roots 开始对堆对象进行可达性分析，遍历对象图，找到要回收的对象。然后重新处理 SATB 记录下的用户线程造成的对象的变动。</li><li>最终标记：对用户线程进行短暂的暂停，再来处理并发阶段后仍遗留下来的最后的 SATB 记录。</li><li>筛选回收：负责更新Region的统计数据，对各个 Region 域的回收价值和成本进行排序，制定回收计划，确定要回收的Region，暂停用户线程，采用的是标记-复制的算法。</li></ol><h4 id="CMS-垃圾收集器与-G1-收集器对比"><a href="#CMS-垃圾收集器与-G1-收集器对比" class="headerlink" title="CMS 垃圾收集器与 G1 收集器对比"></a>CMS 垃圾收集器与 G1 收集器对比</h4><p>CMS 采用的是标记-清除算法，而 G1 整体上采用的是<strong>标记-整理</strong>算法（整个区域收集），局部采用的是<strong>标记-复制</strong>算法（一个区域收集完复制到另一个区域），这说明<strong>G1不会产生内存空间碎片</strong></p><p>G1垃圾收集器的缺点是：<strong>内存占用高</strong>和<strong>程序额外执行负载</strong>要高。</p><h4 id="CMS收集器和G1收集器的区别？"><a href="#CMS收集器和G1收集器的区别？" class="headerlink" title="CMS收集器和G1收集器的区别？"></a>CMS收集器和G1收集器的区别？</h4><ol><li>CMS收集器是<strong>老年代的收集器</strong>，可以配合新生代的Serial和ParNew收集器一起使用；G1收集器收集范围是<strong>老年代和新生代</strong>，不需要结合其他收集器使用；</li><li>CMS收集器<strong>以最小的停顿时间为目标</strong>的收集器；G1收集器<strong>可预测垃圾回收的停顿时间</strong>。</li><li>CMS收集器是使用<strong>“标记-清除”算法</strong>进行的垃圾回收，容易产生内存碎片。G1收集器使用的是<strong>“标记-整理”算法</strong>，进行了空间整合，降低了内存空间碎片。</li></ol><h2 id="三、-类文件结构"><a href="#三、-类文件结构" class="headerlink" title="三、 类文件结构"></a>三、 类文件结构</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count-<span class="number">1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             interfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             interfaces[interfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>魔数</strong>：class 文件标志。他决定了是否能够被虚拟机接受。</p><p><strong>文件版本</strong>：高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。</p><p><strong>常量池</strong>：存放字面量和符号引用。字面量类似于Java的常量，如字符串，声明为final的常量值等。符号引用包含三类：类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。</p><p><strong>访问标志</strong>：识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p><p><strong>当前类的索引this_class</strong>：类索引用于确定这个类的全限定名。</p><p><strong>属性表集合</strong>：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 Class 文件中其它的数据<a href="">项目</a>要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h2 id="四、类加载机制"><a href="#四、类加载机制" class="headerlink" title="四、类加载机制"></a>四、类加载机制</h2><h3 id="1、什么是类加载？类加载的过程？"><a href="#1、什么是类加载？类加载的过程？" class="headerlink" title="1、什么是类加载？类加载的过程？"></a>1、什么是类加载？类加载的过程？</h3><p>类加载机制就是：把描述类的数据加载到内存，然后对数据进行校验、转换解析和初始化。最终形成被虚拟机直接使用的java 类型。</p><p>类加载的过程：<strong>加载、验证、准备、解析、初始化、使用、卸载</strong></p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20211116214556489.png" alt="image-20211116214556489" style="zoom: 67%;" /><h3 id="2、类加载的过程"><a href="#2、类加载的过程" class="headerlink" title="2、类加载的过程"></a>2、类加载的过程</h3><h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1. 加载"></a>1. 加载</h4><p>此步骤需要做的是</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。 </li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 </li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li></ol><h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2. 验证"></a>2. 验证</h4><p>此步骤是为了确定加载到内存中的数据是安全的，不能危害虚拟机的安全。</p><p>这部分主要是对 <strong>文件格式验证、元数据验证、字节码验证、和符号引用验证</strong> </p><ol><li>文件格式验证</li></ol><p>主要是验证字节流是否符合 Class 文件格式的规范，并且能被当前虚拟机进行处理。</p><ul><li>是否以魔数开头</li><li>主次版本号是都在当前虚拟机中接受范围之内</li><li>常量池中的常量是是否有不被支持的常量类型</li><li>……</li></ul><ol start="2"><li>元数据验证</li></ol><p>此阶段主要是对字节码描述的信息进行语义分析，确保符合要求。</p><ul><li>这个类是否有父类</li><li>这个类的父类是不是继承了不允许继承的类</li><li>如果该类不是抽象类，那么该类是不是实现了其父类或者接口中要求的所有方法。</li><li>……</li></ul><ol start="3"><li>字节码验证</li></ol><p>字节码验证时验证过程中最复杂的一个阶段，主要是通过数据流分析和控制流分析，确定程序是合法的，是符合逻辑的。</p><ul><li>保证任意时刻操作数栈上的类型与指令代码序列都能配合工作。</li><li>……</li></ul><ol start="4"><li>符号引用验证</li></ol><p>此阶段的主要目的是确保解析行为能正常执行</p><ul><li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li><li>……</li></ul><h4 id="3-准备"><a href="#3-准备" class="headerlink" title="3. 准备"></a>3. 准备</h4><p>准备阶段进行内存分配的仅仅是类变量，实例变量实在对象初始化的时候才分配。这里静态变量初始化 0 值，如果是有final 关键字的常量，则直接赋值。</p><h4 id="4-解析"><a href="#4-解析" class="headerlink" title="4.解析"></a>4.解析</h4><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，符号引用就理解为一个标示，而在直接引用直接指向内存中的地址。</p><h3 id="3、类加载器的种类"><a href="#3、类加载器的种类" class="headerlink" title="3、类加载器的种类"></a>3、类加载器的种类</h3><ol><li>启动类加载器</li></ol><p>C++语言实现，他独立于虚拟机外部，他只加载 <JAVA_HOME>\lib 目录或者是 -Xbootclasspath 参数指定的路径存放的。启动类加载器是没法办法被Java程序直接调用的。如果强制调用，会显示 null 。</p><ol start="2"><li>扩展类加载器</li></ol><p>扩展类加载器负责加载 <JAVA_HOME>\lib\ext 目录中，或者被 java.ext.dirs 系统遍历所指定的路径中所有的类库。允许被用户扩展 Java SE 的功能。</p><ol start="3"><li>应用程序类加载器（系统类加载器）</li></ol><p>他负责加载类路径下的所有类库，开发者可以直接使用。在没有自己定义类加载器的情况下，这就是默认的类加载器。</p><ol start="4"><li>用户自定义类加载器</li></ol><p>通过继承 java.lang.ClassLoader 类的方式实现。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20211120143543051.png" alt="image-20211120143543051" style="zoom:50%;" /><p>四、什么情况下会对类立即执行初始化（在类的加载阶段）</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis面试题</title>
      <link href="2022/02/13/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2022/02/13/Redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<center>其他的路都不会获取真正的自由，唯有自身这条路没有堵死，所以...全靠自己。</center><a id="more"></a><h2 id="Redis-基础篇"><a href="#Redis-基础篇" class="headerlink" title="Redis 基础篇"></a>Redis 基础篇</h2><h3 id="1-Redis-与-Memcached-的共同点与区别？"><a href="#1-Redis-与-Memcached-的共同点与区别？" class="headerlink" title="1. Redis 与 Memcached 的共同点与区别？"></a>1. Redis 与 Memcached 的共同点与区别？</h3><p><strong>共同点：</strong></p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>不同点(区别)：</strong></p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。 </li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中，没有办法持久化，只能用于缓存使用，重启后数据全部丢失。</strong></li><li>Redis 支持数据恢复机制，因为可以把缓存中的数据持久化起来。</li><li>Redis 6 之前，Redis 网络 IO 模型是单线程的多路 IO 复用模型，6版本开始使用多线程。而 <strong>Memcached</strong> 是多线程，非阻塞 IO模式。</li><li>Redis 原生支持 cluster 模式，可以实现主从复制，读写分离。Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li></ol><h3 id="2-Redis-除了做缓存，还能做什么？"><a href="#2-Redis-除了做缓存，还能做什么？" class="headerlink" title="2. Redis 除了做缓存，还能做什么？"></a>2. Redis 除了做缓存，还能做什么？</h3><ul><li>消息队列</li></ul><p>Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</p><ul><li>分布式锁</li></ul><p>参考：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;mid=2451954663&amp;idx=1&amp;sn=4bd071b6aaede114263f88c790b61371&amp;chksm=8d1c2278ba6bab6eca2ef44f21b2178cc719fffe124289b68128c0dad72429fe5f286854157a&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=MzAwMjI0ODk0NA==&amp;mid=2451954663&amp;idx=1&amp;sn=4bd071b6aaede114263f88c790b61371&amp;chksm=8d1c2278ba6bab6eca2ef44f21b2178cc719fffe124289b68128c0dad72429fe5f286854157a&amp;scene=21#wechat_redirect</a></p><h3 id="3-Redis-运行快的原因？"><a href="#3-Redis-运行快的原因？" class="headerlink" title="3. Redis 运行快的原因？"></a>3. Redis 运行快的原因？</h3><ol><li>完全是内存层面的操作，数据存在内存中，跟传统的磁盘文件数据存储相比，避免了从磁盘 IO 读取到内存这部分开销。</li><li>IO 多路复用机制，减少了阻塞。</li><li>单线程避免了线程切换的开销和竞争问题。</li><li>最最根本的是 Redis 是用 C 语音写的，直接跟操作系统交互，命令执行快的飞起。</li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220223212722618.png" alt="image-20220223212722618"></p><h3 id="4-Redis-的优缺点？"><a href="#4-Redis-的优缺点？" class="headerlink" title="4. Redis 的优缺点？"></a>4. Redis 的优缺点？</h3><p>优点：</p><ul><li><p><strong>读写性能优异</strong>， Redis能读的速度是 110000 次/s，写的速度是 81000 次/s。</p></li><li><p><strong>支持数据持久化</strong>，支持 AOF 和 RDB 两种持久化方式。</p></li><li><p><strong>支持事务</strong>，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。</p></li><li><p><strong>数据结构丰富</strong>，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。</p></li><li><p><strong>支持主从复制</strong>，主机会自动将数据同步到从机，可以进行读写分离。</p></li></ul><p>缺点：</p><ul><li><strong>数据库容量受到物理内存的限制</strong>，不能用作海量数据的高性能读写，因此 Redis 适合的场景主要局限在较小数据量的高性能</li></ul><p>操作和运算上。</p><ul><li><p><strong>Redis 不具备自动容错和恢复功能</strong>，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。</p></li><li><p>主机宕机，<strong>宕机前有部分数据未能及时同步到从机</strong>，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。</p></li><li><p><strong>Redis 较难支持在线扩容</strong>，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费</p></li></ul><h3 id="5-Redis4-0-之前为什么选择单线程-多路-IO-复用"><a href="#5-Redis4-0-之前为什么选择单线程-多路-IO-复用" class="headerlink" title="5. Redis4.0 之前为什么选择单线程+多路 IO 复用"></a>5. Redis4.0 之前为什么选择单线程+多路 IO 复用</h3><p>题外话：<a href="https://www.cnblogs.com/felixzh/p/10345929.html">关于同步 IO、异步 IO、阻塞 IO、非阻塞 IO的联系与区别</a></p><p>Redis选择单线程的主要原因就是1⃣️<strong>CPU不是 Redis 服务器的瓶颈</strong>，其次就是2⃣️<strong>使用单线程模型能带来更好的维护行、方便开发和调试</strong>，最后3⃣️<strong>使用单线程模型也能并发的处理客户端的请求，因为采用的是I/O多路复用机制，可以统计等待多个连接发送的请求</strong>。</p><p>注意⚠️：Redis 4.0 之后加入多线程也是在个别命令上加入的多线程，对于处理所有网络请求来说，还是单线程的！！</p><p>参考文章<a href="https://draveness.me/whys-the-design-redis-single-thread/">https://draveness.me/whys-the-design-redis-single-thread/</a></p><h3 id="6-有-MySQL-了，为什么还需要用-Redis？"><a href="#6-有-MySQL-了，为什么还需要用-Redis？" class="headerlink" title="6. 有 MySQL 了，为什么还需要用 Redis？"></a>6. 有 MySQL 了，为什么还需要用 Redis？</h3><p>两方面回答：<strong>高性能</strong>和<strong>高并发</strong></p><p>高性能：如果我们查询数据时，会直接查找磁盘查询 MySQL，如果jing cha</p><h2 id="Redis-数据结构篇"><a href="#Redis-数据结构篇" class="headerlink" title="Redis 数据结构篇"></a>Redis 数据结构篇</h2><p>常用数据类型：<strong>String字符串、List列表、哈希Hash、Set集合、Zset有序集合</strong></p><p>新数据类型： <strong>Bitmaps、HyperLogLogs、GEO</strong></p><p>使用上面的五种数据类型实现了下面的数据结构</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220307111729075.png" alt="image-20220307111729075" style="zoom: 33%;" /><h3 id="1-SDS-简单动态字符串"><a href="#1-SDS-简单动态字符串" class="headerlink" title="1. SDS(简单动态字符串)"></a>1. SDS(简单动态字符串)</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol><li>保存字符串值</li><li>用作缓冲区( AOF 模块的 AOF 缓冲区、客户端状态的输入缓冲区)</li></ol><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220214170952086.png" alt="image-20220214170952086" style="zoom:50%;" /><h5 id="与-C-字符串的区别？"><a href="#与-C-字符串的区别？" class="headerlink" title="与 C 字符串的区别？"></a>与 C 字符串的区别？</h5><ol><li><p><strong>常数复杂度获取字符串的长度，时间复杂度为 O(1)</strong></p></li><li><p><strong>能有效杜绝缓冲区溢出</strong></p><p>C 字符串不仅不记录自身长度，而且没有分配足够多的内存的话，就会产生溢出。而 SDS 不会产生这样的问题，如果在插入的时候，先判断空间是不是满足，不满足先扩容，扩容完再放数据。</p></li><li><p><strong>减少修改字符串时带来的内存重分配次数（空间预分配、惰性空间释放）</strong></p><p>空间预分配——上面提到的扩容也是有机制的</p><ul><li>长度小于 1M 的，程序最终会分 (len 属性的大小*2+1)字节。</li><li>长度大于 1M 的，最后的空间是 (len 属性的大小+1M+1字节)</li></ul><p>惰性空间释放</p><p>当空间缩小的时候，会直接记录到 free 字段里。</p></li><li><p><strong>二进制安全的</strong></p><p>C 字符串只保存 ASCII 码，并且除了字符串的末尾，不能有空字符串，这些就导致了没办法存放图片、音频、视频等内容，而SDS 就随便放。它读取的是 len 的值，即使你有空字符串也继续读。使用的是 len 属性，而不是字符串里的空字符。</p></li><li><p><strong>兼容部分 C 字符串函数</strong></p></li></ol><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><ol><li>可以做链表键</li><li>发布与订阅（消息队列）</li><li>慢查询</li><li>监视器</li><li>保存多个客户端状态信息，比如朋友圈的点赞列表、评论列表、排行榜。</li><li>构建客户端输出缓冲区</li></ol><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220214175759234.png" alt="image-20220214175759234" style="zoom: 67%;" /><p>总结：</p><ol><li>获取某个节点的前一个或者后一个节点的时间复杂度都是 O(1).</li><li>无环结构，头节点的前一个和尾节点的后一个都是指向的null</li><li>获取表头节点和表尾节点的时间复杂度尾 O(1)</li><li>获取长度的时间复杂度也是 O(1)</li></ol><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h3><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><ol><li>Redis 底层数据库就是使用字典实现的</li><li>是哈希键的底层实现之一</li></ol><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220307154253240.png" alt="image-20220307154253240"></p><h5 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h5><ul><li>计算要添加键值对中键的 hash 值</li><li>然后再跟 sizemark 的值做计算，计算出索引值</li><li>如果键冲突，就头插法插入链表</li></ul><h5 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h5><p>1⃣️为什么rehash？</p><p>因为键值对逐渐增加或者减少，为了让负载因子维持在一个合理的范围，所以 rehash。</p><p>2⃣️rehash 的前提</p><ol><li>没有执行 BGSAVE 和 BGREWRITEAOF 命令 且 负载因子大于1</li><li>执行 BGSAVE 和 BGREWRITEAOF 命令 且 负载因子大于5</li></ol><p>主要是尽量避免在子进程存在期间进行 rehash 操作，最大的节约内存。</p><p>3⃣️ rehash 步骤</p><ol><li><p>为 ht[1] 分配空间</p><ul><li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于 ht [0].used*2的2的n次方幂;（大于等于已经使用的空间的2倍，最接近的2的n次方）</li><li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于 ht [0].used的2的n次方幂。</li></ul></li><li><p>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1] 哈希表的指定位置上。</p></li><li><p>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后(ht [0]变为空表)，释放ht[0]，将 ht[1] 设置为 ht[0]，并在ht [1]新创建一个空白哈希表，为下一次rehash做准备。</p></li></ol><h5 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h5><p>rehash 的操作不是一下子完成的，避免对服务器造成影响。</p><p><strong>步骤：</strong></p><ol><li>为 ht[1] 分配空间，让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li><li>在字典中维持一个索引计数器变量 rehashidx，并将它的值设置为 0 ，表示 rehash 工作正式开始。</li><li>在 rehash 进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1]，当 rehash 工作完成之后，程序将 rehashidx 属性的值增1。</li><li>随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1],这时程序将rehashidx属性的值设为 -1，表示rehash操作已完成。</li></ol><p>注意⚠️：在 rehash 的时候查找，会先找 ht[0]，再找 ht[1]。如果插入的话就直接插在 ht[1] 中。</p><h3 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h3><p><a href="https://blog.csdn.net/weixin_41622183/article/details/91126155">参考链接</a></p><p>数组：二分查找时间 O(logN)，插入和删除都是 O(N)。</p><p>链表：查找 O(N)，插入，删除 O(1)。</p><p>因为查找效率太低了，我们引进了跳跃表，使他的查找时间复杂度尽可能的接近 O(logN)。</p><h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><ul><li>有序集合键的底层实现之一 (zset)</li><li>集群节点中用作内部数据结构</li></ul><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>平均 O(logN)，最坏 O(n)，因为实现起来更简单，并且效率和平衡树相媲美。</p><h5 id="结构-3"><a href="#结构-3" class="headerlink" title="结构"></a>结构</h5><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220313194153270.png" alt="image-20220313194153270" style="zoom: 50%;" /><p><strong>为什么不用二叉查找树？</strong></p><p>因为二叉查找树存在极端情况，会形成链表，不稳定。</p><p><strong>为什么不用红黑树？</strong></p><p>因为红黑树是二叉查找树的变形，查找、插入、删除的复杂度均为O(logN)，但是红黑树在插入、删除节点时都需要调整结构，花的时间很多。</p><h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5. 整数集合"></a>5. 整数集合</h3><h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6. 压缩列表"></a>6. 压缩列表</h3><h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7. 对象"></a>7. 对象</h3><h3 id="8-Redis-数据结构使用场景"><a href="#8-Redis-数据结构使用场景" class="headerlink" title="8. Redis 数据结构使用场景"></a>8. Redis 数据结构使用场景</h3><p><a href="https://www.cnblogs.com/jasonZh/p/9513948.html">参考链接</a></p><p><strong>字符串：</strong></p><ol><li>保存字符串值</li><li>用作缓冲区( AOF 模块的 AOF 缓冲区、客户端状态的输入缓冲区)</li><li>分布式锁</li><li>计数器</li></ol><p><strong>list 链表</strong></p><ol><li>发布与订阅（消息队列）</li><li>保存多个客户端状态信息，比如朋友圈的点赞列表、评论列表、排行榜（最新消息排行榜）。</li></ol><p><strong>hash(字典)</strong></p><ol><li><p>购物车：hset [key] [field] [value] 命令， 可以实现以用户 Id，商品 Id 为 field，商品数量为 value，恰好构成了购物车的 3 个要素</p></li><li><p>存储对象：hash 类型的 (key, field, value) 的结构与对象的(对象id, 属性, 值)的结构相似，也可以用来存储对象。这里的field和 value 存储在map里，map 中的 key 为 属性 field，值为 value，</p></li></ol><p><strong>Set(集合)</strong></p><ol><li>好友、关注、粉丝、感兴趣的人集合</li><li>首页随机展示</li><li>存储某活动中中奖的用户 ID，因为去重功能，保证同一个用户不会中奖两次。</li></ol><p><strong>zset(有序集合)</strong></p><p>做排行榜，可以实现动态排序，比如：用来存储粉丝ID，score 存储的是粉丝按<strong>关注时间</strong>进行排序。</p><h3 id="9-三种特殊数据类型"><a href="#9-三种特殊数据类型" class="headerlink" title="9. 三种特殊数据类型"></a>9. 三种特殊数据类型</h3><h4 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h4><p>其实不是一种数据类型，可以看做成一个byte数组。</p><p>可以用来统计独立用户访问网站的情况。</p><h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>对唯一的事物计数。</p><h4 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a>Geospatial</h4><p>提供了经纬度设置，查询、范围查询、距离查询。</p><h2 id="Redis-持久化篇"><a href="#Redis-持久化篇" class="headerlink" title="Redis 持久化篇"></a>Redis 持久化篇</h2><h3 id="1-讲一下-Redis-中的持久化机制"><a href="#1-讲一下-Redis-中的持久化机制" class="headerlink" title="1. 讲一下 Redis 中的持久化机制"></a>1. 讲一下 Redis 中的持久化机制</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB 持久化方式是将 Redis 在内存中的数据库记录按照指定时间写入磁盘，实际操作过程是 fork 一个子进程，先将数据写入临时文件，写入成功后，在替换之前的文件，使用二进制压缩。</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF 持久化是以日志的形式记录服务器所处理的每一个写、删除操作。不会记录查询操作，以文本的方式记录，可以打开文件看到详细的操作记录。</p><h3 id="2-说一下-RDB-和-AOF-的优缺点？"><a href="#2-说一下-RDB-和-AOF-的优缺点？" class="headerlink" title="2. 说一下 RDB 和 AOF 的优缺点？"></a>2. 说一下 RDB 和 AOF 的优缺点？</h3><p>RDB 的优势</p><ul><li>适合大规模数据恢复（个人理解为启动效率高）</li><li>恢复速度快</li><li>可以对已经存在的 RDB 文件进行压缩，节省磁盘空间。</li><li>性能最大化，对于持久化的时候，他唯一做的就是 fork 出子进程，之后再由子进程完成这些持久化工作，这样就能极大的避免主进程 IO 操作了。</li></ul><p>RDB 的缺点</p><ul><li>最后的一次修改可能会丢失（因为它是周期性做备份的）</li><li>虽然Redis在fork时使用了<strong>写时拷贝技术</strong>，但是如果数据庞大时还是比较消耗性能。</li><li>fork 的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。</li></ul><p>AOF 的优点</p><ul><li>可以让数据更安全，丢失数据概率更低。</li><li>可读的日志文本，可以处理误操作。</li><li>AOF 对日志文件的写入是追加的方式，所以即使在追加的时候出现宕机，之前的操作也是没什么问题的，而且 Redis 还有工具可以解决问题。</li></ul><p>AOF 的缺点</p><ul><li>比起 RDB 更占空间（因为不仅仅保存数据还保存操作的记录）</li><li>恢复速度比较慢（因为需要一条条执行完指令）</li><li>存在 bug，可能造成不能恢复</li></ul><h3 id="3-RDB-和-AOF-选哪一个？"><a href="#3-RDB-和-AOF-选哪一个？" class="headerlink" title="3. RDB 和 AOF 选哪一个？"></a>3. RDB 和 AOF 选哪一个？</h3><p>这个要具体情况具体分析</p><p>如果只是拿 Redis 做内存缓存的话，那么就都不用</p><p>如果对于数据很敏感，可以使用 AOF，但是不建议单独使用，可以也打开 RDB。</p><p>如果对数据不敏感而且还要进行保存，那么仅使用 RDB 进行存储</p><h2 id="Redis-事务篇"><a href="#Redis-事务篇" class="headerlink" title="Redis 事务篇"></a>Redis 事务篇</h2><h3 id="1-Redis-事务的概念？"><a href="#1-Redis-事务的概念？" class="headerlink" title="1. Redis 事务的概念？"></a>1. Redis 事务的概念？</h3><p>Redis 事务的本质就是通过 MULTI、EXEC、WATCH等一组命令的集合，事务支持一次执行多条命令，一个事务中所有的命令都会被序列化，在事务执行的过程中，会按照顺序串型化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令中去。</p><p>MULTI(multi)：命令开启一个事务，执行该命令后，一系列操作会被放入事务中。</p><p>EXEC(exec)：命令执行，一系列操作完成。</p><p>WATCH(watch)：监视某一个键，如果被监视的键被修改了，那么这个事务就无法执行。</p><p>DISCARD(discard)：清空队列，放弃执行事务。</p><h3 id="2-Redis-事务的三个阶段、三个特性"><a href="#2-Redis-事务的三个阶段、三个特性" class="headerlink" title="2. Redis 事务的三个阶段、三个特性"></a>2. Redis 事务的三个阶段、三个特性</h3><p>三阶段：</p><ol><li>开启事务</li><li>入队</li><li>执行</li></ol><p>三特性：</p><ol><li>单独的隔离操作：事务的所有命令都会序列化，按顺序执行，事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断。</li><li>没有隔离级别的概念，因为每一条命令都攒着，一直到执行EXEC命令</li><li>不保证原子性：因为如果一个事务里面的一条命令执行失败，其后面的命令依旧执行，没有回滚。</li></ol><p>注意⚠️：在组队（入队）的时候出错，执行时整个的所有队列都会被取消。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220317164915654.png" alt="image-20220317164915654" style="zoom:50%;" /><p>但是在执行过程中出错的时候，那么就不保存原子性了，其他都执行，错误的就不执行。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220317165129224.png" alt="image-20220317165129224" style="zoom:50%;" /><h3 id="3-Redis-事务保证原子性吗？支持回滚吗？"><a href="#3-Redis-事务保证原子性吗？支持回滚吗？" class="headerlink" title="3.Redis 事务保证原子性吗？支持回滚吗？"></a>3.Redis 事务保证原子性吗？支持回滚吗？</h3><p>在 Redis 中，单条命令是原子性支持的，但是事务不保证原子性的，且没有回滚。</p><h2 id="Redis-集群篇"><a href="#Redis-集群篇" class="headerlink" title="Redis 集群篇"></a>Redis 集群篇</h2><p>主从复制的原理：</p><ul><li>当从服务器连上主服务器的时候，从服务器向主服务器发送数据同步消息</li><li>主服务器连接到从服务器发送过来的同步消息后，把主服务器数据进行持久化RDB文件，把 RDB 文件发送给从服务器，然后，从服务器拿到文件后进行读取。</li><li>每次主服务器进行写操作了，这个时候主服务器主的进行数据同步。</li></ul><h2 id="Redis-内存篇"><a href="#Redis-内存篇" class="headerlink" title="Redis 内存篇"></a>Redis 内存篇</h2><h3 id="1-Redis-的过期键的删除策略？"><a href="#1-Redis-的过期键的删除策略？" class="headerlink" title="1. Redis 的过期键的删除策略？"></a>1. Redis 的过期键的删除策略？</h3><p>可供选择的过期键的删除策略有三种</p><ul><li>定时删除</li></ul><p>在设置键的同时，创建了一个定时器，让定时器在键过期的时候，执行删除操作</p><ul><li>惰性删除</li></ul><p>过期的键放在内存中不管，每次从键空间中获取键的时候，先判断键是不是过期了，如果过期了的话，就删除该键，没有过期就返回值。</p><ul><li>定期删除</li></ul><p>每隔一段时间就对数据库进行一次检查，删除里面过期的键。</p><p>定时和定期属于<strong>主动删除</strong>，惰性删除属于<strong>被动删除</strong>。</p><p><strong>优缺点</strong></p><p>定时删除对内存使用率有优势，但是对 CPU 不友好。</p><p>惰性删除对内存不友好，如果某些键过期了，但是没有被使用，那么就会一直在内存中。</p><p>定期删除是定时删除和惰性删除对折中。</p><p>Redis 只用了两种：<strong>惰性删除和定期删除</strong></p><h3 id="2-Redis-的淘汰策略有哪些？"><a href="#2-Redis-的淘汰策略有哪些？" class="headerlink" title="2. Redis 的淘汰策略有哪些？"></a>2. Redis 的淘汰策略有哪些？</h3><ul><li><p>volatile-lru（least recently used）：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。</p></li><li><p>volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。</p><p>理解：也就是移除那些 TTL（Time To Live） 值最小的 key，即那些最近要过期的 key。</p></li><li><p>volatile-random：从已设置过期时间的数据集中任意选择数据淘汰。</p></li><li><p>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p></li><li><p>allkeys-random：从数据集中任意选择数据淘汰。</p></li><li><p>no-eviction（禁止驱逐）：不进行移除。也就是说当内存不足以容纳新写入数据时，新写入操作会报错。</p></li></ul><p>4.0 版本后增加两种：</p><ul><li><p>volatile-lfu：从已设置过期时间的数据集中<strong>挑选最不经常使用的</strong>数据淘汰。</p></li><li><p>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除<strong>最不经常使用的</strong> key。</p></li></ul><h2 id="Redis-应用问题解决篇"><a href="#Redis-应用问题解决篇" class="headerlink" title="Redis 应用问题解决篇"></a>Redis 应用问题解决篇</h2><h3 id="1-Redis-如何实现分布式锁？"><a href="#1-Redis-如何实现分布式锁？" class="headerlink" title="1. Redis 如何实现分布式锁？"></a>1. Redis 如何实现分布式锁？</h3><p>参考链接：<a href="https://www.zhihu.com/question/300767410/answer/1749442787">https://www.zhihu.com/question/300767410/answer/1749442787</a></p><h5 id="问题出现的原因"><a href="#问题出现的原因" class="headerlink" title="问题出现的原因"></a>问题出现的原因</h5><p>单机中，我们使用本地锁就可以避免多个操作同一个问题，但是在分布式系统中，肯容易就是多个服务器修改同一个数据，又因为读取和更新不是一个操作，所以原来的本地锁就派不上用场，这个时候就就需要分布式锁，它的作用就是<strong>保证多台服务器在执行某一段代码时保证只有一台服务器执行</strong>。</p><h5 id="如果实现分布式锁，需要满足的条件"><a href="#如果实现分布式锁，需要满足的条件" class="headerlink" title="如果实现分布式锁，需要满足的条件"></a>如果实现分布式锁，需要满足的条件</h5><ol><li>互斥性，任何时刻，保证只有一个客户端持有锁。</li><li>不能出现死锁，即使崩溃也要按时释放。</li><li>解锁和释放必须是同一个客户端。</li></ol><h5 id="目前可以实现的方式"><a href="#目前可以实现的方式" class="headerlink" title="目前可以实现的方式"></a>目前可以实现的方式</h5><ul><li>使用 MySQL 实现分布式锁</li><li>基于缓存（Redis）也是我们要讲的（性能最高）</li><li>基于 Zookeeper（最可靠）</li></ul><h5 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h5><p>使用<code>setnx key 1</code>设置锁，使用<code>del key</code>删除锁。</p><p>出现的问题：处理业务时，没及时释放锁，或者进程挂了，没释放锁。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220309123853020.png" alt="image-20220309123853020" style="zoom: 50%;" /><h5 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h5><p>对情况一改进，先执行 <code>setnx key 1</code>,再执行 <code>expire key 10</code>,设置过期时间。</p><p>出现的问题：只执行完了第一条命令，却没来的及执行第二条命令。</p><h5 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h5><p>对情况二改进，执行<code>set key 1 ex 10 nx</code>,这样就是原子操作了，也解决了死锁问题</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220309124333628.png" alt="image-20220309124333628" style="zoom: 50%;" /><p>出现的两个问题：</p><ol><li>客户端A加锁成功，开始操作共享资源，<strong>但是操作共享资源的时间</strong>，锁自动释放。</li><li>客户端A加锁成功，开始操作共享资源，共享资源已经完了，这个时候释放了锁（释放锁的机制有两个，一个操作完就放，一个是过期了释放），又经过其他客户端操作后，过期了，释放了其他客户端的锁。</li></ol><h5 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h5><p>解决上面第一个问题就是<strong>给锁续期</strong>。在 Redisson 框架实现分布式锁的思路，就使用 watchDog 机制实现锁的续期。当加锁成功后，同时开启守护线程，默认有效期是30秒，每隔10秒就会给锁续期到30秒，只要持有锁的客户端没有宕机，就能保证一直持有锁，直到业务代码执行完毕由客户端自己解锁，如果宕机了自然就在有效期失效后自动解锁。</p><p>解决第二个问题就是<strong>使用UUID</strong>，<code>set key UUID ex 10 nx</code>，在删除的时候，判断是不是自己持有的。因为是判断的，所以不是原子性操作，这里需要用到 <strong>Lua 脚本</strong></p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220309125237765.png" alt="image-20220309125237765" style="zoom: 50%;" /><h5 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h5><p>锁只能加一次，不可重入啊，解决方式如下：</p><p>在Redisson实现可重入锁的思路，使用Redis的哈希表存储可重入次数，当加锁成功后，使用<code>hset</code>命令，value(重入次数)则是1。如果同一个客户端再次加锁成功，则使用<code>hincrby</code>自增加一。解锁时，先判断可重复次数是否大于0，大于0则减一，否则删除键值，释放锁资源。</p><p><strong>情况六</strong>：如果加锁失败的情况下，总不可能一直轮询尝试加锁，直到加锁成功为止，这样太过耗费性能。所以需要利用发布订阅的机制进行优化。</p><p>当加锁失败后，订阅锁释放的消息，自身进入阻塞状态。</p><p>当持有锁的客户端释放锁的时候，发布锁释放的消息。</p><p>当进入阻塞等待的其他客户端收到锁释放的消息后，解除阻塞等待状态，再次尝试加锁。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220309125916161.png" alt="image-20220309125916161" style="zoom:67%;" /><h5 id="情况七"><a href="#情况七" class="headerlink" title="情况七"></a>情况七</h5><p>之前分析的都是单个 Redis 实例中可能产生的问题，如果在集群中呢？</p><p>场景：</p><ol><li>客户端 A 在主库上执行 SET 命令，加锁成功</li><li>此时，主库异常宕机，SET 命令还未同步到从库上(主从复制是异步的)</li><li>从库被哨兵提升为新主库，这个锁在新的主库上，丢失了!</li></ol><p>解决方式 ： <strong>RedLock</strong></p><h3 id="2-Redis-如何实现消息队列？"><a href="#2-Redis-如何实现消息队列？" class="headerlink" title="2. Redis 如何实现消息队列？"></a>2. Redis 如何实现消息队列？</h3><p><a href="https://www.zhihu.com/question/20795043">参考链接-@Kaito</a></p><p><a href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html#%E4%B8%80%E3%80%81%E5%9B%9E%E9%A1%BE%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">参考链接-JavaKeeper</a></p><p>三种方式：</p><ul><li>List 队列</li><li>发布/订阅模型</li><li>Stream 趋于成熟的队列</li></ul><p>其实还有一种是专业的消息队列，比如 kafka、RabbitMQ。</p><p>先介绍一下什么是消息队列：</p><p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于<strong>数据通信</strong>来进行分布式系统的集成。通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220328112944756.png" alt="image-20220328112944756"></p><h4 id="List-队列"><a href="#List-队列" class="headerlink" title="List 队列"></a>List 队列</h4><ol><li><p>模型简单，一边生产者生产消息，一边消费者拉取消息.</p><p>存在的问题：没有消息就一直拉取，这个时候就会导致 CPU 空转。如果要是让拉取消息睡眠一会，就有可能<strong>导致新消息延迟消费</strong>。</p></li><li><p>改进：使用 BRPOP/BLPOP ，这里的 B 是阻塞的意思。没有消息就阻塞，有了消息就能消费了。</p><p>存在的问题：</p><ul><li>不支持多个消费者重复消费，消费者拉取消息后，List 上就被删除了，无法被其他消费者消费。</li><li>消息丢失，消费者拉取消息后宕机了，那这条消息就丢失了。</li></ul></li></ol><p>解决方式看发布/订阅模型</p><h4 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h4><p>可以解决了 List 队列不可重复消费的问题，多个消费者订阅同一个生产者，当生产者有消息时，通知消费者，并且一个消费者可以订阅多个生产者。但是存在的问题就是<strong>丢数据</strong>。</p><p>发生的场景：1. 消费者下线。2. Redis 宕机。3.消息堆积</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220310133039176.png" alt="image-20220310133039176" style="zoom:50%;" /><p>我们可以看到，发布/订阅模型不存储数据，只是转发给消费者。<strong>没有数据持久化的能力。</strong></p><p>如果消费者下线了，那再次上线只能接受新的消息。</p><p>如果 Redis 宕机，Pub/Sub 的数据也会全部丢失。</p><p><strong>消费者必须先订阅队列，生产者才能发布消息，否则消息会丢失。</strong></p><p>如果生产者生产速度比较快，对于List来说，可能就是链表过长，内存持续增长，如果是 Pub/Sub 模式，因为消费者每次订阅一个队列，都会给消费者一个缓冲区（也就是一块内存），当生产者发布消息的时候，就会把消息写到订阅这个的消费者的缓冲区，之后消费者在缓冲区读取消息，但是消费者缓冲区是有限制的，如果超过了缓冲区，那就会把这个消费者踢下线。也就导致消费失败，丢失数据。</p><p>发布/订阅的优缺点：</p><ol><li><p>支持发布/订阅。支持多组生产者，消费者处理消息。（优点）</p></li><li><p>消费者下线，消息丢失。</p></li><li><p>不支持数据的持久化，Redis 宕机，数据丢失。</p></li><li><p>消息堆积，缓冲区溢出，消费者被踢，数据丢失。</p></li><li><p>从缓冲区取走数据，也就在 Redis 缓冲区中删除了，消费者异常，无法重新消费。</p></li></ol><p>我们希望的是：</p><ol><li>支持阻塞式拉取消息</li><li>支持发布/订阅模式</li><li>消费失败，可以重新消费。</li><li>实例宕机，消息不丢失，数据可持久化。</li><li>消息可堆积。</li></ol><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>Stream 使用 XADD 和 XREAD 完成生产消费，也支持阻塞式拉取消息，也支持发布/订阅模式，当消费完成后，会执行 XACK 命令告知 Redis，Redis 就会标记为处理完成。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220310135257343.png" alt="image-20220310135257343" style="zoom:50%;" /><p>Stream 和其他数据类型一样，写操作都会写入到 RDB 和 AOF 中。</p><p>对于消息堆积，两个解决方法，1. 生产者限流。2. 丢弃消息：中间件丢弃消息，只保留固定长度新消息。所以，当消息积压的时候，还是会丢失消息。有小瑕疵，如果继续对比，那就是与专业的消息队列对比了。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220329095832473.png" alt="image-20220329095832473" style="zoom:50%;" /><h3 id="3-缓存穿透、缓存击穿、缓存雪崩"><a href="#3-缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="3. 缓存穿透、缓存击穿、缓存雪崩"></a>3. 缓存穿透、缓存击穿、缓存雪崩</h3><h4 id="3-1-缓存穿透"><a href="#3-1-缓存穿透" class="headerlink" title="3.1 缓存穿透"></a>3.1 缓存穿透</h4><p>既不存在于内存数据库 Redis，也不存在于数据库 MySQL。</p><p>问题理解：缓存穿透就是大量请求的数据key并不在缓存和数据库中，导致直接请求到了数据库，从而可能压垮数据库。举个例子，黑客故意制造我们缓存中不存在的 Key，而发起大量请求，就会可能导致我们数据库宕机。</p><p>解决方案：</p><ul><li><p>首先是做好参数校验，应该对无效请求直接抛出异常。</p></li><li><p>对无效key缓存：如果这个数据不在数据库中，那么直接存在缓存中设置，最长不超过5分钟。</p></li><li><p>设置可访问名单（待定）</p></li></ul><p>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问。</p><ul><li>采用布隆过滤器</li></ul><p>它实际上是一个很长的二进制向量(位图)和一系列随机映射函数(哈希函数)。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。将所有可能存在的数据哈希到一个足够大的 bitmaps 中，一个一定不存在的数据会被这个 bitmaps 拦截掉，从而避免了对底层存储系统的查询压力。</p><ul><li>进行实时监控</li></ul><p>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务。</p><h4 id="3-2-缓存击穿（针对一个Key）"><a href="#3-2-缓存击穿（针对一个Key）" class="headerlink" title="3.2 缓存击穿（针对一个Key）"></a>3.2 缓存击穿（针对一个Key）</h4><p>问题理解：缓存中存在一个刚刚过期的key，还没有被清除，同时有大量请求去访问这个 key 时，同时去数据库中读取数据。可能会把数据库压垮。</p><p>解决方案：</p><ul><li>预先设置热门数据：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li><li>实时调整：现场监控哪些数据热门，实时调整key的过期时长</li><li>使用锁。这样可以保证只有一个用户请求去访问数据库并缓存到Redis中，其他请求可以通过再次访问Redis即可。</li></ul><h4 id="3-3-缓存雪崩（针对大量Key）"><a href="#3-3-缓存雪崩（针对大量Key）" class="headerlink" title="3.3 缓存雪崩（针对大量Key）"></a>3.3 缓存雪崩（针对大量Key）</h4><p>问题理解：缓存中的数据 key 大量到过期时间，而查询数据量巨大，可能引起数据库压力过大或者宕机。</p><p>解决方案：</p><ul><li>将缓存失效时间设置随机，防止大量数据同时过期现象的发生。</li><li>设置热点数据永不过期。</li><li>如果缓存数据是分布式部署，可以将数据均匀分布在不同的缓存数据库中。</li></ul><h3 id="4-如何解决数据不一致性？（Redis-MySQL）"><a href="#4-如何解决数据不一致性？（Redis-MySQL）" class="headerlink" title="4. 如何解决数据不一致性？（Redis - MySQL）"></a>4. 如何解决数据不一致性？（Redis - MySQL）</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">不理解？点我看原文！</a></p><p>数据的不一致性：是指假如一个数据访问者同时读取Redis 和数据库，在一段时间里发现这两个数据不一致。</p><p>解决的办法有两种：</p><p>第一种：先删除缓存，在更新数据库。</p><p>第二种：先更新数据库，在删除缓存。</p><p>从两个方面考虑，<strong>并发</strong>和<strong>第二步操作失败</strong>的情况。</p><p><strong>对于并发角度：</strong></p><p>如果有两个线程要并发读写数据，就可能造成数据不一致。</p><ul><li>先删除缓存，再更新数据库</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">线程A写，线程B读 （同时操作 x = 1）</span><br><span class="line">1. 线程A删除缓存</span><br><span class="line">2. 线程B读取x=1</span><br><span class="line">3. 线程A将数据写入 x=2</span><br><span class="line">4. 线程B将旧值写入缓存。</span><br></pre></td></tr></table></figure><ul><li>先更新数据库，在删除缓存</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程A读，线程B写 （同时操作 x &#x3D; 1）</span><br><span class="line">1. 缓存中的x失效了</span><br><span class="line">1. 线程A读取数据x&#x3D;1</span><br><span class="line">2. 线程B更新数据库x&#x3D;2</span><br><span class="line">3. 线程删除缓存</span><br><span class="line">4. 线程A将旧值x&#x3D;1写入缓存。</span><br></pre></td></tr></table></figure><p>但是这种情况概率很低，需要满足以下条件：</p><ul><li>缓存刚刚失效</li><li>读请求与写请求并发</li><li>更新数据库+删除缓存时间要比读数据库+写缓存时间短，但是更新数据库都要加锁，通常时间更长。</li></ul><p>所以，这种情况是可以保证数据一致性的。</p><p><strong>对于第二步操作失败的情况：</strong></p><p>无论是上面两种情况的哪一种，只要是第二步失败，就会导致不一致性，因此，解决问题的关键就是让第二步执行成功。我们可以采取 <strong>重试</strong> 的方法，但是立即重试会大概率失败，并且也不知道设置多少重试次数才合理。所以才有<strong>异步重试</strong>。把重试请求写入到消息队列里。让消息队列保证第二步执行成功。</p><p>另外一种方案就是：订阅数据库变更日志，再操作缓存。只要是修改了数据库，那就有相应的变更日志，拿到具体操作（用阿里的canal），再去删除缓存。这种情况的优点就是(1).无需考虑消息队列失败的情况。(2).自动投递下层队列。</p><p>总结：如果想要保证数据库与缓存的一致性，推荐采用 <strong>更新数据库+再删除缓存的方案，配合消息队列或订阅变更日志的方式来做。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="2022/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>2022/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>​        本片主要梳理计算机网络基础知识，整理常见的面试题～</p><a id="more"></a><h2 id="一、OSI，TCP-IP，五层协议的体系结构，以及各层协议"><a href="#一、OSI，TCP-IP，五层协议的体系结构，以及各层协议" class="headerlink" title="一、OSI，TCP/IP，五层协议的体系结构，以及各层协议"></a><strong>一、OSI，TCP/IP，五层协议的体系结构，以及各层协议</strong></h2><h3 id="1-体系结构"><a href="#1-体系结构" class="headerlink" title="1. 体系结构"></a>1. 体系结构</h3><p>五层协议从上向下：应用层、传输层、网络层、数据链路层、物理层</p><p>七层协议从下到上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p><h3 id="2-各层协议"><a href="#2-各层协议" class="headerlink" title="2. 各层协议"></a>2. 各层协议</h3><p>物理层：RJ45、CLOCK、IEEE802.3   （中继器，集线器，网关） </p><p>数据链路层：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） </p><p>网络层：<strong>IP、ICMP、ARP、RARP</strong>、OSPF、IPX、RIP、IGRP、 （路由器） </p><p>传输层：<strong>TCP、UDP、</strong>SPX </p><p>（不是重点）会话层：NFS、SQL、NETBIOS、RPC </p><p>（不是重点）表示层：JPEG、MPEG、ASII </p><p>应用层：<strong>FTP、DNS、</strong>Telnet、<strong>SMTP、HTTP</strong>、WWW、NFS</p><h3 id="3-各层作用"><a href="#3-各层作用" class="headerlink" title="3. 各层作用"></a>3. 各层作用</h3><p>应用层：通过应用进程之间的交互来完成特定网络应用。</p><p>传输层：负责向两台主机进程之间的通信<strong>提供通用的数据传输服务</strong>（TCP、UDP）。</p><p>网络层：负责为分组交换网上的不同主机提供通信服务。</p><p>数据链路层：将网络层交下来IP数据报组装成帧、在结点与结点之间进行传播</p><p>物理层：通过媒介传输比特,确定机械及电气规范</p><h2 id="二、运输层"><a href="#二、运输层" class="headerlink" title="二、运输层"></a>二、运输层</h2><p>运输层主要是为<strong>两台主机应用进程之间</strong>提供端到端的逻辑通信</p><h3 id="1、TCP的三次握手过程"><a href="#1、TCP的三次握手过程" class="headerlink" title="1、TCP的三次握手过程"></a>1、TCP的三次握手过程</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211112192025828.png" alt="image-20211112192025828"></p><ol><li>起初、两台主机都是关闭状态、这时候，主机 B 先创建 TCB 模块，从 Closed 状态变为Listen状态。</li><li>A 进程也是创建传输控制模块TCB，在创建连接时，设置SYN=1，seq=x，seq是初始序号</li><li>B 收到后，设置SYN=1，ACK=1（建立连接后所有的报文段ACK都设置为1），并同时设置自己的序号y（seq=y）和期待对方发送到序号x+1。</li><li>客户端收到后，ACK=1，并设置客户端期望的序列号y+1，并发送自己的序列号x+1</li></ol><p><strong>注</strong>：也是可以改为四报文握手的，而不是四次握手。</p><h3 id="2、TCP的四次挥手过程"><a href="#2、TCP的四次挥手过程" class="headerlink" title="2、TCP的四次挥手过程"></a>2、TCP的四次挥手过程</h3><p>首先，需要确定的是TCP是全双工的，也就是说，客户端A与服务器B能互相发送接受信息。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211112195257985.png" alt="image-20211112195257985"></p><ol><li>客户端设置FIN=1，seq=u，（seq为已传送过的数据序号加一），此时A进入终止等待1（FIN-WAIT-1）</li><li>B接收到后设置ACK=1，并且ack=u+1（期望对方发送u+1 的报文段）、然后seq=v，是自己的报文段序号，B就进入close-wait状态，这时候，就处于<strong>半关闭</strong>的状态，这时候只是A不能给B发送含有数据的数据报，可是B是可以向A发送的数据的，或许这时候，B向A发送了好多数据。</li><li>当 B 发送完，B会发送FIN=1，ACK=1，seq=w（可能向上面所说的又发送了数据，这时候再发送就是w了）ack=u+1，一直期待A能发送u+1，B就进入了Last-ack状态</li><li>A 收到 B 发送的释放连接的信号，ACK=1，seq=u+1，ack=w+1，此时A就进入了time-wait 状态，这里并没有直接把链接释放掉，需要等待<strong>2MSL</strong>，MSL为最长报文段寿命</li></ol><h3 id="3、为什么客户端在-TIME-WAIT-状态必须等待-2MSL？"><a href="#3、为什么客户端在-TIME-WAIT-状态必须等待-2MSL？" class="headerlink" title="3、为什么客户端在 TIME-WAIT 状态必须等待 2MSL？"></a>3、为什么客户端在 TIME-WAIT 状态必须等待 2MSL？</h3><p>第一，为了保证A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN＋ACK报文段的确认。B会 时重传这个FIN＋ACK报文段，而A就能在2MSL时间内收到这个重传的FIN＋ACK报文段。接着A重传一次确认，重新启动2MSL计时器。最后，A和B都正常进入到 CLOSED状态。如果A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后 立即释放连接，那么就无法收到B重传的FIN＋ACK 报文段，因而也不会再发送一次 确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。</p><p>第二，防止上一节提到的“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间 2 MSL，就可以使本连接持续的时间内所产 生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。</p><h3 id="4、为什么-TCP-需要三次握手，两次不行？"><a href="#4、为什么-TCP-需要三次握手，两次不行？" class="headerlink" title="4、为什么 TCP 需要三次握手，两次不行？"></a>4、为什么 TCP 需要三次握手，两次不行？</h3><p>两次不行，因为：会有一种异常情况，就是客户端 A 发出第一个链接请求的时候，报文段并没有丢失，而是在网络节点中滞留了，这时候A就可能进行超时重传一次链接请求，后来B收到了链接，等数据传输完毕后，就释放了链接，但是这时候在网络节点中滞留的请求重新到达B节点，如果是不进行第三次握手，那么这时候B就认为A已经连接到了B，就会浪费了B的资源。</p><p>也就是说：三次握手主要的目的就是确认自己和对方的发送和接受是正常的，如果少了第三次，服务器没办法确认<strong>自己发送正常，对方接受正常</strong></p><h3 id="5、TCP和UDP之间的区别"><a href="#5、TCP和UDP之间的区别" class="headerlink" title="5、TCP和UDP之间的区别"></a>5、TCP和UDP之间的区别</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211112194503909.png" alt="image-20211112194503909"></p><ol><li>TCP 是面向连接的、可靠的协议，也就是说，在收发数据的时候，先建立三次连接。也就自然可靠</li><li>TCP 以<strong>字节流</strong>进行传输，UDP 以<strong>数据报文段</strong>进行传输。</li><li>TCP 包头占用的字节20-60，UDP占用 8 字节。</li><li>TCP 占用的资源比较多， UDP 占用的资源比较少。</li><li>TCP 速度比较慢 ，UDP 速度比较快。</li></ol><h3 id="6、TCP的粘包和拆包及解决方案"><a href="#6、TCP的粘包和拆包及解决方案" class="headerlink" title="6、TCP的粘包和拆包及解决方案"></a>6、TCP的粘包和拆包及解决方案</h3><p>因为TCP是面向流，没有边界，而操作系统在发送TCP数据时，会通过缓冲区来进行优化，例如缓冲区为1024个字节大小。</p><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP则会将多个请求合并为同一个请求进行发送，这就形成了粘包问题。</p><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP就会将其拆分为多次发送，这就是拆包。</p><p>对于粘包和拆包问题，常见的解决方案有四种：</p><p>·客户端在发送数据包的时候，每个包都固定长度，比如1024个字节大小，如果客户端发送的数据长度不足1024个字节，则通过补充空格的方式补全到指定长度；</p><p>·客户端在每个包的末尾使用固定的分隔符，例如\r\n，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的\r\n，然后对其拆分后的头部部分与前一个包的剩余部分进行合并，这样就得到了一个完整的包；</p><p>·将消息分为头部和消息体，在头部中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；</p><p>·通过自定义协议进行粘包和拆包的处理。</p><h3 id="7、CLOSE-WAIT-与-TIME-WAIT-作用及阶段？"><a href="#7、CLOSE-WAIT-与-TIME-WAIT-作用及阶段？" class="headerlink" title="7、CLOSE-WAIT 与 TIME-WAIT 作用及阶段？"></a>7、CLOSE-WAIT 与 TIME-WAIT 作用及阶段？</h3><p>TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此服务端应尽量减少主动关闭连接。</p><p>CLOSE_WAIT是被动关闭连接是形成的。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。</p><h3 id="8、TCP一共多少种状态？"><a href="#8、TCP一共多少种状态？" class="headerlink" title="8、TCP一共多少种状态？"></a>8、TCP一共多少种状态？</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211112213306704.png" alt="image-20211112213306704"></p><ol><li>CLOSED（关闭状态）**：初始状态，表示TCP连接是“关闭着的”或“未打开的”。</li><li><strong>LISTEN（监听状态）</strong> ：表示服务器端的某个SOCKET处于监听状态，可以接受客户端的连接。</li><li><strong>SYN_SENT（同步已发送）</strong> ：这个状态与SYN_RCVD 状态相呼应，当客户端SOCKET执行connect()进行连接时，它首先发送SYN报文，然后随即进入到SYN_SENT 状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT 状态表示客户端已发送SYN报文。</li><li><strong>SYN_RCVD（同步已收到）</strong> ：表示服务器接收到了来自客户端请求连接的SYN报文。在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat很难看到这种状态，除非故意写一个监测程序，将三次TCP握手过程中最后一个ACK报文不予发送。当TCP连接处于此状态时，再收到客户端的ACK报文，它就会进入到ESTABLISHED 状态。</li><li><strong>ESTABLISHED(已建立链接)</strong> ：表示TCP连接已经成功建立。</li><li><strong>FIN_WAIT_1（终止等待1）</strong> ：这个状态得好好解释一下，其实FIN_WAIT_1 和FIN_WAIT_2 两种状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET进入到FIN_WAIT_1 状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2 状态。当然在实际的正常情况下，无论对方处于任何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1 状态一般是比较难见到的，而FIN_WAIT_2 状态有时仍可以用netstat看到。</li><li><strong>CLOSE_WAIT（关闭等待）</strong> ：表示正在等待关闭。怎么理解呢？当对方close()一个SOCKET后发送FIN报文给自己，你的系统毫无疑问地将会回应一个ACK报文给对方，此时TCP连接则进入到CLOSE_WAIT状态。接下来呢，你需要检查自己是否还有数据要发送给对方，如果没有的话，那你也就可以close()这个SOCKET并发送FIN报文给对方，即关闭自己到对方这个方向的连接。有数据的话则看程序的策略，继续发送或丢弃。简单地说，当你处于CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。</li><li><strong>FIN_WAIT_2(终止等待2)</strong> ：上面已经解释了这种状态的由来，实际上FIN_WAIT_2状态下的SOCKET表示半连接，即有一方调用close()主动要求关闭连接。注意：FIN_WAIT_2 是没有超时的（不像TIME_WAIT 状态），这种状态下如果对方不关闭（不配合完成4次挥手过程），那这个 FIN_WAIT_2 状态将一直保持到系统重启，越来越多的FIN_WAIT_2 状态会导致内核crash。</li><li><strong>TIME_WAIT（关闭等待）</strong> ：表示收到了对方的FIN报文，并发送出了ACK报文。 TIME_WAIT状态下的TCP连接会等待2*MSL（Max Segment Lifetime，最大分段生存期，指一个TCP报文在Internet上的最长生存时间。每个具体的TCP协议实现都必须选择一个确定的MSL值，RFC 1122建议是2分钟，但BSD传统实现采用了30秒，Linux可以cat /proc/sys/net/ipv4/tcp_fin_timeout看到本机的这个值），然后即可回到CLOSED 可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。（这种情况应该就是四次挥手变成三次挥手的那种情况）</li><li><strong>CLOSING（）</strong> ：这种状态在实际情况中应该很少见，属于一种比较罕见的例外状态。正常情况下，当一方发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING 状态表示一方发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？那就是当双方几乎在同时close()一个SOCKET的话，就出现了双方同时发送FIN报文的情况，这是就会出现CLOSING 状态，表示双方都正在关闭SOCKET连接。</li><li><strong>LAST_ACK（最后确认）</strong> ：当被动关闭的一方在发送FIN报文后，等待对方的ACK报文的时候，就处于LAST_ACK 状态。当收到对方的ACK报文后，也就可以进入到CLOSED 可用状态了。</li></ol><h3 id="9、TCP拥塞控制和流量控制"><a href="#9、TCP拥塞控制和流量控制" class="headerlink" title="9、TCP拥塞控制和流量控制"></a>9、TCP拥塞控制和流量控制</h3><h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>四种算法：慢开始、拥塞避免、快重传、快开始。</p><p><strong>慢开始阶段</strong>：主机一开始发送数据时，不知道网络负荷情况，这时候如果一下子就注入大量数据，就容易导致网络拥塞，最好的方法就是由小到大逐渐增大发送窗口，这时候，每经过一个传输伦次，拥塞窗口就加倍，1、2、4、8、16…</p><p><strong>拥塞避免阶段：</strong>慢开始不能一直增长， 这里还需要设置一个门限值，当小于门限值的时候，使用慢开始的方法，大于门限值的时候，就是用拥塞避免的方法。拥塞避免的方法就是一个一个增加。当网络中出现了超时，发送方判断了网络拥塞，就开始从慢开始继续，此时慢开始门限就变为原来的1/2，</p><p><strong>快重传阶段：</strong>当接连收到三个相同发 ACK 时，也就是这个报文在网络中丢失，需要快速进行重传，而不是进行慢启动阶段，而是进入快恢复阶段，并且调整门限为原来的1/2。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>流量控制就是让发送方发送的不要太快，让接受方来得及接收</p><h2 id="三、应用层"><a href="#三、应用层" class="headerlink" title="三、应用层"></a>三、应用层</h2><h3 id="1、DNS解析过程"><a href="#1、DNS解析过程" class="headerlink" title="1、DNS解析过程"></a>1、DNS解析过程</h3><ul><li><strong>主机</strong>向<strong>本地域名服务器</strong>的查询一般都是采用递归查询</li><li><strong>本地域名服务器</strong>向<strong>根域名</strong>服务器查询一般都是采用迭代查询。</li></ul><p><a href="https://www.cnblogs.com/idmask/p/4485836.html">DNS原理总结及其解析过程详解</a></p><p>讲一下DNS过程。给一个网址<a href="http://www.bytedance.com，DNS服务器如何逐级解析的？">www.bytedance.com，DNS服务器如何逐级解析的？</a></p><p><a href="https://www.zhihu.com/question/23042131">下面内容的网址</a></p><p>1、在浏览器中输入<a href="http://www.qq.com/">www.qq.com</a> 域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。 </p><p>2、如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。 </p><p>3、如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。 </p><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。 </p><p>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<a href="https://link.zhihu.com/?target=http://qq.com">http://qq.com</a>域服务器，重复上面的动作，进行查询，直至找到<a href="http://www.qq.com主机./">www.qq.com主机。</a> </p><p>6、如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 </p><p>​    从客户端到本地DNS服务器是属于递归查询，而DNS服务器之间就是的交互查询就是迭代查询。</p><h3 id="2、Http与Https的区别"><a href="#2、Http与Https的区别" class="headerlink" title="2、Http与Https的区别"></a>2、Http与Https的区别</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211103203402124.png" alt="image-20211103203402124"></p><ol><li>开发目的不同，HTTP 的目的就是发布与接受 HTML 页面，而 HTTPS 主要是解决 HTTP 协议存在的问题(给面试官挖个坑，一会让他跳)，提供对服务器的验证，保证数据的完整性。</li><li>在安全协议方面不同，HTTP 不使用安全协议，HTTPS使用安全协议 SSL 或 TLS</li><li>HTTP 无加密方式，HTTPS 有加密方式。</li><li>响应速度 HTTP 相对较快，HTTPS 相对较慢。</li><li>HTTP 端口 80， HTTPS 端口 443。</li></ol><h3 id="3、HTTP状态码及301和302之间的区别"><a href="#3、HTTP状态码及301和302之间的区别" class="headerlink" title="3、HTTP状态码及301和302之间的区别"></a>3、HTTP状态码及301和302之间的区别</h3><table><thead><tr><th align="center"></th><th align="center">类型</th><th align="center">意思</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">信息形状态码</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">成功状态码</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">重定向状态码</td><td align="center">需要进行附加的操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">客户端错误状态码</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">服务器错误状态</td><td align="center">服务器处理请求出错</td></tr></tbody></table><p>200 ：客户端发来的请求在服务端正常处理</p><p>201: 请求处理成功，但是没有资源进行返回</p><p>301:资源永久性重定向</p><p>302:临时性重定向，该状态码表示请求的资源已分配了新的 URI，希望用户使用新的 URI 继续访问资源，和 301 相似，只不过是临时性的移动。</p><p>303:该状态码表示由于请求对应的资源存在着另一个URI，应使用GET方法定向获取请求的资源， 303和302状态码有着相同的功能，但是303明确表示客户端应当采用get方法获取资源，这点与302状态码有区别。</p><ul><li><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#1xx%E6%B6%88%E6%81%AF">1xx消息</a>——请求已被服务器接收，继续处理。</p></li><li><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#2xx%E6%88%90%E5%8A%9F">2xx成功</a>——请求已成功被服务器接收、理解、并接受。</p><ul><li>200: 正常返回信息</li></ul></li><li><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#3xx%E9%87%8D%E5%AE%9A%E5%90%91">3xx重定向</a>——需要后续操作才能完成这一请求。</p><ul><li>300 Multiple Choices</li><li><strong>301 Moved Permanently：永久性重定向</strong>。表示请求的资源已经被分配了新的 URI，以后应使用资源现在所指向的 URI。通常会发送 HTTP Location 来重定向到正确的新位置。这是将 HTTP 迁移到 HTTPS 的极佳方法。</li><li><strong>302 Found：临时重定向</strong>。表示请求的资源已被分配了新的 URI，希望用户**(本次)**能使用新的 URI 访问。</li><li>303 See Other：临时重定向。表示由于请求对应的资源存在着另一个 URI，应使用 <strong>GET</strong> 方法定向获取请求的资源。</li><li><strong>304 Not Modified：</strong>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</li></ul><blockquote><p>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。</p></blockquote></li><li><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#4xx%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF">4xx请求错误</a>——请求含有词法错误或者无法被执行，客户端错误。</p><ul><li>401 Unauthorized：请求未经授权，即用户没有权限执行这个请求。</li><li>403 Forbidden：服务器收到请求，但是拒绝提供服务</li><li>404 Not Found：请求资源不存在。最常见的就是URL错误</li></ul></li><li><p><a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81#5xx%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF">5xx服务器错误</a>——服务器在处理某个正确请求时发生错误</p><p>关于服务器500 501 502 503 504 505 的一些详解：<a href="https://jingyan.baidu.com/article/63f2362812cc600208ab3dce.html">https://jingyan.baidu.com/article/63f2362812cc600208ab3dce.html</a></p><ul><li>500 Internal Server Error：表明服务器端在执行请求时发生了错误，有可能是 Web 应用存在的 bug 或某些临时的故障。</li><li>502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收了无效的响应。</li><li>503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li><li>504 Gateway Time-out 这是代表着网关超时是现象出现了。是指服务器作为网关或代理，但是没有及时从上游服务器收到请求。</li></ul></li></ul><h3 id="4、-浏览器出入-url-发生了什么？"><a href="#4、-浏览器出入-url-发生了什么？" class="headerlink" title="4、 浏览器出入 url 发生了什么？"></a>4、 浏览器出入 url 发生了什么？</h3><ol><li>浏览器查询缓存</li><li>DNS 域名解析</li><li>TCP 三次握手连接</li><li>Http/Https 连接</li><li>服务器处理请求；</li><li>返回响应结果；</li><li>关闭 TCP 连接；</li><li>浏览器解析 HTML；</li><li>浏览器布局渲染；</li></ol><p><strong>1.浏览器查询缓存</strong></p><p>如果查找到缓存中有我们 URL 对应的文件，则判断是否命中强缓存，如果命中直接读取即可，如果没有命中强缓存，判断协商缓存是否命中，但是协商缓存无论是否命中都会发送请求。继续下面的步骤。</p><p><strong>2. DNS 域名解析</strong></p><p>DNS的域名查找，在客户端和浏览器，本地DNS之间的查询方式是递归查询；在本地DNS服务器与根域及其子域之间的查询方式是迭代查询；</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220212163509594.png" alt="image-20220212163509594" style="zoom:50%;" /><p><strong>3. TCP 三次握手连接</strong></p><h3 id="5、-HTTP-协议存在什么问题？如何解决？能否简单聊一聊-HTTPS-的-SSL连接建立的过程？"><a href="#5、-HTTP-协议存在什么问题？如何解决？能否简单聊一聊-HTTPS-的-SSL连接建立的过程？" class="headerlink" title="5、 HTTP 协议存在什么问题？如何解决？能否简单聊一聊 HTTPS 的 SSL连接建立的过程？"></a>5、 HTTP 协议存在什么问题？如何解决？能否简单聊一聊 HTTPS 的 SSL连接建立的过程？</h3><p>主要存在 3 个问题</p><ul><li>通信使用明文，也就是不加密，内容<strong>可能会被窃听</strong>。</li><li>不验证通信方的身份，因此有可能遭遇<strong>伪装</strong></li><li>无法验证报文的完整性，<strong>可能会被篡改</strong>。</li></ul><p>解决方式：</p><ul><li>通过加密处理来防止被窃听，比如 SSL (Secure Socket Layer 安全套接层)或者 TLS (Transport Layer Security 安全层传输协议) 的组合使用，HTTPS使用的是SSL。</li><li>通过内容的加密</li></ul><p>HTTP 协议是 HTTP 直接和 TCP 通信，HTTPS 协议是 HTTP 协议先和SSL通信，再和 TCP 通信。</p><p>共享密钥加密（对称密钥加密）：加密和解密用同一把密钥。</p><p>公开密钥加密（非对称密钥加密）：就是我的公钥公开，你给我发消息的时候，用我的公钥加密，然后发给我的时候我用私钥进行解密。</p><p>但是：这种根据密文和公开密钥进行解密是十分困难的，所以：<strong>HTTPS 采用的是混合的加密机制</strong>，在交换密钥期间使用公开密钥加密方式，之后建立连接后使用共享密钥加密方式。</p><h3 id="6-URI-和-URL-的区别？"><a href="#6-URI-和-URL-的区别？" class="headerlink" title="6. URI 和 URL 的区别？"></a>6. URI 和 URL 的区别？</h3><p>URI 是统一资源标志符，可以唯一标识一个资源</p><p>URL 是统一资源定位符，通过提供该资源的路径，找到它，它是一种具体的 URI。</p><p>URI 像是身份证号，而 URL 更像是住址。</p><h3 id="7-GET-和-POST-有什么区别？"><a href="#7-GET-和-POST-有什么区别？" class="headerlink" title="7. GET 和 POST 有什么区别？"></a>7. GET 和 POST 有什么区别？</h3><p>GET 和 POST 请求实际上是没有区别的，但是说的时候还是要说这些的</p><ul><li>GET 请求是请求资源，可以被缓存，幂等性(可以再次请求)，参数必须是 ASCII 类型，有长度限制。</li><li>POST 请求是提交数据，不能被缓存，不幂等性，有参数可以放到 request body 里并且参数没有长度限制。</li></ul><p>但是这只是两种发动请求的方法，最后都是通过 TCP 链接，但是因为 HTTP 的规定和浏览器的规定，会导致在应用过程中有些不同。</p><p>重大区别：</p><ul><li>GET 请求会把请求头和数据一起发出去，服务器响应 200。</li><li>POST 请求会先发送header，响应100后，再发送数据，服务器响应200，ok。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL高级</title>
      <link href="2022/02/09/MySQL%E9%AB%98%E7%BA%A7/"/>
      <url>2022/02/09/MySQL%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220210222236950.png" alt="image-20220210222236950"></p><p>逻辑架构</p><ul><li>逻辑架构分析</li><li>SQL 查询流程</li><li>查看执行计划</li><li>数据库缓冲池</li></ul><p>存储引擎</p><ul><li>InnoDB</li><li>MyISAM</li><li>…</li></ul><p>InnoDB 的数据存储结构</p><ul><li>关系图</li><li>InnoDB 的行格式</li><li>数据页组成部分</li><li>区的结构</li><li>段的结构</li><li>表空间</li></ul><h3 id="索引及调优篇"><a href="#索引及调优篇" class="headerlink" title="索引及调优篇"></a>索引及调优篇</h3><p>索引的数据结构</p><ul><li>类比</li><li>InnoDB中的索引</li><li>常见的数据结构</li></ul><p>索引的创建与设计原则</p><p>性能分析工具使用</p><p>索引的优化与查询优化</p><ul><li>调优原则与调优手段</li><li>索引失效案例</li><li>关联查询优化</li><li>子查询优化</li><li>排序优化</li><li>Group By 优化</li><li>日常SQL编写的规范与优化</li></ul><p>数据库的设计规范</p><ul><li>六大范式</li><li>反范式化</li><li>ER模型</li><li>表的设计原则</li><li>SQL编写建议</li></ul><p>数据库的其他调优策略</p><h3 id="事务篇"><a href="#事务篇" class="headerlink" title="事务篇"></a>事务篇</h3><p>事务基础知识</p><p>MySQL事务日志</p><ul><li>redo日志</li><li>undo日志</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/12/21/2022%E5%B9%B4%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%BA%8B%E6%83%85/"/>
      <url>2021/12/21/2022%E5%B9%B4%E8%A6%81%E5%AE%8C%E6%88%90%E7%9A%84%E4%BA%8B%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h1 id="2022年要完成的事情（目标）"><a href="#2022年要完成的事情（目标）" class="headerlink" title="2022年要完成的事情（目标）"></a>2022年要完成的事情（目标）</h1><ol><li><p>入党</p></li><li><p>找到一个好工作（大厂）</p></li><li><p>发表一篇论文和专利</p></li><li><p>多读书</p></li></ol><h2 id="论文和专利"><a href="#论文和专利" class="headerlink" title="论文和专利"></a><strong>论文和专利</strong></h2><ul><li>更改论文（抽时间，这是毕业前提）</li><li>书写专利（也一定要做到）</li></ul><h2 id="入党"><a href="#入党" class="headerlink" title="入党"></a><strong>入党</strong></h2><ul><li><p>刷学习强国（每天，坚持到真的成为发展对象）</p></li><li><p>必知必会、各种关于明年发展对象的考试准备（抽空做就可以）</p></li></ul><h2 id="找工作"><a href="#找工作" class="headerlink" title="找工作"></a><strong>找工作</strong></h2><ol><li><p>基础知识，按照每个科目进行，基础知识有很多，要分时间分快学习，关键还是看<strong>行动力</strong></p><ul><li>先找书，不宜多。</li><li>看面经，知道重点的看。</li><li>看书</li><li>看面经，自己整理后输出，对接第2条。</li></ul></li><li><p>博客每日更新（要求坚持到找完工作），为了能让Github每天都变绿 ———-基础沉淀、技术输出</p></li><li><p>每天刷2道LeetCode（优先刷剑指Offer），并提交到Github。千万不能让时间慢慢流逝。（大概30天）——-对接面试手撕算法</p></li><li><p>寒假完成《尚筹宝项目》（大概40天）—————对接项目经历</p></li></ol><p>计算机基础：</p><ul><li><p>计算机网络</p></li><li><p>操作系统</p></li><li><p>数据结构和算法</p></li><li><p>Java 基础</p></li><li><p>Mysql</p></li><li><p>设计模式（先掌握8种重点）</p></li></ul><h2 id="多读书"><a href="#多读书" class="headerlink" title="多读书"></a><strong>多读书</strong></h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="2021/10/18/Git/"/>
      <url>2021/10/18/Git/</url>
      
        <content type="html"><![CDATA[<h2 id="公钥，私钥和数字签名这样最好理解-转载"><a href="#公钥，私钥和数字签名这样最好理解-转载" class="headerlink" title="公钥，私钥和数字签名这样最好理解 (转载)"></a>公钥，私钥和数字签名这样最好理解 (转载)</h2><p>原文地址</p><p><a href="http://blog.csdn.net/tabactivity/article/details/49685319">http://blog.csdn.net/tabactivity/article/details/49685319</a></p><p>原文内容</p><p>一、公钥加密  假设一下，我找了两个数字，一个是1，一个是2。我喜欢2这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，1是我的公钥。</p><p>我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道2就是解密的私钥啊，所以他解不开，只有我可以用 数字2，就是我的私钥，来解密。这样我就可以保护数据了。</p><p>我的好朋友x用我的公钥1加密了字符a，加密后成了b，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道2就是我的私钥， 只有我才能解密，解密后就得到a。这样，我们就可以传送加密的数据了。</p><p>二、私钥签名 如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道2是我的私钥），结果所有的人都看到我的内容了，因为他们都知 道我的公钥是1，那么这种加密有什么用处呢？</p><p>但是我的好朋友x说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥2，加密，加密后的内容是d，发给x，再告诉他 解密看是不是c。他用我的公钥1解密，发现果然是c。 这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。 这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是数字签名</p><p><strong>总结：公钥和私钥是成对的，它们互相解密。<br>公钥加密，私钥解密。<br>私钥数字签名，公钥验证。</strong></p><h2 id="Github常用命令"><a href="#Github常用命令" class="headerlink" title="Github常用命令"></a>Github常用命令</h2><p>将所有的文件放入暂存区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>提交暂存区到仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;你要写的信息&quot;</span><br></pre></td></tr></table></figure><p>如果当前只有一个分支，那么主机名都可以省略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><p>从github上同步到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx</title>
      <link href="2021/09/27/Nginx/"/>
      <url>2021/09/27/Nginx/</url>
      
        <content type="html"><![CDATA[<center>Create your own path</center><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesCDF554B0DD5CA43FF40BB106B6757193.png" alt="CDF554B0DD5CA43FF40BB106B6757193"></p><br><p>无论人生上到哪一层台阶，阶下总有人在仰望你，阶上亦有人在俯视你。你抬头自卑，低头自得，唯有平视，才能看见真正的自己。</p><a id="more"></a><h1 id="Nginx学习笔记"><a href="#Nginx学习笔记" class="headerlink" title="Nginx学习笔记"></a>Nginx学习笔记</h1><h2 id="第一章-nginx基本概念"><a href="#第一章-nginx基本概念" class="headerlink" title="第一章 nginx基本概念"></a>第一章 nginx基本概念</h2><h3 id="1-nginx是什么？做什么事情？"><a href="#1-nginx是什么？做什么事情？" class="headerlink" title="1.nginx是什么？做什么事情？"></a>1.nginx是什么？做什么事情？</h3><p>nginx是</p><h3 id="2-反向代理"><a href="#2-反向代理" class="headerlink" title="2.反向代理"></a>2.反向代理</h3><p>正相代理：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210928160629280.png" alt="image-20210928160629280"></p><p>反向代理：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210928160722072.png" alt="image-20210928160722072"></p><h3 id="3-负载均衡"><a href="#3-负载均衡" class="headerlink" title="3.负载均衡"></a>3.负载均衡</h3><h3 id="4-动静分离"><a href="#4-动静分离" class="headerlink" title="4.动静分离"></a>4.动静分离</h3><h2 id="第二章-nginx安装、常用命令和配置文件"><a href="#第二章-nginx安装、常用命令和配置文件" class="headerlink" title="第二章 nginx安装、常用命令和配置文件"></a>第二章 nginx安装、常用命令和配置文件</h2><h3 id="1-在Linux系统中安装nginx"><a href="#1-在Linux系统中安装nginx" class="headerlink" title="1.在Linux系统中安装nginx"></a>1.在Linux系统中安装nginx</h3><h3 id="2-nginx常用命令"><a href="#2-nginx常用命令" class="headerlink" title="2.nginx常用命令"></a>2.nginx常用命令</h3><h3 id="3-nginx配置文件"><a href="#3-nginx配置文件" class="headerlink" title="3.nginx配置文件"></a>3.nginx配置文件</h3><h2 id="第三章-nginx配置实例1-反向代理"><a href="#第三章-nginx配置实例1-反向代理" class="headerlink" title="第三章 nginx配置实例1-反向代理"></a>第三章 nginx配置实例1-反向代理</h2><h2 id="第四章-nginx配置实例2-负载均衡"><a href="#第四章-nginx配置实例2-负载均衡" class="headerlink" title="第四章 nginx配置实例2-负载均衡"></a>第四章 nginx配置实例2-负载均衡</h2><h2 id="第五章-nginx配置实例3-动静分离"><a href="#第五章-nginx配置实例3-动静分离" class="headerlink" title="第五章 nginx配置实例3-动静分离"></a>第五章 nginx配置实例3-动静分离</h2><h2 id="第六章-nginx配置高可用集群"><a href="#第六章-nginx配置高可用集群" class="headerlink" title="第六章 nginx配置高可用集群"></a>第六章 nginx配置高可用集群</h2><h2 id="第七章-nginx原理"><a href="#第七章-nginx原理" class="headerlink" title="第七章 nginx原理"></a>第七章 nginx原理</h2>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/09/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<center>如果人生尽是坦途，那么梦想何处安放！</center><a id="more"></a><h3 id="1-操作系统中进程和线程的区别？"><a href="#1-操作系统中进程和线程的区别？" class="headerlink" title="1. 操作系统中进程和线程的区别？"></a>1. 操作系统中进程和线程的区别？</h3><p><a href="https://kb.cnblogs.com/page/531409/">参考链接</a></p><ol><li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li><li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li><li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li></ol><h3 id="2-进程间的通信方式"><a href="#2-进程间的通信方式" class="headerlink" title="2. 进程间的通信方式"></a>2. 进程间的通信方式</h3><p><a href="https://blog.csdn.net/weixin_33721344/article/details/86003737">参考链接</a></p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220322111647259.png" alt="image-20220322111647259" style="zoom:50%;" /><ol><li><p><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</p></li><li><p><strong>有名管道(Names Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循先进先出(First In First Out)。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p></li><li><p><strong>信号(Signal)：</strong>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</p></li><li><p><strong>消息队列(Message Queuing) ：</strong>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</p></li><li><p><strong>信号量(Semaphores) ：</strong>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</p></li><li><p><strong>共享内存(Shared memory) ：</strong>使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</p></li><li><p><strong>套接字(Sockets) :</strong> 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p></li></ol><h3 id="3-线程之间的通信方式？"><a href="#3-线程之间的通信方式？" class="headerlink" title="3. 线程之间的通信方式？"></a>3. 线程之间的通信方式？</h3><h3 id="4-线程的状态？"><a href="#4-线程的状态？" class="headerlink" title="4. 线程的状态？"></a>4. 线程的状态？</h3>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL实战</title>
      <link href="2021/08/26/MySQL%E5%AE%9E%E6%88%98/"/>
      <url>2021/08/26/MySQL%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<center>文案</center><center>要想成为强者，</center><center>绝不能绕过挡道的荆棘，也不能回避风雨的冲刷。</center><p>在复习java基础知识的时候，顺便学习一下sql，发现之前学过的数据库在用的时候不会了，拿过来重新拾起来，好难，加油。</p><a id="more"></a><p>视频来源：来自于美国一位老师，看了一些感觉还不错，就决定坚持看下去，在看的基础上，还要看相关书籍，并进行整理。</p><p>视频链接：<a href="https://www.bilibili.com/video/BV1UE41147KC?p=3">简单易懂的MySQL教程</a></p><p>该教程使用到的文件：<a href="https://pan.baidu.com/s/1ao7TTXYQF6OFOPX-O0rOjw">点击这里</a> 密码: 8iha</p><p>以下sql语句是边学边敲的。设计到对数据库的方方面面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">use sql_store</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">-- WHERE customers_id &#x3D; 1</span><br><span class="line">ORDER BY first_name;</span><br><span class="line"></span><br><span class="line">SELECT first_name,last_name,points,points+10</span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">points,</span><br><span class="line">points*10+10</span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">points,</span><br><span class="line">(points+10)*10</span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">points,</span><br><span class="line">(points+10)*10 AS discountfactor </span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">points,</span><br><span class="line">(points+10)*10 AS &#39;discoun factor&#39; </span><br><span class="line">FROM customers;</span><br><span class="line"></span><br><span class="line">SELECT DISTINCT state</span><br><span class="line">from customers;</span><br><span class="line"></span><br><span class="line">#练习,出现的错误，没有在new_price中加入_,导致执行不了</span><br><span class="line">#还有就是，字段之间要加入逗号。</span><br><span class="line">SELECT </span><br><span class="line">name,</span><br><span class="line">unit_price,</span><br><span class="line">unit_price*1.1 AS new_price</span><br><span class="line">from products;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这里还可以使用&gt; &gt;&#x3D; &lt; &lt;&#x3D; !&#x3D;或者&lt;&gt;</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">where points&gt;3000;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">where birth_date &gt; &#39;1990-01-01&#39;;</span><br><span class="line"></span><br><span class="line">#练习 GET the orders place this year</span><br><span class="line">#查看今年所有的订单</span><br><span class="line">select *</span><br><span class="line">from orders</span><br><span class="line">WHERE order_date &gt;&#x3D; &#39;2019-01-01&#39;;</span><br><span class="line"></span><br><span class="line">#组合筛选条件</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE birth_date &gt;&#39;1990-01-01&#39; AND points &gt; 1000;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE birth_date &gt;&#39;1990-01-01&#39; OR points &gt; 1000;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT *</span><br><span class="line">FROM order_items</span><br><span class="line">WHERE order_id &#x3D; 6 AND unit_price * quantity&gt;30;</span><br><span class="line"></span><br><span class="line">#in的练习</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE state &#x3D; &#39;VA&#39; OR state &#x3D;&#39;GA&#39; OR state &#x3D; &#39;FL&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE state in (&#39;VA&#39;,&#39;GA&#39;,&#39;FL&#39;);</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE state not in (&#39;VA&#39;,&#39;GA&#39;,&#39;FL&#39;);</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">select *</span><br><span class="line">from products</span><br><span class="line">WHERE quantity_in_stock IN (&#39;49&#39;,&#39;38&#39;,&#39;72&#39;);</span><br><span class="line"></span><br><span class="line">#关于between运算符</span><br><span class="line">select *</span><br><span class="line">from customers</span><br><span class="line">WHERE points&gt;1300 AND points&lt;3000;</span><br><span class="line"></span><br><span class="line">#使用between运算符</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers </span><br><span class="line">where points between 1000 AND 3000;</span><br><span class="line"></span><br><span class="line">#between练习</span><br><span class="line">select * </span><br><span class="line">FROM customers</span><br><span class="line">WHERE birth_date between &#39;1990-01-01&#39; AND &#39;2000-01-01&#39;;</span><br><span class="line"></span><br><span class="line">#字符串匹配,使用%，这里的b可以匹配大写的，百分号是表示任意多字符。</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name LIKE &#39;b%&#39;;</span><br><span class="line"></span><br><span class="line">#这里_表示只匹配一个字符</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name LIKE &#39;_____y&#39;;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE address LIKE &#39;%TRAIL%&#39;or  address LIKE &#39;%AVENUE%&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE phone LIKE &#39;%9&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE NOT phone LIKE &#39;%9&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># regexp </span><br><span class="line">#平常写：</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name LIKE &#39;%field%&#39;;</span><br><span class="line"></span><br><span class="line">#使用regexp</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;field&#39;;</span><br><span class="line"></span><br><span class="line">#表示只能以field开头</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;^field&#39;;</span><br><span class="line"></span><br><span class="line">#表示只能以field结尾</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;field$&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;field|mac&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;field|mac|rose&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;^field|mac|rose&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;field$|mac|rose&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;e&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#里面含有ge、ie、或者 me。</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;[gim]e&#39;;</span><br><span class="line"></span><br><span class="line">#里面含有eq、 ey、或者es。</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;e[qys]&#39;;</span><br><span class="line"></span><br><span class="line">#里面含有a-h和e组合的所有字符。</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;[a-h]e&#39;;</span><br><span class="line"></span><br><span class="line">#总结: ^:是在最开始</span><br><span class="line"># %:表示是结束</span><br><span class="line">#|:或</span><br><span class="line">#[abcd]</span><br><span class="line">#  [a-d]</span><br><span class="line"></span><br><span class="line">#四个练习</span><br><span class="line">select *</span><br><span class="line">from customers</span><br><span class="line">where first_name REGEXP &#39;ELKA|AMBUR&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;EY$|ON$&#39;;</span><br><span class="line"></span><br><span class="line">#查询</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;^my|se&#39;;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">WHERE last_name REGEXP &#39;B[RU]&#39;;</span><br><span class="line"></span><br><span class="line">#如何获取缺省值</span><br><span class="line"></span><br><span class="line">#获取手机里面没有信息的</span><br><span class="line">SELECT * from customers</span><br><span class="line">WHERE phone is null;</span><br><span class="line"></span><br><span class="line">SELECT * from customers</span><br><span class="line">WHERE phone is null;</span><br><span class="line"></span><br><span class="line">#获取没有发货的订单</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM orders;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from orders</span><br><span class="line">WHERE shipper_id is null;</span><br><span class="line"></span><br><span class="line">#对查询的数据进行排序</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">ORDER BY customer_id DESC;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">ORDER BY first_name;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">ORDER BY state desc,first_name DESC;</span><br><span class="line"></span><br><span class="line">SELECT first_name,last_name,10 as point</span><br><span class="line">from customers</span><br><span class="line">ORDER BY 1,2;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT *</span><br><span class="line">from order_items</span><br><span class="line">WHERE order_id &#x3D; 2</span><br><span class="line">ORDER BY quantity * unit_price DESC ;</span><br><span class="line"></span><br><span class="line">SELECT * ,quantity * unit_price AS total_price</span><br><span class="line">from order_items</span><br><span class="line">WHERE order_id &#x3D; 2</span><br><span class="line">ORDER BY quantity * unit_price DESC ;</span><br><span class="line"></span><br><span class="line">SELECT * ,quantity * unit_price AS total_price</span><br><span class="line">from order_items</span><br><span class="line">WHERE order_id &#x3D; 2</span><br><span class="line">ORDER BY total_price DESC ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#限制展示查询的数据，比如查出来10条数据，只展示3条；</span><br><span class="line">#limit语句</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">LIMIT 3</span><br><span class="line"></span><br><span class="line"># page1  1-3</span><br><span class="line"># page2  4-6</span><br><span class="line"># page3  7-9</span><br><span class="line">#我们想取第三页的数据</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">LIMIT 6,3</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY points DESC</span><br><span class="line">LIMIT 3;</span><br><span class="line"></span><br><span class="line">#写sql语句时关键字的顺序</span><br><span class="line">SELECT *</span><br><span class="line">FROM customers</span><br><span class="line">WHERE points&gt;2500</span><br><span class="line">ORDER BY points DESC</span><br><span class="line">LIMIT 3;</span><br><span class="line"></span><br><span class="line">##之前，都是在一张表上进行操作，但是实际上，我们需要在多张表上进行操作。</span><br><span class="line"></span><br><span class="line">#inner join</span><br><span class="line">SELECT *</span><br><span class="line">from orders</span><br><span class="line">inner JOIN customers on orders.customer_id &#x3D; customers.customer_id; #可选的</span><br><span class="line"></span><br><span class="line">SELECT order_id,first_name,last_name</span><br><span class="line">from orders</span><br><span class="line">inner JOIN customers on orders.customer_id &#x3D; customers.customer_id;</span><br><span class="line"></span><br><span class="line">#这样会报错，因为customer_id两张表都有，</span><br><span class="line">SELECT order_id,customer_id,first_name,last_name</span><br><span class="line">from orders</span><br><span class="line">inner JOIN customers on orders.customer_id &#x3D; customers.customer_id;</span><br><span class="line"></span><br><span class="line">#这样就可以了</span><br><span class="line">SELECT order_id,orders.customer_id,first_name,last_name</span><br><span class="line">from orders</span><br><span class="line">inner JOIN customers on orders.customer_id &#x3D; customers.customer_id;</span><br><span class="line"></span><br><span class="line">#除此之外，因为表名特别长。也可以对表名进行起别名</span><br><span class="line">SELECT order_id,o.customer_id,first_name,last_name</span><br><span class="line">from orders o</span><br><span class="line">JOIN customers c on o.customer_id &#x3D; c.customer_id;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT o.order_id,o.product_id,quantity,o.unit_price</span><br><span class="line">from order_items o</span><br><span class="line">JOIN products p on o.product_id &#x3D; p.product_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#跨数据库中的表查询</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">from order_items o</span><br><span class="line">JOIN sql_inventory.products p on o.product_id &#x3D; p.product_id;</span><br><span class="line">#此时是能够进行查询的，因为我们使用的是sql_store数据库，但是如果不是使用的这个数据库</span><br><span class="line">#我们就需要进行换一种写法</span><br><span class="line">SELECT *</span><br><span class="line">from sql_store.order_items o</span><br><span class="line">JOIN sql_inventory.products p on o.product_id &#x3D; p.product_id;</span><br><span class="line">#所以在查询不同数据库的时候，我们需要在不同数据库表的前面加上数据库的名字</span><br><span class="line"></span><br><span class="line">#其实表也是可以自链接的</span><br><span class="line">use sql_hr;</span><br><span class="line"></span><br><span class="line">SELECT e.employee_id,e.first_name,m.first_name AS manager</span><br><span class="line">from</span><br><span class="line">employees e</span><br><span class="line">JOIN employees m ON e.reports_to &#x3D; m.employee_id;</span><br><span class="line"></span><br><span class="line">#如何连接两个以上的表,这里连接的是三张表</span><br><span class="line">use sql_store;</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM orders</span><br><span class="line">JOIN customers ON orders.customer_id &#x3D; customers.customer_id </span><br><span class="line">JOIN order_statuses on order_statuses.order_status_id &#x3D; orders.&#96;status&#96;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#改进</span><br><span class="line">SELECT </span><br><span class="line">o.order_id,</span><br><span class="line">o.order_date,</span><br><span class="line">c.first_name,</span><br><span class="line">c.last_name,</span><br><span class="line">os.name AS status</span><br><span class="line">FROM orders o</span><br><span class="line">JOIN customers c ON o.customer_id &#x3D; c.customer_id </span><br><span class="line">JOIN order_statuses os on os.order_status_id &#x3D; o.&#96;status&#96;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">use sql_invoicing</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">p.date,</span><br><span class="line">p.invoice_id,</span><br><span class="line">p.payment_id,</span><br><span class="line">p.amount,</span><br><span class="line">c.&#96;name&#96;,</span><br><span class="line">pm.&#96;name&#96;</span><br><span class="line">FROM payments p</span><br><span class="line">JOIN payment_methods pm ON p.payment_method &#x3D; pm.payment_method_id</span><br><span class="line">JOIN clients c ON p.client_id &#x3D; c.client_id;</span><br><span class="line"></span><br><span class="line">#到目前为止，我们只是做的事每一个表有主键只有一个，接下来是多个字段作为主键的情况</span><br><span class="line"></span><br><span class="line">#练习一个表与另一表进行连接，其中一个表主键包含两个字段</span><br><span class="line">USE sql_store</span><br><span class="line"></span><br><span class="line">SELECT *</span><br><span class="line">FROM order_items</span><br><span class="line">JOIN order_item_notes </span><br><span class="line">on order_items.order_id &#x3D; order_item_notes.order_id</span><br><span class="line">AND order_items.product_id &#x3D; order_item_notes.product_id;</span><br><span class="line"></span><br><span class="line">#隐式连接</span><br><span class="line">#之前的是这样的</span><br><span class="line">SELECT *</span><br><span class="line">from orders o</span><br><span class="line">JOIN customers c on o.customer_id &#x3D; c.customer_id;</span><br><span class="line">#现在</span><br><span class="line">#我们称之为隐式语法，但是如果没有写where子句的话，查出来的数据与我们想要的不一样，</span><br><span class="line">#所以但是我们最好使用显示的。</span><br><span class="line">SELECT *</span><br><span class="line">FROM orders o,customers c</span><br><span class="line">WHERE o.customer_id &#x3D; c.customer_id;</span><br><span class="line"></span><br><span class="line">#下面的写法是没有问题的，但是发现，有的数据是不能展示出来的。</span><br><span class="line">SELECT </span><br><span class="line">c.customer_id,</span><br><span class="line">c.first_name,</span><br><span class="line">o.order_id</span><br><span class="line">FROM customers c</span><br><span class="line">JOIN orders o on c.customer_id &#x3D; o.customer_id</span><br><span class="line">ORDER BY c.customer_id;</span><br><span class="line"></span><br><span class="line">#左连接</span><br><span class="line">SELECT </span><br><span class="line">c.customer_id,</span><br><span class="line">c.first_name,</span><br><span class="line">o.order_id</span><br><span class="line">FROM customers c</span><br><span class="line">left JOIN orders o on c.customer_id &#x3D; o.customer_id</span><br><span class="line">ORDER BY c.customer_id;</span><br><span class="line"></span><br><span class="line">#右连接</span><br><span class="line">SELECT </span><br><span class="line">c.customer_id,</span><br><span class="line">c.first_name,</span><br><span class="line">o.order_id</span><br><span class="line">FROM customers c</span><br><span class="line">left JOIN orders o on c.customer_id &#x3D; o.customer_id</span><br><span class="line">ORDER BY c.customer_id;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">p.product_id,</span><br><span class="line">p.name,</span><br><span class="line">oi.quantity</span><br><span class="line">from products p</span><br><span class="line">LEFT JOIN order_items oi</span><br><span class="line">on p.product_id &#x3D; oi.product_id;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">p.product_id,</span><br><span class="line">p.name,</span><br><span class="line">oi.quantity</span><br><span class="line">from products p</span><br><span class="line">LEFT JOIN order_items oi</span><br><span class="line">on p.product_id &#x3D; oi.product_id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">c.customer_id,</span><br><span class="line">c.first_name,</span><br><span class="line">o.order_id</span><br><span class="line">FROM customers c</span><br><span class="line">left JOIN orders o on c.customer_id &#x3D; o.customer_id</span><br><span class="line">JOIN shippers sh on o.shipper_id &#x3D; sh.shipper_id</span><br><span class="line">ORDER BY c.customer_id;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">c.customer_id,</span><br><span class="line">c.first_name,</span><br><span class="line">o.order_id</span><br><span class="line">FROM customers c</span><br><span class="line">left JOIN orders o on c.customer_id &#x3D; o.customer_id</span><br><span class="line">left JOIN shippers sh on o.shipper_id &#x3D; sh.shipper_id</span><br><span class="line">ORDER BY c.customer_id;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT </span><br><span class="line">o.order_id,</span><br><span class="line">o.order_date,</span><br><span class="line">c.first_name as customer,</span><br><span class="line">s.name as shipper</span><br><span class="line"></span><br><span class="line">from orders o</span><br><span class="line">LEFT JOIN customers c ON o.customer_id &#x3D; c.customer_id</span><br><span class="line">LEFT JOIN shippers s  on s.shipper_id &#x3D; o.shipper_id </span><br><span class="line">ORDER BY o.order_id</span><br><span class="line"></span><br><span class="line">#自连接</span><br><span class="line">use sql_hr;</span><br><span class="line"></span><br><span class="line">#如果不是使用left join，只是会显示employees有经理的，如下所示：</span><br><span class="line">SELECT </span><br><span class="line">e.employee_id,</span><br><span class="line">e.first_name,</span><br><span class="line">m.first_name as manager</span><br><span class="line">FROM employees e</span><br><span class="line">JOIN employees m</span><br><span class="line">on e.reports_to &#x3D; m.employee_id;</span><br><span class="line"></span><br><span class="line">#改进：</span><br><span class="line">SELECT </span><br><span class="line">e.employee_id,</span><br><span class="line">e.first_name,</span><br><span class="line">m.first_name as manager</span><br><span class="line">FROM employees e</span><br><span class="line">LEFT JOIN employees m</span><br><span class="line">on e.reports_to &#x3D; m.employee_id;</span><br><span class="line"></span><br><span class="line">#USING 使用</span><br><span class="line">#之前是这样的，</span><br><span class="line">select</span><br><span class="line">o.order_id,</span><br><span class="line">c.first_name</span><br><span class="line">FROM orders o</span><br><span class="line">join customers c ON o.customer_id &#x3D; c.customer_id;</span><br><span class="line">#现在是这样的，</span><br><span class="line">select</span><br><span class="line">o.order_id,</span><br><span class="line">c.first_name</span><br><span class="line">FROM orders o</span><br><span class="line">join customers c  USING(customer_id);</span><br><span class="line"></span><br><span class="line">#关于之前的主键包含两个字段的</span><br><span class="line">select *</span><br><span class="line">from order_items</span><br><span class="line">JOIN order_item_notes</span><br><span class="line">on order_items.order_id &#x3D; order_item_notes.order_Id </span><br><span class="line">AND order_items.product_id &#x3D; order_item_notes.product_id;</span><br><span class="line"></span><br><span class="line">#可以换为：</span><br><span class="line">select *</span><br><span class="line">from order_items</span><br><span class="line">JOIN order_item_notes</span><br><span class="line">USING(order_id,product_id);</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">use sql_invoicing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#这里面在使用Using()的时候，两个表名里面的字段名必须相同，否则没办法用。</span><br><span class="line">SELECT *</span><br><span class="line">FROM payments p</span><br><span class="line">JOIN payment_methods pm</span><br><span class="line">on pm.payment_method_id &#x3D; p.payment_id</span><br><span class="line">join clients USING(client_id);</span><br><span class="line"></span><br><span class="line">#交叉连接</span><br><span class="line">#例如：</span><br><span class="line">use sql_store;</span><br><span class="line"></span><br><span class="line">#交叉连接显示语法</span><br><span class="line">SELECT *</span><br><span class="line">from customers</span><br><span class="line">cross JOIN products;</span><br><span class="line"></span><br><span class="line">#交叉连接隐式语法</span><br><span class="line">SELECT *</span><br><span class="line">from customers,products;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#UNION,将多个查询的语句结果进行整合，但是如果没个查询的语句查询的列数不一样，比如</span><br><span class="line">#第一个查询是一个字段，第二个查询是两个字段，回产生错误。</span><br><span class="line"></span><br><span class="line"># &#39;Avtive&#39;是我们自己加上去的，题目意思是：2019-01-01之前的不是Active。</span><br><span class="line">SELECT </span><br><span class="line">order_id,</span><br><span class="line">order_date,</span><br><span class="line">&#39;Active&#39; AS status</span><br><span class="line">from orders</span><br><span class="line">WHERE order_date &gt;&#x3D; &#39;2019-01-01&#39; </span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">order_id,</span><br><span class="line">order_date,</span><br><span class="line">&#39;Actived&#39; AS status</span><br><span class="line">from orders</span><br><span class="line">WHERE order_date &lt; &#39;2019-01-01&#39;;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">SELECT </span><br><span class="line">customer_id,</span><br><span class="line">first_name,</span><br><span class="line">points,</span><br><span class="line">&#39;Bronze&#39; AS type </span><br><span class="line">FROM customers</span><br><span class="line">WHERE points &lt; 2000</span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">customer_id,</span><br><span class="line">first_name,</span><br><span class="line">points,</span><br><span class="line">&#39;Silver&#39; AS type </span><br><span class="line">FROM customers</span><br><span class="line">WHERE points BETWEEN 2000 AND 3000</span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">customer_id,</span><br><span class="line">first_name,</span><br><span class="line">points,</span><br><span class="line">&#39;Gold&#39; AS type </span><br><span class="line">FROM customers</span><br><span class="line">WHERE points &gt; 3000</span><br><span class="line">ORDER BY first_name;</span><br><span class="line"></span><br><span class="line">#-----------------------------------------------------------</span><br><span class="line">#插入、更新和删除</span><br><span class="line">#在表格中插入一行,这里default是默认真，起初设置的是id，</span><br><span class="line">#我们遵循mysql里面的自动增长，不能进行显示赋值。</span><br><span class="line">INSERT INTO customers</span><br><span class="line">VALUES(</span><br><span class="line">DEFAULT,</span><br><span class="line">&#39;LGY&#39;,</span><br><span class="line">&#39;GG&#39;,</span><br><span class="line">NULL,</span><br><span class="line">&#39;17863978947&#39;,</span><br><span class="line">&#39;山东省&#39;,</span><br><span class="line">&#39;聊城&#39;,</span><br><span class="line">&#39;aa&#39;,</span><br><span class="line">DEFAULT);</span><br><span class="line"></span><br><span class="line">#也可以指定值，我们没必要按照顺序进行</span><br><span class="line">INSERT INTO customers(</span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">birth_date,</span><br><span class="line">address,</span><br><span class="line">city,</span><br><span class="line">state</span><br><span class="line">)</span><br><span class="line">VALUES(</span><br><span class="line">&#39;LGY1&#39;,</span><br><span class="line">&#39;GG&#39;,</span><br><span class="line">&#39;1996-06-26&#39;,</span><br><span class="line">&#39;山东省&#39;,</span><br><span class="line">&#39;聊城&#39;,</span><br><span class="line">&#39;aa&#39;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">#一次性插入多行</span><br><span class="line">INSERT into shippers (name)</span><br><span class="line">VALUES (&#39;shipper1&#39;),(&#39;shipper2&#39;),(&#39;shipper&#39;);</span><br><span class="line">#练习</span><br><span class="line">INSERT INTO products(name,quantity_in_stock,unit_price)</span><br><span class="line">VALUES(&#39;lhu&#39;,&#39;22&#39;,&#39;33&#39;),</span><br><span class="line">(&#39;ldu&#39;,&#39;3&#39;,&#39;3&#39;),</span><br><span class="line">(&#39;lhuw&#39;,&#39;7&#39;,&#39;1&#39;);</span><br><span class="line"></span><br><span class="line">#将数据插入到多表中,关于order与order_item表</span><br><span class="line"></span><br><span class="line">INSERT INTO orders(customer_id,order_date,&#96;status&#96;)</span><br><span class="line">VALUES(1,&#39;2020-01-01&#39;,1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT into order_items</span><br><span class="line">VALUES</span><br><span class="line">(LAST_INSERT_ID(),1,1,2.98),</span><br><span class="line">(LAST_INSERT_ID(),2,1,3.98)</span><br><span class="line"></span><br><span class="line">#复制数据从一个表到另一个表,但是，复制产生的表里面的主键是没有的，</span><br><span class="line">#而且没有设置为自动增长的</span><br><span class="line">#这里是查询所有的数据进行复制过去</span><br><span class="line">CREATE table order_archived as</span><br><span class="line">SELECT * from orders;</span><br><span class="line"></span><br><span class="line">#也可以先清空表，然后进行复制筛选出来的部分</span><br><span class="line">INSERT into order_archived</span><br><span class="line">SELECT *</span><br><span class="line">from orders</span><br><span class="line">WHERE order_date &lt; &#39;2019-01-01&#39;;</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">use sql_invoicing;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create TABLE invoices_archied as</span><br><span class="line">SELECT </span><br><span class="line">client_id,</span><br><span class="line">invoice_id,</span><br><span class="line">&#96;name&#96; AS client,</span><br><span class="line">invoice_total,</span><br><span class="line">payment_total,</span><br><span class="line">invoice_date,</span><br><span class="line">due_date,</span><br><span class="line">payment_date</span><br><span class="line">FROM invoices</span><br><span class="line">JOIN clients USING(client_id)</span><br><span class="line">WHERE payment_date is not null</span><br><span class="line"></span><br><span class="line">#更新数据</span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_total &#x3D; 10,payment_date &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">where invoice_id &#x3D; 1;</span><br><span class="line"></span><br><span class="line">#更新多行</span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_total &#x3D; 10,payment_date &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">where client_id &#x3D; 3;</span><br><span class="line"></span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_total &#x3D; 10,payment_date &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">where client_id &#x3D; (3,4);</span><br><span class="line"></span><br><span class="line">#练习</span><br><span class="line">use sql_store;</span><br><span class="line"></span><br><span class="line">UPDATE customers</span><br><span class="line">SET points &#x3D; points +50</span><br><span class="line">WHERE birth_date &lt;&#39;1990-01-01&#39;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use sql_invoicing</span><br><span class="line"></span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_total &#x3D; 10,payment_date &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">where client_id &#x3D; (SELECT client_id FROM clients WHERE name &#x3D; &#39;Myworks&#39;);</span><br><span class="line"></span><br><span class="line">UPDATE invoices</span><br><span class="line">SET payment_total &#x3D; 10,payment_date &#x3D; &#39;2020-12-22&#39;</span><br><span class="line">where client_id in (SELECT client_id FROM clients WHERE state in (&#39;CA&#39;,&#39;NY&#39;));</span><br><span class="line"></span><br><span class="line">#delete删除</span><br><span class="line">DELETE from invoices</span><br><span class="line">WHERE invoice_id &#x3D; 1</span><br><span class="line"></span><br><span class="line">##################################</span><br><span class="line">到此完成了数据库前四章基础内容，对应视频1-40小节</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 算法题目</title>
      <link href="2021/08/20/LeetCode/"/>
      <url>2021/08/20/LeetCode/</url>
      
        <content type="html"><![CDATA[<center>只有经历过地狱般的磨砺，才能练就创造天堂的力量，只有流过血的手指，才能弹出世间的绝响</center><br><p>本篇博客是关于Leetcode的算法题汇总，计划按照顺序依次作答记录，包括但不限于题目说明，解答思路，代码实现，知识补充四个部分，希望通过努力与自律，踏实和实事求是的态度，为未来一年的秋招做好准备！</p><a id="more"></a><h1 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h1><h2 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h2><p>题目链接：<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">点击这里</a>  </p><ul><li><strong>题目说明</strong></li></ul><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>举例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p>举例2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p>举例3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p>举例4:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>说明：</p><ol><li><p><code>0 &lt;= s.length &lt;= 5 * 104</code></p></li><li><p><code>s</code> 由英文字母、数字、符号和空格组成</p></li></ol><ul><li><strong>解答思路</strong></li></ul><p>一读题目，以为之前做过，认为是给出一个字符串，总包含第一个字符，但是仔细一读，发现不是这样的，对于字串，字串开始并不一定就是给出字符串的第一个字母，想到了头指针和尾指针，但是没有考虑到如果是写循环的话，会有大量的重复工作，最后看了官方的思路，豁然开朗。</p><ul><li><strong>代码实现</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        Set&lt;Character&gt; characters = <span class="keyword">new</span> HashSet&lt;Character&gt;();<span class="comment">//创建一个HashSet的对象</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();<span class="comment">//求字符串的长度</span></span><br><span class="line">        <span class="keyword">int</span> rk = -<span class="number">1</span>;<span class="comment">//指向第0个元素的左边，以-1开头</span></span><br><span class="line">        <span class="keyword">int</span> ans= <span class="number">0</span>;<span class="comment">//返回的最大字串长度</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>)&#123;</span><br><span class="line">                characters.remove(s.charAt(i-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (rk+<span class="number">1</span>&lt;n &amp;&amp; !characters.contains(s.charAt(rk+<span class="number">1</span>)))&#123;</span><br><span class="line">                characters.add(s.charAt(rk+<span class="number">1</span>));</span><br><span class="line">                ++rk;</span><br><span class="line">            &#125;</span><br><span class="line">           ans = Math.max(ans,rk-i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;<span class="comment">//返回的是该字符串的无重复字串的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>知识补充</strong></li></ul><p><strong>HashSet</strong>：是一个不允许有重复元素的集合，允许null，是无序的，不是线程安全的，他实现了set()接口，里面存储的是对象，一些常见的基本类型可以使用他的包装类。使用HashSet,需要导入java.util.HashSet包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; sites = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>里面存储的是String类型的对象，可以是Character的对象都可以。</p><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sites.add()<span class="comment">//添加方法</span></span><br><span class="line">sites.contains(<span class="string">&quot;Taobao&quot;</span>)<span class="comment">//返回的是布尔值，查看是否包含这个字符串</span></span><br><span class="line">sites.remove(<span class="string">&quot;Taobao&quot;</span>);<span class="comment">//删除字符串</span></span><br><span class="line">sites.size()<span class="comment">//返回的是int类型的数字</span></span><br></pre></td></tr></table></figure><p><strong>String</strong>：</p><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String site = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> len = site.length();<span class="comment">//字符串长度</span></span><br><span class="line"></span><br><span class="line">string1.concat(string2);<span class="comment">//连接两个字符串</span></span><br><span class="line"></span><br><span class="line">String s = <span class="string">&quot;www.runoob.com&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> result = s.charAt(<span class="number">6</span>);去索引为<span class="number">6</span>的字符</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda总结</title>
      <link href="2021/08/13/Anaconda/"/>
      <url>2021/08/13/Anaconda/</url>
      
        <content type="html"><![CDATA[<center>文案</center><center>白天隐藏在入夜的灯，风躺进熟睡人的呼吸</center><center>芦苇是地底的云，你推窗望过来，瞳孔是距我最近的星🌟</center><a id="more"></a><p>​        最近在进行python实验环境安装过程中，了解的Anaconda（蟒蛇）软件能够有效管理python中的包，于是上手体验啦一番，期间遇到了一些问题，我把我用到的关于Anaconda的常用知识进行汇总。</p><h3 id="关于Anaconda-的常用命令"><a href="#关于Anaconda-的常用命令" class="headerlink" title="关于Anaconda 的常用命令"></a>关于Anaconda 的常用命令</h3><ol><li>检查anaconda 的版本(可以在Anaconda Prompt或者windows自带的命令提示符都可以)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure><ol start="2"><li>显示所有环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env list</span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个名称为KGCN环境，并指定python版本</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name KGCN python &#x3D; 3.7.11</span><br></pre></td></tr></table></figure><ol start="4"><li>切换环境到KGCN（默认使用环境为base）</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate KGCN</span><br></pre></td></tr></table></figure><ol start="5"><li>删除环境KGCN(虚拟环境名称)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove -n KGCN --all</span><br></pre></td></tr></table></figure><ol start="6"><li>导出某个环境到yaml作为备份，文件存储在命令行打印的目录，前提要进入该环境。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env export &gt; 名称.yaml</span><br></pre></td></tr></table></figure><ol start="7"><li>在另一台电脑上进行克隆环境</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda env create -f 名称.yaml</span><br></pre></td></tr></table></figure><ol start="8"><li>mac安装了anaconda后，进入命令行自动带（base）LGYdeMacBook-Pro:~ lvguangyue$，要想不显示，执行如下命令：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda config --set auto_activate_base false</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>链接：<a href="https://blog.csdn.net/ysq319/article/details/102773615?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">https://blog.csdn.net/ysq319/article/details/102773615?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control</a></p>]]></content>
      
      
      <categories>
          
          <category> Anaconda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础</title>
      <link href="2021/08/13/MySQL%E5%9F%BA%E7%A1%80/"/>
      <url>2021/08/13/MySQL%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<center>文案</center><center>白天隐藏在入夜的灯，风躺进熟睡人的呼吸</center><center>芦苇是地底的云，你推窗望过来，瞳孔是距我最近的星🌟</center><a id="more"></a><ol><li><p>SqlServer只适合windows操作系统，不适合其他系统，所以存在一定的局限性。</p></li><li><p>DB（数据库）、DBMS（数据库管理系统）、SQL（结构化查询语言）</p></li><li><p>安装数据库，其实是安装数据库的服务端。</p></li></ol><p>关于卸载MySql：</p><ol><li>在windows里卸载后，其实还没卸载完全</li><li>在安装路径下，存在残留，要删除。</li><li>C盘根目录下，隐藏文件夹ProgramData存在数据库文件，存在mysql文件，要删除。</li></ol><p>停止/打开mysql服务</p><ol><li>通过命令行的方式</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net <span class="keyword">stop</span> mysql(musql为服务里面的mysql的名字)</span><br><span class="line">net <span class="keyword">start</span> mysql</span><br></pre></td></tr></table></figure><ol start="2"><li>通过windows服务页面</li></ol><p>退出mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit或者ctrl+C</span><br></pre></td></tr></table></figure><p>##本单元目标</p><pre><code>一、为什么要学习数据库二、数据库的相关概念          DBMS、DB、SQL三、数据库存储数据的特点四、初始MySQL    MySQL产品的介绍            MySQL产品的安装          ★            MySQL服务的启动和停止     ★    MySQL服务的登录和退出     ★          MySQL的常见命令和语法规范      五、DQL语言的学习   ★                  基础查询        ★                 条件查询         ★                排序查询         ★                    常见函数        ★                   分组函数        ★                  分组查询           ★                连接查询         ★                子查询       √                      分页查询       ★                  union联合查询    √            六、DML语言的学习    ★                 插入语句                            修改语句                            删除语句                        七、DDL语言的学习      库和表的管理     √                    常见数据类型介绍  √              常见约束        √            八、TCL语言的学习    事务和事务处理                 九、视图的讲解           √十、变量                      十一、存储过程和函数   十二、流程控制结构       </code></pre><p>##数据库的好处<br>    1.持久化数据到本地<br>    2.可以实现结构化查询，方便管理</p><p>##数据库相关概念<br>    1、DB：数据库，保存一组有组织的数据的容器<br>    2、DBMS：数据库管理系统，又称为数据库软件（产品），用于管理DB中的数据<br>    3、SQL:结构化查询语言，用于和DBMS通信的语言</p><p>##数据库存储数据的特点<br>    1、将数据放到表中，表再放到库中<br>    2、一个数据库中可以有多个表，每个表都有一个的名字，用来标识自己。表名具有唯一性。<br>    3、表具有一些特性，这些特性定义了数据在表中如何存储，类似java中 “类”的设计。<br>    4、表由列组成，我们也称为字段。所有表都是由一个或多个列组成的，每一列类似java 中的”属性”<br>    5、表中的数据是按行存储的，每一行类似于java中的“对象”。</p><p>##MySQL产品的介绍和安装</p><p>###MySQL服务的启动和停止<br>    方式一：计算机——右击管理——服务<br>    方式二：通过管理员身份运行<br>    net start 服务名（启动服务）<br>    net stop 服务名（停止服务）</p><p>###MySQL服务的登录和退出<br>    方式一：通过mysql自带的客户端<br>    只限于root用户</p><pre><code>方式二：通过windows自带的客户端登录：mysql 【-h主机名 -P端口号 】-u用户名 -p密码退出：exit或ctrl+C</code></pre><p>​<br>​<br>​<br>###MySQL的常见命令 </p><pre><code>1.查看当前所有的数据库show databases;2.打开指定的库use 库名3.查看当前库的所有表show tables;4.查看其它库的所有表show tables from 库名;5.创建表create table 表名(    列名 列类型,    列名 列类型，    。。。);6.查看表结构desc 表名;7.查看服务器的版本方式一：登录到mysql服务端select version();方式二：没有登录到mysql服务端mysql --version或mysql --V</code></pre><p>###MySQL的语法规范<br>    1.不区分大小写,但建议关键字大写，表名、列名小写<br>    2.每条命令最好用分号结尾<br>    3.每条命令根据需要，可以进行缩进 或换行<br>    4.注释<br>        单行注释：#注释文字<br>        单行注释：– 注释文字<br>        多行注释：/* 注释文字  */</p><p>​<br>​    </p><p>###SQL的语言分类<br>    DQL（Data Query Language）：数据查询语言<br>        select<br>    DML(Data Manipulate Language):数据操作语言<br>        insert 、update、delete<br>    DDL（Data Define Languge）：数据定义语言<br>        create、drop、alter<br>    TCL（Transaction Control Language）：事务控制语言<br>        commit、rollback</p><p>###SQL的常见命令</p><pre><code>show databases； 查看所有的数据库use 库名； 打开指定 的库show tables ; 显示库中的所有表show tables from 库名;显示指定库中的所有表create table 表名(    字段名 字段类型,        字段名 字段类型); 创建表desc 表名; 查看指定表的结构select * from 表名;显示表中的所有数据</code></pre><p>在navicat细节问题：</p><ol><li>在使用数据库的时候，要先打开指定的库，</li><li>``叫做着重号，一般使用在字段里面，但是不使用也没事，主要是区分是不是字段或者是不是着重号。</li><li>想执行某条语句，选中要执行的语句进行.</li></ol><p>##DQL语言的学习<br>###进阶1：基础查询<br>    语法：<br>    SELECT 要查询的东西<br>    【FROM 表名】;</p><pre><code>类似于Java中 :System.out.println(要打印的东西);特点：①通过select查询完的结果 ，是一个虚拟的表格，不是真实存在② 要查询的东西 可以是常量值、可以是表达式、可以是字段、可以是函数</code></pre><p>###进阶2：条件查询<br>    条件查询：根据条件过滤原始表的数据，查询到想要的数据<br>    语法：<br>    select<br>        要查询的字段|表达式|常量值|函数<br>    from<br>        表<br>    where<br>        条件 ;</p><pre><code>分类：一、条件表达式    示例：salary&gt;10000    条件运算符：    &gt; &lt; &gt;= &lt;= = != &lt;&gt;二、逻辑表达式示例：salary&gt;10000 &amp;&amp; salary&lt;20000逻辑运算符：    and（&amp;&amp;）:两个条件如果同时成立，结果为true，否则为false    or(||)：两个条件只要有一个成立，结果为true，否则为false    not(!)：如果条件成立，则not后为false，否则为true三、模糊查询示例：last_name like &#39;a%&#39;</code></pre><h4 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h4><p>方式一：使用AS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select last_name AS 姓 from teacher;</span><br></pre></td></tr></table></figure><p>方式二：省略AS，直接相连，也可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select last_name 姓 from teacher;</span><br></pre></td></tr></table></figure><p>如果是把结果显示为某一项，但是某一项有特殊符号，需要加””或者’’。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select age AS &quot;out put&quot; from students;</span><br></pre></td></tr></table></figure><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>distinct关键字</p><h4 id="号的作用"><a href="#号的作用" class="headerlink" title="+号的作用"></a>+号的作用</h4><p>加号+在mysql中只有一个功能，那就是作为运算符，</p><p>###进阶3：排序查询    </p><pre><code>语法：select    要查询的东西from    表where     条件order by 排序的字段|表达式|函数|别名 【asc|desc】</code></pre><p>​<br>###进阶4：常见函数<br>    一、单行函数<br>    1、字符函数<br>        concat拼接<br>        substr截取子串<br>        upper转换成大写<br>        lower转换成小写<br>        trim去前后指定的空格和字符<br>        ltrim去左边空格<br>        rtrim去右边空格<br>        replace替换<br>        lpad左填充<br>        rpad右填充<br>        instr返回子串第一次出现的索引<br>        length 获取字节个数</p><pre><code>2、数学函数    round 四舍五入    rand 随机数    floor向下取整    ceil向上取整    mod取余    truncate截断3、日期函数    now当前系统日期+时间    curdate当前系统日期    curtime当前系统时间    str_to_date 将字符转换成日期    date_format将日期转换成字符4、流程控制函数    if 处理双分支    case语句 处理多分支        情况1：处理等值判断        情况2：处理条件判断5、其他函数    version版本    database当前库    user当前连接用户</code></pre><p>​    </p><p>二、分组函数</p><pre><code>    sum 求和    max 最大值    min 最小值    avg 平均值    count 计数    特点：    1、以上五个分组函数都忽略null值，除了count(*)    2、sum和avg一般用于处理数值型        max、min、count可以处理任何数据类型    3、都可以搭配distinct使用，用于统计去重后的结果    4、count的参数可以支持：        字段、*、常量值，一般放1       建议使用 count(*)</code></pre><p>##进阶5：分组查询<br>    语法：<br>    select 查询的字段，分组函数<br>    from 表<br>    group by 分组的字段</p><p>​<br>​    特点：<br>​    1、可以按单个字段分组<br>​    2、和分组函数一同查询的字段最好是分组后的字段<br>​    3、分组筛选<br>​            针对的表    位置            关键字<br>​    分组前筛选：    原始表        group by的前面        where<br>​    分组后筛选：    分组后的结果集    group by的后面        having<br>​<br>​    4、可以按多个字段分组，字段之间用逗号隔开<br>​    5、可以支持排序<br>​    6、having后可以支持别名</p><p>##进阶6：多表连接查询</p><pre><code>笛卡尔乘积：如果连接条件省略或无效则会出现解决办法：添加上连接条件</code></pre><p>一、传统模式下的连接 ：等值连接——非等值连接</p><pre><code>1.等值连接的结果 = 多个表的交集2.n表连接，至少需要n-1个连接条件3.多个表不分主次，没有顺序要求4.一般为表起别名，提高阅读性和性能</code></pre><p>二、sql99语法：通过join关键字实现连接</p><pre><code>含义：1999年推出的sql语法支持：等值连接、非等值连接 （内连接）外连接交叉连接语法：select 字段，...from 表1【inner|left outer|right outer|cross】join 表2 on  连接条件【inner|left outer|right outer|cross】join 表3 on  连接条件【where 筛选条件】【group by 分组字段】【having 分组后的筛选条件】【order by 排序的字段或表达式】好处：语句上，连接条件和筛选条件实现了分离，简洁明了！</code></pre><p>​<br>三、自连接</p><p>案例：查询员工名和直接上级的名称</p><p>sql99</p><pre><code>SELECT e.last_name,m.last_nameFROM employees eJOIN employees m ON e.`manager_id`=m.`employee_id`;</code></pre><p>sql92</p><pre><code>SELECT e.last_name,m.last_nameFROM employees e,employees m WHERE e.`manager_id`=m.`employee_id`;</code></pre><p>##进阶7：子查询</p><p>含义：</p><pre><code>一条查询语句中又嵌套了另一条完整的select语句，其中被嵌套的select语句，称为子查询或内查询在外面的查询语句，称为主查询或外查询</code></pre><p>特点：</p><pre><code>1、子查询都放在小括号内2、子查询可以放在from后面、select后面、where后面、having后面，但一般放在条件的右侧3、子查询优先于主查询执行，主查询使用了子查询的执行结果4、子查询根据查询结果的行数不同分为以下两类：① 单行子查询    结果集只有一行    一般搭配单行操作符使用：&gt; &lt; = &lt;&gt; &gt;= &lt;=     非法使用子查询的情况：    a、子查询的结果为一组值    b、子查询的结果为空② 多行子查询    结果集有多行    一般搭配多行操作符使用：any、all、in、not in    in： 属于子查询结果中的任意一个就行    any和all往往可以用其他查询代替</code></pre><p>##进阶8：分页查询</p><p>应用场景：</p><pre><code>实际的web项目中需要根据用户的需求提交对应的分页查询的sql语句</code></pre><p>语法：</p><pre><code>select 字段|表达式,...from 表【where 条件】【group by 分组字段】【having 条件】【order by 排序的字段】limit 【起始的条目索引，】条目数;</code></pre><p>特点：</p><pre><code>1.起始条目索引从0开始2.limit子句放在查询语句的最后3.公式：select * from  表 limit （page-1）*sizePerPage,sizePerPage假如:每页显示条目数sizePerPage要显示的页数 page</code></pre><p>##进阶9：联合查询</p><p>引入：<br>    union 联合、合并</p><p>语法：</p><pre><code>select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union 【all】select 字段|常量|表达式|函数 【from 表】 【where 条件】 union  【all】.....select 字段|常量|表达式|函数 【from 表】 【where 条件】</code></pre><p>特点：</p><pre><code>1、多条查询语句的查询的列数必须是一致的2、多条查询语句的查询的列的类型几乎相同3、union代表去重，union all代表不去重</code></pre><p>##DML语言</p><p>###插入</p><p>语法：<br>    insert into 表名(字段名，…)<br>    values(值1，…);</p><p>特点：</p><pre><code>1、字段类型和值类型一致或兼容，而且一一对应2、可以为空的字段，可以不用插入值，或用null填充3、不可以为空的字段，必须插入值4、字段个数和值的个数必须一致5、字段可以省略，但默认所有字段，并且顺序和表中的存储顺序一致</code></pre><p>###修改</p><p>修改单表语法：</p><pre><code>update 表名 set 字段=新值,字段=新值【where 条件】</code></pre><p>修改多表语法：</p><pre><code>update 表1 别名1,表2 别名2set 字段=新值，字段=新值where 连接条件and 筛选条件</code></pre><p>###删除</p><p>方式1：delete语句 </p><p>单表的删除： ★<br>    delete from 表名 【where 筛选条件】</p><p>多表的删除：<br>    delete 别名1，别名2<br>    from 表1 别名1，表2 别名2<br>    where 连接条件<br>    and 筛选条件;</p><p>方式2：truncate语句</p><pre><code>truncate table 表名</code></pre><p>两种方式的区别【面试题】</p><pre><code>#1.truncate不能加where条件，而delete可以加where条件#2.truncate的效率高一丢丢#3.truncate 删除带自增长的列的表后，如果再插入数据，数据从1开始#delete 删除带自增长列的表后，如果再插入数据，数据从上一次的断点处开始#4.truncate删除不能回滚，delete删除可以回滚</code></pre><p>##DDL语句<br>###库和表的管理<br>库的管理：</p><pre><code>一、创建库create database 库名二、删除库drop database 库名</code></pre><p>表的管理：<br>    #1.创建表</p><pre><code>CREATE TABLE IF NOT EXISTS stuinfo(    stuId INT,    stuName VARCHAR(20),    gender CHAR,    bornDate DATETIME</code></pre><p>​<br>​    );<br>​<br>​    DESC studentinfo;<br>​    #2.修改表 alter<br>​    语法：ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;<br>​<br>    #①修改字段名<br>    ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;</p><pre><code>#②修改表名ALTER TABLE stuinfo RENAME [TO]  studentinfo;#③修改字段类型和列级约束ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;#④添加字段ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;#⑤删除字段ALTER TABLE studentinfo DROP COLUMN email;</code></pre><p>​<br>​    #3.删除表<br>​<br>​    DROP TABLE [IF EXISTS] studentinfo;</p><p>​    </p><p>###常见类型</p><pre><code>整型：小数：    浮点型    定点型字符型：日期型：Blob类型：</code></pre><p>###常见约束</p><pre><code>NOT NULLDEFAULTUNIQUECHECKPRIMARY KEYFOREIGN KEY</code></pre><p>##数据库事务<br>###含义<br>    通过一组逻辑操作单元（一组DML——sql语句），将数据从一种状态切换到另外一种状态</p><p>###特点<br>    （ACID）<br>    原子性：要么都执行，要么都回滚<br>    一致性：保证数据的状态操作前和操作后保持一致<br>    隔离性：多个事务同时操作相同数据库的同一个数据时，一个事务的执行不受另外一个事务的干扰<br>    持久性：一个事务一旦提交，则数据将持久化到本地，除非其他事务对其进行修改</p><p>相关步骤：</p><pre><code>1、开启事务2、编写事务的一组逻辑操作单元（多条sql语句）3、提交事务或回滚事务</code></pre><p>###事务的分类：</p><p>隐式事务，没有明显的开启和结束事务的标志</p><pre><code>比如insert、update、delete语句本身就是一个事务</code></pre><p>显式事务，具有明显的开启和结束事务的标志</p><pre><code>    1、开启事务    取消自动提交事务的功能    2、编写事务的一组逻辑操作单元（多条sql语句）    insert    update    delete    3、提交事务或回滚事务</code></pre><p>###使用到的关键字</p><pre><code>set autocommit=0;start transaction;commit;rollback;savepoint  断点commit to 断点rollback to 断点</code></pre><p>###事务的隔离级别:</p><p>事务并发问题如何发生？</p><pre><code>当多个事务同时操作同一个数据库的相同数据时</code></pre><p>事务的并发问题有哪些？</p><pre><code>脏读：一个事务读取到了另外一个事务未提交的数据不可重复读：同一个事务中，多次读取到的数据不一致幻读：一个事务读取数据时，另外一个事务进行更新，导致第一个事务读取到了没有更新的数据</code></pre><p>如何避免事务的并发问题？</p><pre><code>通过设置事务的隔离级别1、READ UNCOMMITTED2、READ COMMITTED 可以避免脏读3、REPEATABLE READ 可以避免脏读、不可重复读和一部分幻读4、SERIALIZABLE可以避免脏读、不可重复读和幻读</code></pre><p>设置隔离级别：</p><pre><code>set session|global  transaction isolation level 隔离级别名;</code></pre><p>查看隔离级别：</p><pre><code>select @@tx_isolation;</code></pre><p>##视图<br>含义：理解成一张虚拟的表</p><p>视图和表的区别：</p><pre><code>    使用方式    占用物理空间视图    完全相同    不占用，仅仅保存的是sql逻辑表    完全相同    占用</code></pre><p>视图的好处：</p><pre><code>1、sql语句提高重用性，效率高2、和表实现了分离，提高了安全性</code></pre><p>###视图的创建<br>    语法：<br>    CREATE VIEW  视图名<br>    AS<br>    查询语句;<br>###视图的增删改查<br>    1、查看视图的数据 ★</p><pre><code>SELECT * FROM my_v4;SELECT * FROM my_v1 WHERE last_name=&#39;Partners&#39;;2、插入视图的数据INSERT INTO my_v4(last_name,department_id) VALUES(&#39;虚竹&#39;,90);3、修改视图的数据UPDATE my_v4 SET last_name =&#39;梦姑&#39; WHERE last_name=&#39;虚竹&#39;;</code></pre><p>​<br>​    4、删除视图的数据<br>​    DELETE FROM my_v4;<br>###某些视图不能更新<br>    包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all<br>    常量视图<br>    Select中包含子查询<br>    join<br>    from一个不能更新的视图<br>    where子句的子查询引用了from子句中的表<br>###视图逻辑的更新<br>    #方式一：<br>    CREATE OR REPLACE VIEW test_v7<br>    AS<br>    SELECT last_name FROM employees<br>    WHERE employee_id&gt;100;</p><pre><code>#方式二:ALTER VIEW test_v7ASSELECT employee_id FROM employees;SELECT * FROM test_v7;</code></pre><p>###视图的删除<br>    DROP VIEW test_v1,test_v2,test_v3;<br>###视图结构的查看<br>    DESC test_v7;<br>    SHOW CREATE VIEW test_v7;</p><p>##存储过程</p><p>含义：一组经过预先编译的sql语句的集合<br>好处：</p><pre><code>1、提高了sql语句的重用性，减少了开发程序员的压力2、提高了效率3、减少了传输次数</code></pre><p>分类：</p><pre><code>1、无返回无参2、仅仅带in类型，无返回有参3、仅仅带out类型，有返回无参4、既带in又带out，有返回有参5、带inout，有返回有参注意：in、out、inout都可以在一个存储过程中带多个</code></pre><p>###创建存储过程<br>语法：</p><pre><code>create procedure 存储过程名(in|out|inout 参数名  参数类型,...)begin    存储过程体end</code></pre><p>类似于方法：</p><pre><code>修饰符 返回类型 方法名(参数类型 参数名,...)&#123;    方法体;&#125;</code></pre><p>注意</p><pre><code>1、需要设置新的结束标记delimiter 新的结束标记示例：delimiter $CREATE PROCEDURE 存储过程名(IN|OUT|INOUT 参数名  参数类型,...)BEGIN    sql语句1;    sql语句2;END $2、存储过程体中可以有多条sql语句，如果仅仅一条sql语句，则可以省略begin end3、参数前面的符号的意思in:该参数只能作为输入 （该参数不能做返回值）out：该参数只能作为输出（该参数只能做返回值）inout：既能做输入又能做输出</code></pre><p>#调用存储过程<br>    call 存储过程名(实参列表)<br>##函数</p><p>###创建函数</p><p>学过的函数：LENGTH、SUBSTR、CONCAT等<br>语法：</p><pre><code>CREATE FUNCTION 函数名(参数名 参数类型,...) RETURNS 返回类型BEGIN    函数体END</code></pre><p>###调用函数<br>    SELECT 函数名（实参列表）</p><p>###函数和存储过程的区别</p><pre><code>        关键字        调用语法    返回值            应用场景函数        FUNCTION    SELECT 函数()    只能是一个        一般用于查询结果为一个值并返回时，当有返回值而且仅仅一个存储过程    PROCEDURE    CALL 存储过程()    可以有0个或多个        一般用于更新</code></pre><p>##流程控制结构</p><p>###系统变量<br>一、全局变量</p><p>作用域：针对于所有会话（连接）有效，但不能跨重启</p><pre><code>查看所有全局变量SHOW GLOBAL VARIABLES;查看满足条件的部分系统变量SHOW GLOBAL VARIABLES LIKE &#39;%char%&#39;;查看指定的系统变量的值SELECT @@global.autocommit;为某个系统变量赋值SET @@global.autocommit=0;SET GLOBAL autocommit=0;</code></pre><p>二、会话变量</p><p>作用域：针对于当前会话（连接）有效</p><pre><code>查看所有会话变量SHOW SESSION VARIABLES;查看满足条件的部分会话变量SHOW SESSION VARIABLES LIKE &#39;%char%&#39;;查看指定的会话变量的值SELECT @@autocommit;SELECT @@session.tx_isolation;为某个会话变量赋值SET @@session.tx_isolation=&#39;read-uncommitted&#39;;SET SESSION tx_isolation=&#39;read-committed&#39;;</code></pre><p>###自定义变量<br>一、用户变量</p><p>声明并初始化：</p><pre><code>SET @变量名=值;SET @变量名:=值;SELECT @变量名:=值;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select @变量名;</code></pre><p>二、局部变量</p><p>声明：</p><pre><code>declare 变量名 类型 【default 值】;</code></pre><p>赋值：</p><pre><code>方式一：一般用于赋简单的值SET 变量名=值;SET 变量名:=值;SELECT 变量名:=值;方式二：一般用于赋表 中的字段值SELECT 字段名或表达式 INTO 变量FROM 表;</code></pre><p>使用：</p><pre><code>select 变量名</code></pre><p>二者的区别：</p><pre><code>        作用域            定义位置        语法</code></pre><p>用户变量    当前会话        会话的任何地方        加@符号，不用指定类型<br>局部变量    定义它的BEGIN END中     BEGIN END的第一句话    一般不用加@,需要指定类型</p><p>###分支<br>一、if函数<br>    语法：if(条件，值1，值2)<br>    特点：可以用在任何位置</p><p>二、case语句</p><p>语法：</p><pre><code>情况一：类似于switchcase 表达式when 值1 then 结果1或语句1(如果是语句，需要加分号) when 值2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）情况二：类似于多重ifcase when 条件1 then 结果1或语句1(如果是语句，需要加分号) when 条件2 then 结果2或语句2(如果是语句，需要加分号)...else 结果n或语句n(如果是语句，需要加分号)end 【case】（如果是放在begin end中需要加上case，如果放在select后面不需要）</code></pre><p>特点：<br>    可以用在任何位置</p><p>三、if elseif语句</p><p>语法：</p><pre><code>if 情况1 then 语句1;elseif 情况2 then 语句2;...else 语句n;end if;</code></pre><p>特点：<br>    只能用在begin end中！！！！！！！！！！！！！！！</p><p>三者比较：<br>            应用场合<br>    if函数        简单双分支<br>    case结构    等值判断 的多分支<br>    if结构        区间判断 的多分支</p><p>###循环</p><p>语法：</p><pre><code>【标签：】WHILE 循环条件  DO    循环体END WHILE 【标签】;</code></pre><p>特点：</p><pre><code>只能放在BEGIN END里面如果要搭配leave跳转语句，需要使用标签，否则可以不用标签leave类似于java中的break语句，跳出所在循环！！！</code></pre>]]></content>
      
      
      <categories>
          
          <category> MySql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语言</title>
      <link href="2021/08/13/Java/"/>
      <url>2021/08/13/Java/</url>
      
        <content type="html"><![CDATA[<p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210831130537444.png" alt="image-20210831130537444"></p><p>最近在复盘 Java 基础，有些在之前的学习过程中遗忘，现在进行查缺补漏。</p><a id="more"></a> <h1 id="Java语言学习"><a href="#Java语言学习" class="headerlink" title="Java语言学习"></a>Java语言学习</h1><h2 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h2><h2 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>命名规范：</p><p>类名：XxxYyyZzz </p><p>包名：xxxyyyzzz</p><p>常量名、方法名还有多单词首字母大写时：xxxYyyZzz</p><p>常量名：所有字母都大写，多单词用下划线 XXX_YYY_ZZZ，除此之外还要见名知意。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量必须先声明再赋值</p><h4 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h4><p><strong>8种基本数据类型：</strong></p><p>byte：1字节，占8bit（位）、bit不是存0就是存1，标识范围：-128～127（-2*2的7次方～2的7次方-1）。</p><p>short：2字节。</p><p>int：4字节，经常用。</p><p>long：8字节：声明long型的变量，必须以l或者L结尾。只是标示一下。</p><p>float：4字节，精度有限，单精度，虽然也占4个字节，但是要比int表示的范围还要大。定义float类型要以f或者F结尾，只是标示。</p><p>doublt：8字节，双精度，精度要高。要用浮点型的话，经常用double，但是不如float存的多。</p><p>char：（1个字符等于2个字节，16位）例：char c1= ‘a’，只能写一个字符，不能写两个。char c2 = ‘\n’,表示换行</p><p>boolean：只能有两个值，一个是true，一个是false。</p><p><u>字符集，所有的东西在存储的时候都是01010…..，但是展现的时候是丰富多彩的，a = 3 ，美国的ASCII规定了每个字符代表着什么，比如，a为97，但是中国却不能一一对应，Unicode是使用最广的一种，但是落地的是UTF-8，我们都是用它。</u></p><p><strong>3种引用类型：</strong>（以后再说）</p><p>class：</p><p>interface</p><p>[]数组（字符串是一个类类型）</p><p><strong>7种基本数据类型（不包括boolean）之间的运算规则</strong>：</p><p>byte、char、short –&gt;int –&gt; long –&gt;float –&gt; double</p><ul><li>自动类型提升：</li></ul><ol><li>byte和int类型做运算，转为int型，转为long型也可以，使用float型也可以，会补小数点。</li><li>char和int做运算，转为int类型，但是byte和char还要short俩俩做运算时，只能使用int型。</li></ol><p><strong>总结：</strong>当容量小的变为数据类型转位容量大的类型的时候，自动提升为容量大的。</p><ul><li>强制类型转换（自动类型提升的逆运算）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> b1 = <span class="number">12.3</span></span><br><span class="line"><span class="keyword">int</span> i1 = (<span class="keyword">int</span>)b1</span><br><span class="line">结果：<span class="number">12</span></span><br></pre></td></tr></table></figure><p>强制转换可能会导致精度损失</p><p><strong>String</strong></p><p>String属于引用数据类型，翻译为字符串，是可以和8种数据类型做运算的，且运算只能是连接运算，</p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>要不停的敲，不停的写代码，边写边想，强化记忆，刚开始拿来题目不会很正常，但是要想且要敲就好了。</p><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>+、-、*、/、%、++、–、+（字符串连接）</p><p>a++、++a、（先写先加，后写后加），这种自增1不会改变原来的数据类型。</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>=、+=、-=、*=、/=，%=</p><p>+=：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 = s1 +<span class="number">2</span>;</span><br><span class="line">s1 += <span class="number">2</span>;</span><br><span class="line">第一种不会改变变量本身的数据类型，第二种会改变本身的数据类型。</span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>(结果是boolean型)</p><p>==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof</p><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符只能适用于布尔类型的变量</p><p>&amp;（逻辑与）、|（逻辑或）、！（逻辑非）、&amp;&amp;(短路与)、||（短路或）、^ （逻辑异或）</p><p>&amp;（逻辑与）：全为真才为真</p><p>|（逻辑或）：有一个为真就是真</p><p>&amp;&amp;(短路与)：全是真才为真</p><p>||（短路或）：有一个真就是真</p><p>^ （逻辑异或）：相同为false，不同就为true。</p><p>问题1:<strong>&amp;和&amp;&amp;之间的相同点与区别</strong></p><ol><li>都表示且对关系，只有当都满足（true）的时候才才为真</li><li>当左边是true 的时候，右边都执行。</li><li>当左边是false 的时候，&amp;&amp;左边为false 的时候，右边就不执行了。</li></ol><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>&lt;&lt;（左移）、&gt;&gt;（右移）、&gt;&gt;&gt;（无符号右移）、&amp;（与运算）、|（或运算）、^（异或运算） 、～（）取反运算</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>（条件表达式）？表达式1:表达式2；</p><p>true：执行表达式1，false：执行表达式2</p><p>三元运算符是可以嵌套的，除此之外，凡是可以使用三元运算符的，都是可以使用if else语句的。但是反过来是不一定的。</p><h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>if … else</p><p>switch….</p><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>for循环、while循环、do while循环</p><p><strong>break与continue的关系</strong></p><p>break应用在switch-case循环结构中，当调用break时，是结束<strong>当前</strong>循环</p><p>continue应用在循环结构中，只是结束<strong>当次</strong>循环。</p><h2 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h2><ol><li>Eclipse中的workspace就是工作空间，把所有的代码自动放在一个空间里。</li><li>eclipse导入到工作空间中，如果工作空间中有一个相同的项目，更改名字是不能够导入的，这时候要改一下工作空间中的项目名字，再把项目整进去，可以选择复制进去，然后进行删除页面的项目。</li><li>关于单个文件的乱码问题，可以单独用记事本打开，然后另存为UTF-8的格式，然后再粘进去。Notepad软件能够直接更改格式。</li></ol><h2 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h2><p>内存中的区域：方法区、虚拟机栈、本地方法栈、堆、程序计数器。</p><h2 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h2><ol><li><p>可变形参方法的函数中，如过还有一个确定的形参，需要把确定的形参放到前面，可变形参放到后面。</p></li><li><p>可变形参数一个方法只能有一个。</p></li><li><p>关于值传递机制：形参接受的是实参的地址值。</p></li></ol><h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><p>java规定的四种权限修饰符，private、缺省、provated、public</p><p>修饰类的话只能是public或者是缺省。其他的不能修饰类。</p><p>任何一个类，都有构造器。constructor：建造者。</p><p>默认的构造器的权限跟类的权限相同。</p><p>构造器的作用：</p><ol><li>创建对象。</li><li>还可以进行对对象进行初始化。</li></ol><p>new + 构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>只要显示定义了构造器，系统就不再提供空参构造器。</p><p>属性赋值的先后顺序：1.默认初始化值、2.显示初始化值（在类的属性中进行赋值）3.构造器赋值、4.方法赋值</p><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>可以修饰：属性、方法、构造器</p><p>this理解为：当前对象或者为正在创建的对象，可以this.属性或者this.方法，一般我们都不写this，但是当方法的形参和类的属性同名的时候，就要使用this。</p><p>this可以修饰构造器</p><p>原因：当不同构造器中含有很多相同的方法，除了把相同的方法写成一个函数，也可以调用构造器。</p><p>如果一个类中有n个构造器，那么最多有（n-1）个构造器使用了this（形参列表）</p><p>this（构造器）一定要放在构造器的首行。</p><p>构造器内部只能声明一个this（形参列表），用来调用其他的构造器。</p><h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><p>关于多态：</p><p>这里Person是父类，Man是子类。这里是：父亲的引用指向子类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = <span class="keyword">new</span> Man</span><br></pre></td></tr></table></figure><p>这里面执行的是子类重写父类的方法（work()方法在子类的方法中重写过）也就是子父类都有walk()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.work()</span><br></pre></td></tr></table></figure><p>而earnMoney()方法是子类特有的方法，但是p2.earnMoney()是不能调用的，因为父类中没有</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.earnMoney()</span><br></pre></td></tr></table></figure><p>多态时是运行时行为，</p><p>使用前提：1⃣️ 类的继承 2⃣️方法的重写</p><p>说明：</p><ol><li><p>如果子父类有一个相同的属性，在new完对象的时候，如果调用子父类都有的属性，调用的是父类的属性，所以说，多态适合于方法，而不适合于属性，</p></li><li><p>有了对象以后，我们在编译期，只能调用父类声明的方法，但在运行期，执行的是子类重写父类的方法。</p><p>有了对象的多态性以后，内存中实际上是加载了子类的属性和方法的，到那时由于变量声明为父类类型，</p><p>导致编译时，只能调用父类声明的属性和方法，子类特有的属性和方法不能够调用。</p></li></ol><p>如何能调用子类特有的属性和方法？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man m1 = (Man)p2</span><br></pre></td></tr></table></figure><p>这里p2是父类类型的对象，进行父类向子类对象进行强转。也就是<strong>向下转型</strong>（父类向子类转）</p><p>使用强转时，可能会造成ClassCastExceotion的异常，比如Momen和Man都是Person的子类，但是如果这样使用就会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Women w1 = (Women)p2</span><br></pre></td></tr></table></figure><p>这样会报错，这里引入：instanceof关键字，使用情景，为了避免在向下转型出现异常，使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> A</span><br></pre></td></tr></table></figure><p>如果是，那就继续执行，不是就不执行了。</p><p>如果a instanceof A为true，那么a instance B也一定对，那么B一定是A 的父类。</p><p>== 和equals() 的区别</p><p>== ：运算符</p><ol><li>可以使用在基本数据类型变量和引用数据类型变量中(但如果比较多是基本数据类型，知识比较多数据是否相等，类型不一定相同)</li><li>如果比较的是引用数据类型，那么比较多两个对象的地址值是不是相同。</li></ol><p>equals()：是一个方法</p><ol><li>只适用于引用数据类型 。</li><li>Object类中的equals()中与 == 相同。</li><li>但是，像String、Date、File等包装类都重写了Object类中的equals()，重写以后，比较的不是引用的地址值是不是相同，而是比较的是两个对象的“实体内容”是不是相同。</li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210817201217488.png" alt="image-20210817201217488"></p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>视频301</p><h3 id="基本数据类型与包装类"><a href="#基本数据类型与包装类" class="headerlink" title="基本数据类型与包装类"></a>基本数据类型与包装类</h3><p>int对应与Integer类，一般我们都需要进行如下操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Intenger int1 = <span class="keyword">new</span> Intenger(i);</span><br></pre></td></tr></table></figure><p>此时，int1就为Integer 的对象，但是以下操作也是正确的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">Integer int1 = num2;</span><br></pre></td></tr></table></figure><p>这里面设计自动封箱，以前还需要进行包装，现在是不需要进行包装。</p><p>自动装箱和自动拆箱是JDK 5.0以后才有的，拿过来使用即可。</p><p>基本数据类型、包装类 —&gt; String类型：调用String重载的valueof()</p><p>重点：基本数据类型和包装类 转 String 使用valueof(),String转为基本数据类型、包装类的时候使用parseXXX(String).</p><h2 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h2><p>如果在类中声明了static类型的，那就不归某一个对象所拥有，所有创建的对象，都有static的这部分，翻译为静态的</p><p>static可以修饰：属性、方法、代码块、内部类。不能修饰构造器。</p><ol><li>static修饰属性叫做静态变量，</li></ol><p>属性：按是否使用static修饰，氛围静态属性 vs 非静态属性（实例变量）。</p><p>静态变量随着类的加载而加载，静态变量加载要早于对象的创建。由于类只加载一次，所以，静态变量也只加载一次，存在于<strong>方法区的静态域</strong>中。</p><p>举例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println()</span><br></pre></td></tr></table></figure><p>没有声明但是可以进行使用，就因为是静态变量，不需要创建对象就可以使用。</p><ol><li>static修饰方法</li></ol><p>随着类的加载而加载，也就是说，在不创建对象的时候，也是可以进行调用的。</p><p>静态方法中，只能调用静态的方法或者属性</p><p>非静态方法中，既可以进行调用非静态的属性和方法，也可以调用静态的方法和属性。</p><p>开发中，如何确定一个属性是否应该声明为static的？</p><ul><li>属性不会随着对象的不同而不同的。</li></ul><p>开发中，如何确定一个属性是否应该声明为static的？</p><ul><li>如果一个属性被设置为静态的，调用这些属性的时候不需要造对象。还有一些经常用的工具类，也经常设置为静态的。</li></ul><p>饿汉式：一上来就造好了。</p><p>懒汉式：啥时候用啥时候造，属于懒汉式，什么时候用什么时候造。</p><p>区分饿汉式和懒汉式，（一般懒汉式比较好，延迟对象的创建）</p><p>饿汉式：坏处，对象加载时间过长，好处：线程安全的。</p><p>懒汉式：好处：延迟对象的创建，坏处：目前线程不安全，到多线程的时候在进行修改。</p><p>单例模式应用场景：</p><ol><li>网站的计数器</li><li>应用程序的日志应用</li><li>数据库连接池</li><li>读取配置文件的类</li><li>Application也是单例</li><li>windows 的任务管理器及回收站也是单例模式。</li></ol><h2 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块也叫做初始化块，写在类里面哪里都可以，使用一对大括号{}表示</p><p>代码块的作用：用来初始化类、对象，<strong>只能使用static 修饰</strong>，不能使用其他的修饰</p><p>于是分为：<strong>静态代码块、非静态代码块</strong></p><ul><li>静态代码块</li></ul><ol><li>内部可以有输出语句</li><li><strong>随着类的加载而执行，而且只加载一次，</strong>静态方法是随着类的加载而加载，但是不调用就不会起作用，而静态代码块只要是类加载进去，就被调用。作用<strong>是可以初始化类的一些信息</strong>。</li><li>如果定义了多个静态代码块，那么按照先后顺序进行执行。</li><li>静态代码块的执行要优于非静态代码块的执行。</li><li>对于静态代码块内，只能调用静态的属性和方法，不能调用非静态的结构。</li></ol><ul><li>非静态代码块</li></ul><ol><li>内部可以有输出语句</li><li><strong>随着对象的创建而执行，</strong>每造一个对象就执行一次非静态代码块。也就是说，在创建对象时，<strong>对对象的属性进行初始化。</strong></li><li>如果定义了多个非静态代码块，那么按照先后顺序进行执行。</li><li>非静态代码块，可以调用静态的属性、静态的方法、或者非静态的属性、非静态的方法。</li></ol><p>对属性可以赋值的位置：</p><ol><li>默认初始化</li><li>显示初始化/在代码块中进行赋值（谁在前面谁先执行）</li><li>构造器中初始化</li><li>有了对象以后，可以通过“对象.属性”或”对象.方法”进行赋值。</li></ol><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final关键字可以修饰的结构：类、方法、变量</p><ul><li><p>final修饰类的时候：代表该类没有子类，绝了。像是String类、System类、StringBufffer类就是final的。</p></li><li><p>修饰方法的时候；表示该方法不能被子类进行重写，比如Object类中的getClass()方法就是final的。</p></li></ul><p>这里涉及到native关键字,native代表着调用底层的c或者c++</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure><ul><li>final修饰变量，那么变量就变为常量，<ul><li>final修饰属性：可以考虑赋值的位置；显示初始化、代码块中赋值、构造器中初始化、其他的都不行</li><li>final修饰局部变量（局部变量有方法内部的局部变量，另一种是形参）<ul><li>尤其是使用final修饰形参时，这时候表明此形参为常量。当我们调用此方法时，会穿入一个数值，一旦传入后，就没办法改变了。</li></ul></li></ul></li></ul><p>satatic final 组合可以修饰属性（我们成为全局常量）和方法（用的比较少）</p><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><p>abstract关键字的使用</p><p>可以修饰类、方法（不可以修饰属性、构造器，也不能修饰私有方法和静态方法、final 的方法、final的类）</p><p>使用abstract修饰类的时候，一旦修饰类，就不能创建对象了，也就是不能实例化了。但是其子类可以进行创建对象，子类创建对象的时候，回调用父类中构造器，所有父类的构造器还是有用的。</p><p>修饰方法的时候，就没有方法体了,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><strong>包含抽象方法的类，一定是抽象类。反之，抽象类是可以没有抽象方法的。</strong></p><p>子类继承抽象类的时候，要么重写一下，要么也写为抽象类。如果重写了父类的所有抽象方法的时候，此时子类才可以进行实例化。若子类没有全部重写抽象方法，那么子类也需要写为抽象类。</p><h3 id="匿名对象于抽象类的匿名子类"><a href="#匿名对象于抽象类的匿名子类" class="headerlink" title="匿名对象于抽象类的匿名子类"></a>匿名对象于抽象类的匿名子类</h3><p>匿名对象：只是new出来的一个对象，并没有进行赋值</p><p>抽象类的匿名子类</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口和类属于并列关系，但是在java中只能进行单继承，不能进行多继承，使用接口就可以实现多重继承的效果。</p><p>有时候我们需要在几个类中抽取一些相同的特征，但是他们之间有不适is-a的关系，只是具有相同行为的特征。</p><p>接口使用interface关键字</p><h4 id="如何定义接口"><a href="#如何定义接口" class="headerlink" title="如何定义接口"></a>如何定义接口</h4><p>接口中可以定义的成员：</p><p>JDK7及以前：只能定义全局常量和抽象方法</p><ul><li>全局常量：public static final 的，但是书写时可以不写public static final</li><li>抽象方法：public abstract 的</li></ul><p>JDK8：除了定义全局常量和抽象方法以外，还可以定义静态方法、默认方法（略）</p><p>接口中是不能定义构造器的，也就是说接口是不能进行实例化的</p><p>在java开发中，接口通过让类实现（implements）的方式来使用，如果实现类实现了抽象类中的所有抽象方法，那么此类就可以进行实例化。如果没有全部实现，那么此类还是抽象类，需要加入abstract。</p><p>java类可以实现多个接口，于是就弥补了单继承的局限性。</p><p>格式：class AA extends BB implements CC,DD,EE</p><p>接口和接口之间的关系是：继承，而且还是多继承，不像类一样只可以进行单继承。</p><h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>接口的具体使用，体现了多态性，接口实际上可以看做一种规范。（具体不明白接口定义了规范看视频351）</p><ol><li><p>在JDK8以后，如果在接口中定义了静态方法，子类实现接口的时候，并且在创建子类对象的时候，子类对象是拿不到接口中定义的静态方法。只能通过接口来调用，这时接口就有点像工具类了。</p></li><li><p>如果是默认方法，通过子类的实现接口，并且创建子类对象是可以调用默认方法的。如果想重写，直接在子类中进行重写。</p></li><li><p>如果一个子类继承了父类并且实现了一个接口，但是此时父类有一个和实现接口相同的同名同参数的默认方法，此时在子类实例中调用的时候，优先考虑父类中的方法，成为类优先原则。</p></li><li><p>如果一个子类只是实现了多个接口，但是接口中有相同的同名同参数的默认方法，那么在实现类中没有重写此方法的情况下，会报错，接口冲突，解决冲突就需要在子类中进行重写方法。</p></li><li><p>如何在子类的方法中调用父类、接口中重写的方法？</p><p>形式：接口.super.方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompareA.<span class="keyword">super</span>.method();</span><br></pre></td></tr></table></figure></li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B就是内部类，类A就成为内部类</p><p>内部类有分为成员内部类和局部内部类，成员内部类和属性并列，局部内部类是定义在（类方法、代码块、构造器）里面的类。</p><p>成员内部类也是可以定义类的所有东西，可以被final修饰，可以被abstract修饰（不可被实例化）</p><h2 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h2><p>异常处理分为：Error和Exception,这里主要说明一下Exception。</p><p>Exception又分为编译时异常(非受检异常)和运行时异常(受检异常)</p><p>面试题：常见的异常有哪些？举例说明。</p><p>编译时异常：IOException、ClassNotFondException</p><p>运行时异常：</p><ul><li>NullPointerException(空指针异常)</li><li>ArrayIndexOutOfBoundException(数组角标越界)还有字符串角标越界</li><li>ClassCastException(类型转换异常)</li><li>NumberFormatException</li><li>InputMismatchException(输入不匹配异常)</li><li>ArithmeticException(算数异常)</li><li>······</li></ul><h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>两种方式：</p><p>方式一：Try-catch-finally</p><p>方式二：throws+异常类型</p><p>异常的处理：抓抛模型</p><p>过程一：“抛”：程序在执行的过程中，一旦出现异常，就会在异常代码出生成一个异常类对象。并将此对象抛出，一旦抛出异常对象以后，其后的代码就不再执行了。</p><p>过程二：“抓”：可以理解为异常处理的方式，也就是上面的两种方式。</p><h3 id="Try-catch-finally的使用"><a href="#Try-catch-finally的使用" class="headerlink" title="Try-catch-finally的使用"></a>Try-catch-finally的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//处理异常类型的1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>finally是可选的，如果没得，如果在try{}里面出现异常，会出现一个异常类的对象，如果被捕获切匹配成功，则说明匹配，以后的catch{}就不执行了，跳出try-catch结构。继续执行后面的代码。</p><p>说明：catch中的异常类型，如果没有子父类关系，谁先谁后无所谓，如果是含有子父类关系，那么要求子类在先，父类在后，不这样做就会报错，显示后面的catch不可到达。</p><p>常用的异常对象处理的方式：1⃣️String getMessage() 2⃣️2printStackTrace</p><p>注意：在try{}里面声明的变量，出了结构以后就不能用了。解决方法：可以在外面声明，在里面进行赋值。</p><p>使用try-catch-finally处理编译时异常时，使得程序不在报错，但是在运行时可不一定不报错。</p><p>finally中声明的都是一定被执行的代码，即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p><p>什么写在finally块内？</p><ul><li>想数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要手动的对资源进行释放，此时写在finally内。</li></ul><p>try-catch-finally也是可以进行嵌套的。</p><p>现实开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，我们只针对编译型异常进行处理。</p><h3 id="thows-异常类型"><a href="#thows-异常类型" class="headerlink" title="thows+异常类型"></a>thows+异常类型</h3><p>样例：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210817195846461.png" alt="image-20210817195846461"></p><p>throws + 异常类型写在方法的声明处，指明此方法执行时，可能会抛出的异常，一旦方法体执行时，出现异常，仍会在异常代码处声明一个异常类，此对象满足throws后异常类型时，就会被抛出，异常代码的后续代码，就不再执行了。</p><p>try-catch-finally :真正的将异常处理掉了</p><p>throws：只是把异常抛给了方法的调用者，并没有真正解决异常。</p><h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法有异常，则必须使用try-catch-finally方式进行处理。    </p><p>关于异常的产生？</p><ol><li>系统自动生成</li><li>手动生成一个异常对象，并抛出(throw), 注意：throw 与throws不一样。</li></ol><h3 id="用户自定义异常类"><a href="#用户自定义异常类" class="headerlink" title="用户自定义异常类"></a>用户自定义异常类</h3><h4 id="如何自定义异常类？"><a href="#如何自定义异常类？" class="headerlink" title="如何自定义异常类？"></a>如何自定义异常类？</h4><ol><li>写一个类继承于现有的异常类：RuntimeException或Exception</li><li>提供全局常量：serialVersionUID，可以模仿父类里面的写，可以理解为对类的标识。</li><li>提供重载的构造器</li></ol><h4 id="异常处理练习：视频382"><a href="#异常处理练习：视频382" class="headerlink" title="异常处理练习：视频382"></a>异常处理练习：视频382</h4><h3 id="throws与throw-的不同"><a href="#throws与throw-的不同" class="headerlink" title="throws与throw 的不同"></a>throws与throw 的不同</h3><p>他俩没什么关系，顶多是在讲异常的时候一起讲的。</p><p>throws是异常处理的一种方式，声明在方法的声明处。</p><p>而throw是生成一个异常对象声明在方法体内，抛出对象的一种情况。</p><h2 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h2><h2 id="day18-多线程"><a href="#day18-多线程" class="headerlink" title="day18 多线程"></a>day18 多线程</h2><h3 id="基本概念：程序、进程、线程"><a href="#基本概念：程序、进程、线程" class="headerlink" title="基本概念：程序、进程、线程"></a>基本概念：程序、进程、线程</h3><p><strong>程序</strong>(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。<br><strong>进程</strong>(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期<br>例如：运行中的QQ，运行中的MP3播放器，程序是静态的，进程是动态的</p><p>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域<br><strong>线程</strong>(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p><ul><li><p>若一个进程同一时间并行执行多个线程，就是支持多线程的</p></li><li><p>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</p></li><li><p>一个进程中的多个线程共享相同的内存单元/内存地址空间à它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p></li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210818200735250.png" alt="image-20210818200735250"></p><h3 id="多线程创建的方式"><a href="#多线程创建的方式" class="headerlink" title="多线程创建的方式"></a>多线程创建的方式</h3><p>方式一：继承与Thread类</p><ol><li>写一个类继承于Thread类</li><li>重写Thread类里面的run()方法，把要执行的代码写在此方法里。</li><li>创建Thread类的子类对象</li><li>通过此对象调用start()方法</li></ol><p>方式二：实现Runnable接口</p><ol><li>创建一个实现了Runnable接口的类</li><li>实现类去实现Runnable中的抽象方法：run()</li><li>创建实现类的对象</li><li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li><li>通过Thread类的对象调用start()</li></ol><p>比较创建线程的两种方式:</p><ul><li><p>开发中：优先选择：实现Runnable接口的方式</p></li><li><p>原因：</p><ol><li><p>实现的方式没有类的单继承性的局限性</p></li><li><p>实现的方式更适合来处理多个线程有共享数据的情况。</p></li></ol></li><li><p>联系：public class Thread implements Runnable</p></li><li><p>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p></li></ul><p>发现：Thread类本身也是实现类Runnable接口，方式一是继承Thread类，然后重写父类的run()方法，方式二是直接进行实现Runnable()接口，进而重写run()方法。</p><h3 id="测试Thread中的常用方法："><a href="#测试Thread中的常用方法：" class="headerlink" title="测试Thread中的常用方法："></a>测试Thread中的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. start():启动当前线程；调用当前线程的run()</span><br><span class="line">2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</span><br><span class="line">3. currentThread():静态方法，返回执行当前代码的线程</span><br><span class="line">4. getName():获取当前线程的名字</span><br><span class="line">5. setName():设置当前线程的名字</span><br><span class="line">6. yield():释放当前cpu的执行权</span><br><span class="line">7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</span><br><span class="line">8. stop():已过时。当执行此方法时，强制结束当前线程。</span><br><span class="line">9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</span><br><span class="line">10. isAlive():判断当前线程是否存活</span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY：10</span><br><span class="line">MIN _PRIORITY：1</span><br><span class="line">NORM_PRIORITY：5  --&gt;默认优先级</span><br></pre></td></tr></table></figure><p>如何获取和设置当前线程的优先级：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPriority():获取线程的优先级</span><br><span class="line">setPriority(int p):设置线程的优先级</span><br><span class="line">说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</span><br></pre></td></tr></table></figure><h3 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210821101501463.png" alt="image-20210821101501463"></p><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>问题；在买票过程中，出现重票、错票。就会导致线程安全问题</p><h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h3><p>String：字符串，使用一对””引起来表示。</p><ol><li><p>String声明为final的，不可被继承</p></li><li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p></li><li><p>String内部定义了final char[] value用于存储字符串数据</p></li><li><p>String:代表不可变的字符序列。简称：不可变性。<br>体现：</p><p>1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p><ol start="2"><li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li><li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 </li></ol></li><li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p></li><li><p>字符串常量池中是不会存储相同内容的字符串的。</p></li></ol><p>String的实例化方式：<br>    方式一：通过字面量定义的方式<br>    方式二：通过new + 构造器的方式</p><p><strong>面试题</strong>：String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？<br>            两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210830132449790.png" alt="image-20210830132449790"></p><p>关字符串的拼接：</p><ol><li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li><li>只要其中有一个是变量，结果就在堆中。</li><li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li></ol><p><strong>字符串相关的方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== <span class="number">0</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">替换：</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">匹配:</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="function">切片：</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br></pre></td></tr></table></figure><p><strong>String 与基本数据类型、包装类之间的转换。</strong></p><p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p><p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p><p><strong>String 与 char[]之间的转换</strong></p><p>String –&gt; char[]:调用String的toCharArray()</p><p>char[] –&gt; String:调用String的构造器</p><p><strong>String 与 byte[]之间的转换</strong></p><p>编码：String –&gt; byte[]:调用String的getBytes()</p><p>解码：byte[] –&gt; String:调用String的构造器</p><p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</p><p>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</p><p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p><p><strong>String、StringBuffer、StringBuilder三者的异同？</strong></p><p>String:不可变的字符序列；相同点：底层使用char[]存储</p><p>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</p><p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的常用方法：</span><br><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>：提供了很多的<span class="title">append</span><span class="params">()</span>方法，用于进行字符串拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>：删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>：把[start,end)位置替换为str</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>：在指定位置插入xxx</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">总结：</span></span><br><span class="line"><span class="function">增：<span class="title">append</span><span class="params">(xxx)</span></span></span><br><span class="line"><span class="function">删：<span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">改：<span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span> / <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span></span><br><span class="line"><span class="function">查：<span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">插：<span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span></span></span><br><span class="line"><span class="function">长度：<span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">遍历：<span class="keyword">for</span>() + charAt() / toString()</span><br></pre></td></tr></table></figure><h3 id="时间日期API"><a href="#时间日期API" class="headerlink" title="时间日期API"></a>时间日期API</h3><p>（未学）</p><h2 id="枚举类与新注解"><a href="#枚举类与新注解" class="headerlink" title="枚举类与新注解"></a>枚举类与新注解</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>一、枚举类的使用</p><p>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p><p>2.当需要定义一组常量时，强烈建议使用枚举类</p><p>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</p><p>二、如何定义枚举类</p><p>方式一：jdk5.0之前，自定义枚举类</p><p>方式二：jdk5.0，可以使用<strong>enum</strong>关键字定义枚举类</p><p>三、Enum类中的常用方法：</p><p>**values()**方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p><p>**valueOf(String str)**：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p><p>**toString()**：返回当前枚举类对象常量的名称</p><p>四、使用enum关键字定义的枚举类实现接口的情况</p><p>情况一：实现接口，在enum类中实现抽象方法</p><p>情况二：让枚举类的对象分别实现接口中的抽象方法</p><h3 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h3><ol><li>注解的使用</li></ol><p>理解Annotation:</p><p>① jdk 5.0 新增的功能</p><p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</p><p>通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p><p>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p><ol start="2"><li>Annocation的使用示例</li></ol><p>示例一：生成文档相关的注解</p><p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p><p>@Override: 限定重写父类方法, 该注解只能用于方法</p><p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p><p>@SuppressWarnings: 抑制编译器警告</p><p>示例三：跟踪代码依赖性，实现替代配置文件功能</p><ol start="3"><li>如何自定义注解：参照@SuppressWarnings定义</li></ol><p>① 注解声明为：@interface</p><p>② 内部定义成员，通常使用value表示</p><p>③ 可以指定成员的默认值，使用default定义</p><p>④ 如果自定义注解没有成员，表明是一个标识作用。</p><p>如果注解有成员，在使用注解时，需要指明成员的值，但是有默认值就不需要指定了 。自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</p><p><strong>自定义注解通过都会指明两个元注解：Retention、Target</strong></p><ol start="4"><li>jdk 提供的4种元注解 （元注解就是修饰其他注解的注解）（顺便说一下元数据，对现有数据的进行修饰的数据）</li></ol><p>元注解：对现有的注解进行解释说明的注解</p><p><strong>Retention：</strong>指定所修饰的 Annotation 的生命周期：<strong>SOURCE、CLASS（默认行为）、RUNTIME</strong>，只有声明为</p><p>RUNTIME生命周期的注解，才能通过反射获取。</p><p><strong>Target：</strong>用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p><p><strong>Documented：</strong>表示所修饰的注解在被javadoc解析时，保留下来。</p><p><strong>Inherited：</strong>被它修饰的 Annotation 将具有继承性。</p><ol start="5"><li><p>通过反射获取注解信息 —到反射内容时在讲解</p><ol start="6"><li>jdk 8 中注解的新特性：可重复注解、类型注解</li></ol><p>6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p><pre><code>         ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</code></pre><p>6.2 类型注解：<br>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。<br>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p></li></ol><h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>一、集合框架的概述</p><p>1.集合、数组都是对多个数据进行存储（针对内存层面）操作的结构，简称 Java容器。</p><p>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</p><p>2.1 数组在存储多个数据方面的特点：</p><ul><li><p>一旦初始化以后，其长度就确定了。（长度确定）</p></li><li><p>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。（类型确定）</p><ul><li>比如：String[] arr;int[] arr1;Object[] arr2;</li></ul></li></ul><p>2.2 数组在存储多个数据方面的缺点：</p><ul><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 </li></ul><p>二、集合框架 （两个接口 Collection 和 Map，两个并列）</p><ul><li><p>Collection接口：单列集合，用来存储一个一个的对象</p><ul><li>List接口：存储有序的、可重复的数据。  –&gt;“动态”数组<ul><li>ArrayList、LinkedList、Vector （主要实现类）</li></ul></li><li>Set接口：存储无序的、不可重复的数据   –&gt;像高中讲的“集合”<ul><li>HashSet、LinkedHashSet、TreeSet</li></ul></li></ul></li><li><p>Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y = f(x)，不同的key可以指向</p><p> 同一个value</p><ul><li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List接口框架</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">    |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span><br><span class="line">        |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">        |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">        |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure><p><strong>面试题：ArrayList、LinkedList、Vector 三者的异同</strong></p><p>相同点：三个类都实现了List接口，存储数据的特点相同，存储有序的、可重复的数据。</p><p>不同点：见上面👆</p><p><strong>ArrayList的源码分析：</strong>这里分为jdk7和jdk8</p><p>jdk 7情况下：</p><ul><li>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</li><li>list.add(123);//elementData[0] = new Integer(123);</li><li>…</li><li>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</li><li>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</li></ul><p>jdk 8中ArrayList的变化：</p><ul><li>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</li><li>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</li><li>…</li><li>后续的添加和扩容操作与jdk 7 无异。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span><br></pre></td></tr></table></figure><p><strong>LinkedList的源码分析：</strong></p><p>LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p><ul><li>list.add(123);//将123封装到Node中，创建了Node对象。</li></ul><p><strong>Vector的源码分析：</strong>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p><ul><li>在扩容方面，默认扩容为原来的数组长度的2倍。（不重要）</li></ul><p>set接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set接口的框架：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">          |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span><br><span class="line">          |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">          |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure><h3 id="Map的实现类的结构："><a href="#Map的实现类的结构：" class="headerlink" title="Map的实现类的结构："></a>Map的实现类的结构：</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220102223958792.png" alt="image-20220102223958792"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y &#x3D; f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。</span><br><span class="line">               原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">               对于频繁的遍历操作，此类执行效率高于HashMap，可以使用LinkedHashMap</span><br><span class="line">     |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树。</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap的底层：数组+链表  （jdk7及之前）</span><br><span class="line">              数组+链表+红黑树 （jdk 8）</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line">1. HashMap的底层实现原理？</span><br><span class="line">2. HashMap 和 Hashtable的异同？</span><br><span class="line">3. CurrentHashMap 与 Hashtable的异同？（暂时不学）</span><br></pre></td></tr></table></figure><p>Map结构的理解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</span><br><span class="line">Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()，</span><br><span class="line"></span><br><span class="line">一个键值对：key-value构成了一个Entry对象。</span><br><span class="line">Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span><br></pre></td></tr></table></figure><p>三、HashMap的底层实现原理？以jdk7为例说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashMap map &#x3D; new HashMap():</span><br><span class="line">在实例化以后，底层创建了长度是16的一维数组Entry[] 名字叫table。</span><br><span class="line">      ...然后可能已经执行过多次put...</span><br><span class="line">      map.put(key1,value1):</span><br><span class="line">      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span><br><span class="line">      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span><br><span class="line">      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">      如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span><br><span class="line">      如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span><br><span class="line">      如果equals()返回false:此时key1-value1添加成功。----情况3</span><br><span class="line">      如果equals()返回true:使用value1替换value2。说明此时的put方法有修改的功能了。</span><br><span class="line"></span><br><span class="line">补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span><br><span class="line"></span><br><span class="line">      在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jdk8 相较于jdk7在底层实现方面的不同：</span><br><span class="line">1. new HashMap():底层没有创建一个长度为16的数组</span><br><span class="line">2. jdk 8底层的数组是：Node[],而非jdk7里面的Entry[]</span><br><span class="line">3. 首次调用put()方法时，底层创建长度为16的数组 </span><br><span class="line">4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span><br><span class="line">  4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span><br><span class="line">  4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span><br><span class="line">    DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</span><br><span class="line">    DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</span><br><span class="line">    threshold：扩容的临界值，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</span><br><span class="line">    TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</span><br><span class="line">    MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型的使用</p><p>1.jdk 5.0新增的特性</p><p>2.在集合中使用泛型：</p><p>总结：</p><p>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p><p>② 在实例化集合类时，可以指明具体的泛型类型</p><p>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p><p>比如：add(E e)  —&gt;实例化以后：add(Integer e)</p><p>④ 注意点：<strong>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</strong></p><p>⑤ 如果实例化时，没有指明泛型的类型。<strong>默认类型为java.lang.Object类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();<span class="comment">//jdk5新特性    </span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//jdk7新特性：类型推断</span></span><br></pre></td></tr></table></figure><p>ORM（对象关系映射），数据库中的一张表对应一个java类，体现的是万事万物皆对象。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法：在方法中出现了泛型结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型都无所谓。</p><p>泛型方法可以声明为是静态的，只要在调用的时候指明是什么类型的就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//这是错误的写法，</span></span><br><span class="line">  <span class="comment">//这不是泛型方法，编译器会误认为是不是还有一个类叫做 E</span></span><br><span class="line">  <span class="comment">//E 与上面的 T 没有关系，并且</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> list&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E&lt;&gt; arr)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//正确的方法，如果是要声明泛型方法，需要在 public 和 List&lt;E&gt; 之间，写好&lt;E&gt;,这才是泛型方法。</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E&lt;&gt; arr)</span></span>&#123; </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//静态泛型方法,其中 list&lt;E&gt; 是返回类型。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">copyFromArrayToList_1</span><span class="params">(E&lt;&gt; arr)</span></span>&#123; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;();</span><br><span class="line">  Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="1-流的分类"><a href="#1-流的分类" class="headerlink" title="1. 流的分类"></a>1. 流的分类</h3><p>按照数据单位不同分为：<strong>字节流和字符流</strong></p><p>按照数据流的流向分为：<strong>输入流和输出流</strong></p><p>按照流的角色分为：<strong>节点流和处理流</strong></p><p>节点流：直接作用在文件上</p><p>处理流：是在节点流的基础上进行包裹的流。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210906192257236.png" alt="image-20210906192257236"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</span><br><span class="line">2. 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...)，使用字节流处理</span><br></pre></td></tr></table></figure><p>但是：如果是文本文件，只是想复制一下，使用字节流也行，但是不要读出来，但是即使是复制，去处理非文本文件，也不能使用字符流。</p><p>缓冲流：是处理流的一种，主要是为了提高速度。</p><p>对象流：不仅可以存储基本数据类型数据，还可以把对象写入到数据源中，也可以把对象从数据源中还原回来</p><p><strong>序列化：</strong>用ObjectOutputStream类保存基本类型数据或对象的机制</p><p><strong>反序列化：</strong>用ObjectInputStream类读取基本类型数据或对象的机制</p><p>举例：自己写的一个类Person</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person需要满足如下的要求，方可序列化</span><br><span class="line">1.需要实现接口：Serializable</span><br><span class="line">2.当前类提供一个全局常量：serialVersionUID</span><br><span class="line">3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</span><br></pre></td></tr></table></figure><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>此部分主要是了解网络编程，详细见代码</p><h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><p>复习反射需要的材料（反射一节的ppt、反射代码、和此笔记）</p><p>本节主要的是<strong>获取Class实例，创建运行时类的对象、调用运行时类的结构</strong></p><h3 id="1-Java反射机制概述"><a href="#1-Java反射机制概述" class="headerlink" title="1. Java反射机制概述"></a>1. Java反射机制概述</h3><h4 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h4><p>​        反射是被视为<strong>动态语言</strong>的关键，是因为 Java 文件要进行两个阶段的“洗礼”，第一个编译阶段是生成  .java 文件编译为 .class 文件，此时还不能确定某一类的对象，只有在运行时才能确定是哪个。体现了动态性。反射可以获取对象的任何信息。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201124193827032.png" alt="image-20201124193827032"></p><p>反射的意思就是 通过类的对象，能了解到类的信息。就是反射。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201127142743534.png" alt="image-20201127142743534"></p><h4 id="动态语言-与-静态语言"><a href="#动态语言-与-静态语言" class="headerlink" title="动态语言 与 静态语言"></a>动态语言 与 静态语言</h4><p><strong>动态语言</strong>：在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构。</strong> </p><p><strong>静态语言</strong>：运行时结构不可改变，如Java、C、 C++。</p><p>虽然Java不是动态语言，但是Java可以成为“<strong>准动态语言</strong>”，也就是说它有动态性，可以利用反射的机制来体现。</p><h4 id="Java反射机制研究与应用"><a href="#Java反射机制研究与应用" class="headerlink" title="Java反射机制研究与应用"></a>Java反射机制研究与应用</h4><p>反射可以干什么？</p><ul><li>在运行时判断任意一个对象所属的类 </li><li>在运行时构造任意一个类的对象 </li><li>在运行时判断任意一个类所具有的成员变量和方法 </li><li>在运行时获取泛型信息 </li><li>在运行时调用任意一个对象的成员变量和方法 </li><li>在运行时处理注解 </li><li>生成动态代理</li></ul><p>总之一句话：就是可以获取类的任何信息。</p><p>关于反射相关的API</p><ul><li>java.lang.Class:代表一个类，（一个类也是一个类）</li><li>java.lang.reflect.Method:代表类的方法</li><li>java.lang.reflect.Field:代表类的成员变量</li><li>java.lang.reflect.Constructor:代表类的构造器</li></ul><h3 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2. 理解Class类并获取Class实例"></a>2. 理解Class类并获取Class实例</h3><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>Class是用来描述类的类，比如每个类都有属性，都有方法等等，所以又抽象出一个类。Class类是反射的源头。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201127144332468.png" alt="image-20201127144332468" style="zoom: 80%;" /><p>因为 Object 类是所有类的父类，要想得到每个类的信息，getClass()方法就声明在了 Object 类中。</p><p>​        对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构的有关信息。</p><ul><li>Class 本身也是一个类 </li><li>Class 对象只能由系统建立对象 </li><li>一个加载的类在 JVM 中只会有一个 Class 实例 </li><li>一个Class对象对应的是一个加载到 JVM 中的一个 .class 文件 </li><li>每个类的实例都会记得自己是由哪个 Class 实例所生成 </li><li>通过 Class 可以完整地得到一个类中的所有被加载的结构 </li><li>Class 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对</li></ul><h4 id="获取Class类的实例-（四种方法）"><a href="#获取Class类的实例-（四种方法）" class="headerlink" title="获取Class类的实例 （四种方法）"></a>获取Class类的实例 （四种方法）</h4><p>获取Class类的实例的四种方法，其中前三种方法比较重要，经常用到，最后一种不需要掌握。</p><p> 方式一：调用运行时类的属性：.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br></pre></td></tr></table></figure><p>方式二：通过运行时类的对象,调用getClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(); <span class="comment">// 此时Person类为运行时类</span></span><br><span class="line">Class clazz2 = p1.getClass();<span class="comment">//.getclass 是在object里面造的</span></span><br><span class="line">System.out.println(clazz2);</span><br></pre></td></tr></table></figure><p>方式三：调用Class的 静态方法 ：forName(String classPath)。这里必须写 类的全类名，因为同一个module下可能有多个person（使用的比较多）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz3+<span class="string">&quot;打印3&quot;</span>);</span><br></pre></td></tr></table></figure><p>方式四：使用类的加载器：ClassLoader  (了解)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz4);</span><br></pre></td></tr></table></figure><h3 id="3-类的加载-与ClassLoader的理解（了解）"><a href="#3-类的加载-与ClassLoader的理解（了解）" class="headerlink" title="3. 类的加载 与ClassLoader的理解（了解）"></a>3. 类的加载 与ClassLoader的理解（了解）</h3><h4 id="类的加载过程-（了解）"><a href="#类的加载过程-（了解）" class="headerlink" title="类的加载过程 （了解）"></a>类的加载过程 （了解）</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201127152144541.png" alt="image-20201127152144541"></p><ul><li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</li><li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul><li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 </li><li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。 </li><li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li></ul></li><li>初始化<ul><li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li><li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。</li><li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li></ul></li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201125121333135.png" alt="image-20201125121333135"></p><h4 id="类加载器的作用："><a href="#类加载器的作用：" class="headerlink" title="类加载器的作用："></a>类加载器的作用：</h4><ul><li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 </li><li>类缓存：标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些Class对象。</li></ul><h4 id="类的加载器的种类："><a href="#类的加载器的种类：" class="headerlink" title="类的加载器的种类："></a>类的加载器的种类：</h4><p>引导类加载器、扩展类加载器、系统类加载器</p><ul><li>引导类加载器：是C、C++编写的，是JVM自带的加载器，<strong>主要负责Java平台核心库</strong>，用来加载核心类库。</li><li>扩展类加载器：负责jre/lib/ext目录下的jar包或指定目录下的jar包</li><li>系统类加载器：自己定义的类都是有系统类加载器进行加载</li></ul><h3 id="4-创建运行时类对象（重点）"><a href="#4-创建运行时类对象（重点）" class="headerlink" title="4. 创建运行时类对象（重点）"></a>4. 创建运行时类对象（重点）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象 </span></span><br><span class="line">String name = <span class="string">&quot;atguigu.java.Person&quot;</span>; </span><br><span class="line">Class clazz = <span class="keyword">null</span>; </span><br><span class="line">clazz = Class.forName(name); </span><br><span class="line"><span class="comment">//2.调用指定参数结构的构造器，生成Constructor的实例 </span></span><br><span class="line">Constructor con = clazz.getConstructor(String.class,Integer.class); </span><br><span class="line"><span class="comment">//3.通过Constructor的实例创建对应类的对象，并初始化类属性 </span></span><br><span class="line">Person p2 = (Person) con.newInstance(<span class="string">&quot;Peter&quot;</span>,<span class="number">20</span>); </span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure><h3 id="5-获取运行时类的完整结构"><a href="#5-获取运行时类的完整结构" class="headerlink" title="5. 获取运行时类的完整结构"></a>5. 获取运行时类的完整结构</h3><p>具体内容在代码中体现。</p><h3 id="6-调用运行时类的指定结构"><a href="#6-调用运行时类的指定结构" class="headerlink" title="6. 调用运行时类的指定结构"></a>6. 调用运行时类的指定结构</h3><p>主要是调用运行时类中指定的结构：属性、方法、构造器。</p><p>具体内容在代码中体现。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="2021/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>2021/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<center>如果人生尽是坦途，那么梦想何处安放！</center><a id="more"></a><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p>双重检查单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//https://juejin.cn/post/6844903772892692487</span></span><br><span class="line">  <span class="comment">// 1. 定义变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 私有构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">// 3. 得到单例的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 判断是不是被初始化了</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">          <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">                <span class="comment">// 再次判断是不是被初始化了</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类加载到内存中，static 保证只加载一次， 线程安全的。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 构造器被私有化,让别人没办法调用</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. getInstance() 只能到的一个实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁的方式来解决方式三存在的问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习笔记</title>
      <link href="2021/02/18/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/18/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 面试整理</title>
      <link href="2021/02/18/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
      <url>2021/02/18/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h3 id="1-java-中对象比较的三种方式"><a href="#1-java-中对象比较的三种方式" class="headerlink" title="1. java 中对象比较的三种方式"></a>1. java 中对象比较的三种方式</h3><ol><li>== 和 equals() 方法</li><li>hashCode() 方法和 equals() 方法</li><li>Comparable 接口和 Comparator 接口</li></ol><ul><li>== 和 equals() 方法（已经整理）</li></ul><p>不重写就是比较的对象的地址值是不是一样的，自己写的类一般都重写 equals() 方法。</p><ul><li>hashCode() 方法和 equals() 方法</li></ul><p>之所以重写hashCode() 方法就是为了使对象里面的相同的内容产生相同的 hash 值，然后在对象进行比较的时候 hash 值一样。</p><p>实现 Comparable 接口，然后重写compareTo() 方法。</p><ul><li>Comparable 接口和 Comparator 接口<ul><li>Comparable 接口需要重写 compareTo() 方法</li><li>Comparator接口</li></ul></li></ul><p>参考：<a href="https://www.cnblogs.com/myworld7/p/10050947.html#_label1">https://www.cnblogs.com/myworld7/p/10050947.html#_label1</a></p><h3 id="2-HashCode-的作用"><a href="#2-HashCode-的作用" class="headerlink" title="2.  HashCode 的作用"></a>2.  HashCode 的作用</h3><p>（1）HashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，HashCode经常用于确定对象的存储地址；</p><p>（2）如果两个对象相同， equals方法一定返回true，并且这两个对象的HashCode一定相同；</p><p>（3）两个对象的HashCode相同，并不一定表示两个对象就相同，即equals()不一定为true，只能说明这两个对象在一个散列存储结构中。</p><p>（4）如果对象的equals方法被重写，那么对象的HashCode也尽量重写。</p><p>在集合中，当要添加元素时，没使用 HashCode 之前，需要进行很多次 equals() 方法，会降低效率，但是我们使用 HashCode() 的时候，我们就能一下子确定插入的位置。即使相同的 Hash 值，也能调用有限次 equals() 方法进行比较。</p><p>参考：<a href="https://blog.csdn.net/SEU_Calvin/article/details/52094115">https://blog.csdn.net/SEU_Calvin/article/details/52094115</a></p><h3 id="3-Java-中获取键盘输入值的三种方法"><a href="#3-Java-中获取键盘输入值的三种方法" class="headerlink" title="3. Java 中获取键盘输入值的三种方法"></a>3. Java 中获取键盘输入值的三种方法</h3><ul><li>从控制台中接收一个字符，然后将其打印出来。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">       System.out.print(<span class="string">&quot;Enter a Char:&quot;</span>); </span><br><span class="line">        <span class="keyword">char</span> i = (<span class="keyword">char</span>) System.in.read(); </span><br><span class="line">       System.out.println(<span class="string">&quot;your char is :&quot;</span>+i); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>只能针对一个字符进行获取，获取进来的变量只能是 char，如果是一个数字，我们需要得到一个整型变量的时候，只能再次进行转换。</p><ul><li>从控制台接收一个字符串，然后将其打印出来。我们需要用到 BufferedReader 类和 InputStreamReader 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IOException</span>&#123; </span><br><span class="line">         BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in)); </span><br><span class="line">         String str = <span class="keyword">null</span>; </span><br><span class="line">         System.out.println(<span class="string">&quot;Enter your value:&quot;</span>); </span><br><span class="line">         str = br.readLine(); </span><br><span class="line">         System.out.println(<span class="string">&quot;your value is :&quot;</span>+str); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 Scanner 类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123; </span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in); </span><br><span class="line">       System.out.println(<span class="string">&quot;请输入你的姓名：&quot;</span>); </span><br><span class="line">        String name = sc.nextLine(); </span><br><span class="line">       System.out.println(<span class="string">&quot;请输入你的年龄：&quot;</span>); </span><br><span class="line">        <span class="keyword">int</span> age = sc.nextInt(); </span><br><span class="line">       System.out.println(<span class="string">&quot;请输入你的工资：&quot;</span>); </span><br><span class="line">        <span class="keyword">float</span> salary = sc.nextFloat(); </span><br><span class="line">       System.out.println(<span class="string">&quot;你的信息如下：&quot;</span>); </span><br><span class="line">       System.out.println(<span class="string">&quot;姓名：&quot;</span>+name+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;年龄：&quot;</span>+age+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;工资：&quot;</span>+salary); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="http://blog.sina.com.cn/s/blog_93dc666c0101h00f.html">http://blog.sina.com.cn/s/blog_93dc666c0101h00f.html</a></p><h3 id="4-Java中有哪几种类型的流"><a href="#4-Java中有哪几种类型的流" class="headerlink" title="4. Java中有哪几种类型的流"></a>4. Java中有哪几种类型的流</h3><p>按照数据单位不同分为：<strong>字节流和字符流</strong></p><p>按照数据流的流向分为：<strong>输入流和输出流</strong></p><p>按照流的角色分为：<strong>节点流和处理流</strong></p><p>节点流：直接作用在文件上。</p><p>处理流：是在节点流的基础上进行包裹的流。</p><p>字节流继承于 InputStream 和 OutStream，字符流继承于 Reader 和 Writer。</p><h3 id="5-字节流和字符流的区别？"><a href="#5-字节流和字符流的区别？" class="headerlink" title="5. 字节流和字符流的区别？"></a>5. 字节流和字符流的区别？</h3><p>参考：<a href="https://www.zhihu.com/question/39262026">https://www.zhihu.com/question/39262026</a></p><ol><li>字节流操作的基本单位是字节，而字符流操作的基本单位是 Unicode码元。</li><li>字节流不需要使用缓冲区，字符流需要使用缓冲区。</li><li>字节流可以处理二进制数据，也就是可以处理任意类型的数据。而字符流通常处理文本类型的数据。</li></ol><h3 id="6-String、StringBuffer、和StringBuilder-的区别？"><a href="#6-String、StringBuffer、和StringBuilder-的区别？" class="headerlink" title="6. String、StringBuffer、和StringBuilder 的区别？"></a>6. String、StringBuffer、和StringBuilder 的区别？</h3><p>参考链接：<a href="https://blog.csdn.net/mad1989/article/details/26389541">https://blog.csdn.net/mad1989/article/details/26389541</a></p><h3 id="7-接口和抽象类的区别？"><a href="#7-接口和抽象类的区别？" class="headerlink" title="7. 接口和抽象类的区别？"></a>7. 接口和抽象类的区别？</h3><p><strong>设计目的不同：</strong></p><p>接口的设计目的是一种模版设计，是一种行为规范，凡事实现接口的类，都要实现它的方法，是一种行为抽象。</p><p>抽象类的设计目的是为了复用代码，抽象类是对现实事物的抽象，记录通用特性的。</p><p><strong>实现不同：</strong></p><p>实现接口就要实现它的所有方法。</p><p>继承抽象类上面没有类似的要求。如果提供部分方法的实现，那么这个子类依旧是抽象类，如果全部实现，那这个类就不是抽象类了。</p><p><strong>构造器：</strong></p><p>接口不可以有构造器。</p><p>抽象类可以拥有构造器。</p><p>注意⚠️：Java 8中接口引入了默认方法和静态方法。子类可以不去实现默认方法。</p><p><strong>选择</strong>：如果是定义一组行为模型，那我们优先选择接口，如果是某一种事物的抽象，我们选用抽象类。</p><p><strong>相同点：</strong></p><p>接口和抽象类都不能实例化</p><p>他们都位于继承的顶端，用于实现或者继承。</p><p>都包涵抽象方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 容器</title>
      <link href="2021/02/18/Java%E9%9B%86%E5%90%88/"/>
      <url>2021/02/18/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20220302160454294.png" alt="image-20220302160454294" style="zoom:50%;" /><a id="more"></a><p>集合主要有两个接口：Collection 和 Map。Collection接口下有两个字接口 List 子接口和 Set子接口。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220105213540811.png" alt="image-20220105213540811"></p><p>Map接口：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20220102223958792-20220325205334795.png" alt="image-20220102223958792"></p><h3 id="List、Set、Map-的区别？"><a href="#List、Set、Map-的区别？" class="headerlink" title="List、Set、Map 的区别？"></a>List、Set、Map 的区别？</h3><p>List 可以存放有序、可重复的数据。也称为“动态数组”（这里的有序指的是存放顺序从索引0开始存放）</p><p>Set 可以存放无序、不可重复的数据。（类似于高中的集合）</p><p>Map 是双列集合，用来存储一对（key- value） 的数据，key值是唯一的。用Set存。key是无序的，不可重复的数据，value存放的是无序的，可重复的数据。</p><h3 id="ArrayList-和-LinkedList-的区别？"><a href="#ArrayList-和-LinkedList-的区别？" class="headerlink" title="ArrayList 和 LinkedList 的区别？"></a>ArrayList 和 LinkedList 的区别？</h3><ul><li>底层数据结构</li></ul><p>ArrayList 底层使用的是Object[] elementData 数组存储的，而 LinkedList 底层是用<strong>双向链表</strong>存储的( JDK 1.6 之前是循环链表，1.7取消了循环链表)。</p><ul><li>插入和删除受元素位置的影响</li></ul><p>ArrayList是用数组存储的，如果是执行add( E ,e)这时候就是在最后面插入，时间为O(1)，如果是在中间插入元素，执行add(int index, E element) 的时间复杂度就在O(n-i),因为在插入i的位置之后的元素，即第n-i个元素都需要进行移动。</p><p>LinkedList采用的是链表的存储的，插入，删除的时间复杂度为O(1)</p><ul><li>是否支持快速随机访问（也就是查找速度看谁快）</li></ul><p>ArrayList 支持快速随机访问，而LinkedList不支持快速随机访问</p><ul><li>占用内存空间</li></ul><p>ArrayList 的空间浪费主要是在 list 列表结尾会有一部分空间预留</p><p>LinkedList 空间花费在每一个元素都比 ArrayList 元素更多的空间（因为要存放前驱和后继的数据）</p><h3 id="ArrayList-和-Vector-的区别？-为什么Vector-被代替？"><a href="#ArrayList-和-Vector-的区别？-为什么Vector-被代替？" class="headerlink" title="ArrayList 和 Vector 的区别？ 为什么Vector 被代替？"></a>ArrayList 和 Vector 的区别？ 为什么Vector 被代替？</h3><ul><li>ArrayList 是线程不安全的，效率高，而 Vector 是线程安全的，效率低。</li><li>ArrayList 扩容的时候是扩容1.5倍，而 Vector 扩容的时候是2倍</li></ul><p>因为 Vector 类中所有的方法都是同步的(线程安全的)，所以系统开销比较大。</p><h3 id="ArrayList-的扩容机制"><a href="#ArrayList-的扩容机制" class="headerlink" title="ArrayList 的扩容机制"></a>ArrayList 的扩容机制</h3><p>jdk 7 情况下</p><ul><li>ArrayList list = new ArrayList()；//底层创建了长度是 <strong>10</strong> 的 Object[] 数组 elementData</li></ul><ul><li>list.add(123)；//elementData[0] = new Integer(123);</li><li>…</li><li>list.add(11)；//如果此次的添加导致底层 elementData 数组容量不够，则扩容。</li><li>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</li></ul><p>jdk 8 中ArrayList的变化：</p><ul><li>ArrayList list = new ArrayList(); //底层 Object[] elementData 初始化为 {} .并没有创建长度为 10 的数组</li><li>list.add(123); //第一次调用 add() 时，底层才创建了长度 10 的数组，并将数据 123 添加到 elementData[0]</li><li>…</li><li>后续的添加和扩容操作与jdk 7 无异。<br>小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</li></ul><h3 id="HashMap-底层的实现原理？"><a href="#HashMap-底层的实现原理？" class="headerlink" title="HashMap 底层的实现原理？"></a>HashMap 底层的实现原理？</h3><ol><li><p>创建 HashMap map = new HashMap() 对象</p></li><li><p>实例化后，底层创建了一个长度 <strong>16</strong> 的数组。</p></li><li><p>…可能在放元素之前，已经放了好多次了… 然后我们在放元素 map.put(key1,value1)</p></li><li><p>首先，调用 key1 所在的类计算 hashcode() 计算 key1 的哈希值，此哈希值经过某种计算后，得到在Entry数组中存放的位置。</p></li><li><p>如果此位置上数据为空，那么直接存放该数据 ———–<strong>情况1</strong>。</p><p>如果此位置上数据不为空(那就是说此位置上有一个或多个数据(多个数据则是以链表的形式存在))，则比较和已经存在的一个或者多个数据的哈希值：</p><ul><li><p>如果key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1 - value1添加成功。——-<strong>情况2</strong></p></li><li><p>如果key1 的哈希值与已经存在的数据的哈希值有相同的，则继续比较：调用key1所在类的equals(key1)方法，比较：</p><ul><li>如果 equals() 返回false；此时 key1 - value1 添加成功  ——-<strong>情况3</strong></li><li>如果 equals() 返回true；那么此时 value1 的值会代替之前的旧值。</li></ul></li></ul></li></ol><h3 id="HashMap-底层数组为什么要保证是-2-的-n-次方？"><a href="#HashMap-底层数组为什么要保证是-2-的-n-次方？" class="headerlink" title="HashMap 底层数组为什么要保证是 2 的 n 次方？"></a>HashMap 底层数组为什么要保证是 2 的 n 次方？</h3><p>​    因为在计算要存放的 hash 值后，会与数组的长度 -1 进行一次<strong>与运算</strong>，如果数组是2的倍数（也就是2的n次方），那么长度length-1 的二进制一定是 ….000001111这样的格式，后面全是1，那么在进行与运算的时候，结果一定是在原来的数组的大小范围之内（即0-15之内），假如不是2的倍数，那么length-1 的二进制值后面可能就不可能全是1，做运算的时候可能就有空间不管怎么计算都落不到，就会导致空间的浪费。</p><h3 id="HashMap-和-Hashtable-的区别？"><a href="#HashMap-和-Hashtable-的区别？" class="headerlink" title="HashMap 和 Hashtable 的区别？"></a>HashMap 和 Hashtable 的区别？</h3><ul><li>线程是否安全</li></ul><p>HashMap 线程不安全、Hashtable 是线程安全，Hashtable 内部都是 synchronized 的，如果是要保证线程安全，就用ConcurrenthashMap</p><ul><li>效率</li></ul><p>因为线程不安全，所以 HashMap 效率高点，Hashtable 效率低，一般都不使用了。</p><ul><li>Null key 和 Null value</li></ul><p>HashMap 支持 null 作为键，但是只能有一个，值也可以为 null，可以有多个。</p><p>Hashtable 键是不能作为 null 的。</p><ul><li>初始化容量大小和每次扩容的大小不同</li></ul><p>HashMap 默认初始化是 16 ，每次扩容为原来的<strong>两倍</strong>。Hashtable默认初始化 <strong>11</strong>。每次扩容为原来的 2n+1。</p><p>如果初始化都指定来一个初始化值，那么 HashMap 都会扩充为 2 的幂次方大小。而Hashtable则就是使用指定的大小进行初始化。</p><ul><li>底层数据结构</li></ul><p>HashMap 在1.8以后当链表的长度大于 8 且数组的长度大于 64 的时候，这时候链表会转化为红黑树，而 Hashtable 没有这种机制。</p><h3 id="HashMap-和-HashSet-的区别"><a href="#HashMap-和-HashSet-的区别" class="headerlink" title="HashMap 和 HashSet 的区别"></a>HashMap 和 HashSet 的区别</h3><p>HashSet 底层是基于 HashMap 实现的，所以一般很少问到 HashSet 的底层数据结构。</p><p>HashMap 实现了Map接口，而 HashSet 实现了 Set 接口。</p><p>HashMap 存储的是键值对，HashSet 存储的是对象。</p><p>HashMap 使用的是 key 进行计算 hashcode，HashSet 使用成员对象计算 hashcode。</p><h3 id="HashSet-如何检查重复？"><a href="#HashSet-如何检查重复？" class="headerlink" title="HashSet 如何检查重复？"></a>HashSet 如何检查重复？</h3><p>当把对象加入到 HashSet 的时候，首先会计算该对象的 hashcode 值，来判断该对象的位置，同时和其他已经存在的进行值比较，如果该位置为空(对应位置没有元素)，那么就认为对象没有重复，它就是唯一的(嗯，我就是唯一的)，那就可以放进去了，但是，如果比较相同，那就会调用 equal() 方法再来比较 (因为不同的对象可有可能出现相同的 hashcode 值)，看是否真的相同，如果相同就添加成功，不相同那就算了。</p><h3 id="hashCode-与-equals-的相关规定"><a href="#hashCode-与-equals-的相关规定" class="headerlink" title="hashCode() 与 equals() 的相关规定"></a>hashCode() 与 equals() 的相关规定</h3><ol><li>如果两个对象相同，那么hashcode 一定相同。</li><li>如果两个对象相同，那么 equals 方法返回 true。</li><li>hashcode 相同的两个对象，也可能不相等。</li></ol><p>所以：equals() 方法被覆盖重写，那么 hashCode() 方法一定要重写。如果不重写，就是使用默认的 hashCode() 方法，默认的 hashCode() 方法对里面的对象产生不同的值。那么该 class 的两个对象无论如何都不会相等，即使这两个对象指向相同的数据，也会产生不同的值。 </p><h3 id="与-equal-的区别？"><a href="#与-equal-的区别？" class="headerlink" title="== 与 equal() 的区别？"></a>== 与 equal() 的区别？</h3><ol><li><p>== 一般比较的是值是否相等</p><ul><li><p>如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</p></li><li><p>如果作用于引用类型的变量，则比较的是所指向的对象的地址。</p></li></ul></li><li><p>对于equals方法，一般为比较内容是否相同。</p><ul><li>如果没有对 equals 方法进行重写，则比较的是引用类型的变量所指向的对象的地址。</li><li>诸如 String、Date 等类对 equals 方法进行了重写的话，比较的是所指向的对象的内容。</li></ul></li></ol><h3 id="ConcurrentHashMap-和-Hashtable-的区别？"><a href="#ConcurrentHashMap-和-Hashtable-的区别？" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别？"></a>ConcurrentHashMap 和 Hashtable 的区别？</h3><p>参考链接：<a href="https://raymond-zhao.top/2020/07/08/2020-07-08-Java-HashMap/">https://raymond-zhao.top/2020/07/08/2020-07-08-Java-HashMap/</a></p><ul><li>线程安全的方式</li></ul><p>Hashtable: 采用的是 synchronized 进行锁定，锁住的是一整个表，效率比较低。</p><p>ConcurrentHashMap: 在 jdk 7 内部包含一个 Segment 数组，一个 Segment 就类似于 Hashtable 结构，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，当进行锁定的时候，会获取对应的 Segment 的锁，不会获取一整个表的锁。这样就支持多线程同时访问，提高了效率。在 jdk1.8 的时候采用的是 <strong>CAS + synchronized</strong> 的方式。</p><ul><li>底层数据结构</li></ul><p>Hashtable 采用的是<strong>数组+链表</strong>的形式</p><p>ConcurrentHashMap 在 jdk 7 的是由 <strong>Segment 数组结构和 HashEntry 数组结构</strong> 构成。在 jdk 8中，底层和 HashMap 数据结构差不多。采用的是<strong>数组+链表+红黑树</strong>(链表长度超过8则由链表转红黑树)</p><ul><li>扩容方式</li></ul><p>Hashtable 扩容为原来的 2倍+1 大小。</p><p>ConcurrentHashMap 扩容为原来的 2 倍</p><ul><li>添加元素的方式</li></ul><p>Hashtable 将新节点插入到链表<strong>头部</strong>。</p><p>ConcurrentHashMap 将新节点插入到链表<strong>尾部</strong>。</p><ul><li>默认容量大小</li></ul><p>Hashtable 默认容量为 11。</p><p>ConcurrentHashMap 默认容量为 16。</p><h3 id="HashMap源码中的重要常量"><a href="#HashMap源码中的重要常量" class="headerlink" title="HashMap源码中的重要常量"></a>HashMap源码中的重要常量</h3><p>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</p><p>MAXIMUM_CAPACITY : HashMap的最大支持容量，2^30 </p><p>DEFAULT_LOAD_FACTOR: HashMap的默认加载因子 </p><p>TREEIFY_THRESHOLD: Bucket中链表长度大于该默认值，转化为红黑树 </p><p>UNTREEIFY_THRESHOLD: Bucket中红黑树存储的Node小于该默认值，转化为链表 </p><p>MIN_TREEIFY_CAPACITY: 桶中的Node被树化时最小的hash表容量。(当桶中Node的 数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行 resize扩容操作这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_THRESHOLD的4 倍。)</p><p>table: 存储元素的数组，总是2的n次幂 </p><p>entrySet: 存储具体元素的集 </p><p>size: HashMap中存储的键值对的数量 </p><p>modCount: HashMap扩容和结构改变的次数。 </p><p>threshold: 扩容的临界值，threshold=容量*填充因子 </p><p>loadFactor: 填充因子</p><h3 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h3><p>jdk 7 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化容器大小为 16，也就是创建的数组的长度。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 加载因子为 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//table</span></span><br><span class="line"><span class="keyword">transient</span> Entry&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 点击 this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR); 进入此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="comment">// 如果这里传进的值是自己定的，也不会就创建自己指定的大小。</span></span><br><span class="line">  <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给当前对象的加载因子赋值为 0.75</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="comment">//min(16*0.75,最大值)，threshold就是临界值，是12，这个值影响的是扩容的时候，超过就扩容。</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 创造了长度为 16 的数组，这里的 table 就是上面定义的 table。</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">  <span class="comment">//这里不会就不看了，然后看 put 数据的时候。</span></span><br><span class="line">    useAltHashing = sun.misc.VM.isBooted() &amp;&amp;</span><br><span class="line">            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. put 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//坚持是不是 null，是就放了。Hashtable不是这样的。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">  <span class="comment">// 计算 key 的 hash 值。hash方法在 put 方法下面👇</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">  <span class="comment">// 获取在数组中要存放的位置，indexFor()方法在下面。</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">  <span class="comment">//取出要放的位置的数据，先判断是不是为 null，不是 null 就进去，也就是有值了，可能就不止一个值了。</span></span><br><span class="line">  <span class="comment">//所以就 for 循环</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">      <span class="comment">//先判断 hash 是不是等等，不等就不用看了，如果循环后都不等，也就跳出for循环，执行下面的      addEntry 了</span></span><br><span class="line">      <span class="comment">//如果 hash 值相等,先判断 key 是不是相等，再去判断 equals 是不是相等。</span></span><br><span class="line">      <span class="comment">//如果 hash 值相等，但是equals不相等，还是执行 addEntry</span></span><br><span class="line">      <span class="comment">//如果都为 true，那就是key-value都相同，那就进行修改老的值。</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 这个就不看了</span></span><br><span class="line">    modCount++;</span><br><span class="line">  <span class="comment">//没有元素直接添加，addEntry()方法在下面👇</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// useAltHashing 默认为 false</span></span><br><span class="line">    <span class="keyword">if</span> (useAltHashing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            <span class="keyword">return</span> sun.misc.Hashing.stringHash32((String) k);</span><br><span class="line">        &#125;</span><br><span class="line">        h = hashSeed;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//调用hashCode方法，进行异或得到值。</span></span><br><span class="line">    h ^= k.hashCode();</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//一系列异或算法</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// indexFor()方法</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 位运算符取余</span></span><br><span class="line">    <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addEntry 方法，参数 bucketIndex 为要存放的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//如果这个值大于刚刚算的临界值 12 且 这个里面有值.</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">      <span class="comment">//这里就进行扩容，扩容为原来的 2 倍。</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">      <span class="comment">//重新计算 hash 值，就有可能原来是链表，后来就在数组里了，这里比较耗时间。</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 不需要扩容就直接执行这个方法。这个方法在下面👇</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// createEntry()</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先把数组中本身的元素取出来，赋值为e</span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">  <span class="comment">//在创建新的 Entry放入小位位上。（这里指的是七上八下的七上）</span></span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  <span class="comment">//大小加一</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">  <span class="comment">// 指向下一个元素</span></span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line">    <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的n就是原来的那个e，赋值为新创建的下一个元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">        V oldValue = value;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Map.Entry e = (Map.Entry)o;</span><br><span class="line">        Object k1 = getKey();</span><br><span class="line">        Object k2 = e.getKey();</span><br><span class="line">        <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">            Object v1 = getValue();</span><br><span class="line">            Object v2 = e.getValue();</span><br><span class="line">            <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">               (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getKey() + <span class="string">&quot;=&quot;</span> + getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the value in an entry is</span></span><br><span class="line"><span class="comment">     * overwritten by an invocation of put(k,v) for a key k that&#x27;s already</span></span><br><span class="line"><span class="comment">     * in the HashMap.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This method is invoked whenever the entry is</span></span><br><span class="line"><span class="comment">     * removed from the table.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk 8 源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//仅仅是赋值加载因子，没有创建长度为 16 的数组</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//put()方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//算出 hash 值，然后进入putVal()方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//putVal()方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,<span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//创建了两个 Node 类型的变量 ，两个int类型的变量。</span></span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="comment">//tab = table) == null 为 true</span></span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//执行了resize()方法，这个方法在下面👇</span></span><br><span class="line">    <span class="comment">//获得长度</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="comment">//与运算获取位置，看其位置赋值给p，然后看是不是有元素</span></span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    <span class="comment">//如果没有元素，那就直接创建新的节点，添加成功</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">//判断hash值是不是相等，如果hash相等，在判断key和equals是不是相等。</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="comment">//一样，就把当前的元素放在刚刚创建的e里。</span></span><br><span class="line">      e = p;</span><br><span class="line">    <span class="comment">//判断是不是TreeNode，先不看，暂时不是红黑树。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="comment">//要么hash值不一样，要么hash值一样，equals不一样，都进来这个else。</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//进入for循环</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="comment">//如果就一个元素，就进</span></span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//那就直接作为p.next。(这里就是七上八下的八下)</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="comment">//如果超过8，就变为 tree 的结构了</span></span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">//这个方法在下面👇</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后对比hash值是不是一样，比key比equals。若为真，那就是真正的相同，直接break掉。</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//e不是null也就是刚才的p值</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="comment">//进行值替换</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize() 方法</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  <span class="comment">//table 为 null</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">//oldCap为0</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="comment">//临界值为0</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">  <span class="comment">//定义俩变量</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//oldCap为0，不进去</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//oldThr 为0，不进去。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">  <span class="comment">//这里就进去了</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">          <span class="comment">//这里就进去了，发现是 16 被赋值。</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">          <span class="comment">//16*0.75 = 12 临界值出现。</span></span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//12 ！=0</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//临界值赋值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  <span class="comment">//创建了一个Node 的数组，newCap = 16</span></span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  <span class="comment">//赋值为16</span></span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">//返回了16</span></span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//treeifyBin() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">  <span class="comment">//tab是数组，不为null。</span></span><br><span class="line">  <span class="comment">//static final int MIN_TREEIFY_CAPACITY = 64;</span></span><br><span class="line">  <span class="comment">//当前长度是不是大于64，不是的话，就扩容大小。</span></span><br><span class="line">  <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br><span class="line">  <span class="comment">//大于64 再去变为树。</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">        hd = p;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        p.prev = tl;</span><br><span class="line">        tl.next = p;</span><br><span class="line">      &#125;</span><br><span class="line">      tl = p;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">      hd.treeify(tab);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>jdk8 相较于jdk7在底层实现方面的不同：</p><ul><li>new HashMap():底层没有创建一个长度为16的数组</li><li>jdk 8底层的数组是：Node[],而非Entry[]</li><li>首次调用put()方法时，底层创建长度为 16 的数组</li><li>jdk7底层结构只有：数组+链表。jdk8 中底层结构：数组+链表+红黑树。</li><li>形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li><li>当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</li></ul><h3 id="ConcurrentHashMap-讲解"><a href="#ConcurrentHashMap-讲解" class="headerlink" title="ConcurrentHashMap 讲解"></a>ConcurrentHashMap 讲解</h3><p><a href="https://blog.csdn.net/justloveyou_/article/details/72783008">https://blog.csdn.net/justloveyou_/article/details/72783008</a></p><h3 id="JDK1-7-和-JDK1-8-ConcurrentHashMap的区别？"><a href="#JDK1-7-和-JDK1-8-ConcurrentHashMap的区别？" class="headerlink" title="JDK1.7 和 JDK1.8 ConcurrentHashMap的区别？"></a>JDK1.7 和 JDK1.8 ConcurrentHashMap的区别？</h3><p><strong>数据结构</strong>：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p><strong>保证线程安全机制</strong>：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用CAS+synchronized保证线程安全。</p><p><strong>锁的粒度</strong>：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。</p><p><strong>链表转化为红黑树</strong>：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。</p><p><strong>查询时间复杂度</strong>：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。</p><h3 id="ConcurrentHashMap的实现原理是什么？"><a href="#ConcurrentHashMap的实现原理是什么？" class="headerlink" title="ConcurrentHashMap的实现原理是什么？"></a>ConcurrentHashMap的实现原理是什么？</h3><p>ConcurrentHashMap 在 JDK 1.7 和 JDK 1.8实现的原理不同。</p><p><strong>JDK 1.7</strong> </p><p>JDK1.7 中的 ConcurrentHashMap 是由 <strong>Segment 数组结构和 HashEntry 数组结构</strong>组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment），每个小数组有 n 个 HashEntry 组成。</p><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</p><p><strong>JDK 1.8</strong> </p><p>JDK1.8 中的 ConcurrentHashMap 选择了与 HashMap 相同的<strong>Node数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized 实现更加细粒度的锁。</p><p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p><h3 id="JDK-1-8-中为什么使用内置锁-synchronized-替换可重入锁-ReentrantLock？"><a href="#JDK-1-8-中为什么使用内置锁-synchronized-替换可重入锁-ReentrantLock？" class="headerlink" title="JDK 1.8 中为什么使用内置锁 synchronized 替换可重入锁 ReentrantLock？"></a>JDK 1.8 中为什么使用内置锁 synchronized 替换可重入锁 ReentrantLock？</h3><p>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</p><p>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</p><h3 id="处理-hash-冲突有哪些方法？"><a href="#处理-hash-冲突有哪些方法？" class="headerlink" title="处理 hash 冲突有哪些方法？"></a>处理 hash 冲突有哪些方法？</h3><p>直接定址法、除留余数法、数字分析法、平方取中法。</p><p>拉链法、开放定址法，</p><h3 id="为什么超过-8-才变为红黑树-？"><a href="#为什么超过-8-才变为红黑树-？" class="headerlink" title="为什么超过 8 才变为红黑树 ？"></a>为什么超过 8 才变为红黑树 ？</h3><p><a href="https://www.cnblogs.com/linghu-java/p/10598758.html">参考链接</a></p><p>说法一：</p><p>TreeNodes 占用空间是普通 Nodes 的两倍，所以只有当 bin 包含足够多的节点时才会转成 TreeNodes。链表长度达到8就转成红黑树，当长度降到6就转成普通 bin。（bin就是bucket，即HashMap中hashCode值一样的元素保存的地方）</p><p>当 hashCode 离散性很好的时候，树型 bin 用到的概率非常小，因为数据均匀分布在每个 bin 中，几乎不会有 bin 中链表长度会达到阈值。但是在随机 hashCode 下，离散性可能会变差，然而 JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。不过理想情况下随机 hashCode 算法下所有bin中节点的分布频率会遵循<strong>泊松分布</strong>，我们可以看到，一个 bin 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。所以，之所以选择 8 ，不是拍拍屁股决定的，而是根据概率统计决定的。由此可见，发展30年的 Java 每一项改动和优化都是非常严谨和科学的。</p><p>说法二：</p><p>红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，而log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p><h3 id="ConcurrentHashMap-为什么不支持-null-value？"><a href="#ConcurrentHashMap-为什么不支持-null-value？" class="headerlink" title="ConcurrentHashMap 为什么不支持 null value？"></a>ConcurrentHashMap 为什么不支持 null value？</h3><p>因为 value 为 null 有两种情况，第一种是可能存的值为 null，第二种可能就是没有映射到值返回的 null 值。而 HashMap 在单线程下可以通过 ContainsKey() 区分这两种情况。ConcurrentHashMap 用于多线程下，本来映射 ContainsKey() 返回 false，但是可能在你调用 ContainsKey() 检查时，新线程插入了 null值，返回 ture。存在二义性。</p><h3 id="多线程下安全的操作，map还有其他方法吗？"><a href="#多线程下安全的操作，map还有其他方法吗？" class="headerlink" title="多线程下安全的操作，map还有其他方法吗？"></a>多线程下安全的操作，map还有其他方法吗？</h3><p>使用Collections.SynchronizedMap 方法，对方法进行同步锁。如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</p><h3 id="具体说一下-Hashtable-的锁机制？"><a href="#具体说一下-Hashtable-的锁机制？" class="headerlink" title="具体说一下 Hashtable 的锁机制？"></a>具体说一下 Hashtable 的锁机制？</h3><p>Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p><p>参考资料：</p><ol><li><p><a href="https://www.bilibili.com/video/BV1Kb411W75N?spm_id_from=333.337.search-card.all.click">尚硅谷基础视频课程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/RmpzIc9sddmVgvwZnM9OSw">你好，面试官-HashMap</a></p></li><li><p><a href="https://blog.csdn.net/justloveyou_/article/details/72783008">ConcurrentHashMap 1.7</a></p></li><li><p><a href="https://blog.csdn.net/wwj17647590781/article/details/118151008?spm=1001.2014.3001.5501">ConcurrentHashMap 1.8</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="2021/01/31/JavaWeb/"/>
      <url>2021/01/31/JavaWeb/</url>
      
        <content type="html"><![CDATA[<center>珍惜时间</center><a id="more"></a><h1 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h1><h2 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1.Servlet"></a>1.Servlet</h2><h3 id="1-什么是Servlet"><a href="#1-什么是Servlet" class="headerlink" title="1. 什么是Servlet"></a>1. 什么是Servlet</h3><ol><li>Servlet是JavaEE规范之一，规范就是接口</li><li>Servlet就是JavaWeb三大组件之一，三大组件就是：Servlet程序、Filter监听器、Listener监视器。</li><li>Servlet是运行中服务器上的java小程序，可以接收客户端发送过来的请求，并响应数据给客户端。</li></ol><h3 id="2-手动实现Servlet程序"><a href="#2-手动实现Servlet程序" class="headerlink" title="2. 手动实现Servlet程序"></a>2. 手动实现Servlet程序</h3><ol><li>编写一个类实现Servlet接口</li><li>实现service，处理请求，并响应数据。</li><li>到web.xml文件中去配置servlet访问地址</li></ol><h3 id="3-URL地址到Servlet程序的访问过程"><a href="#3-URL地址到Servlet程序的访问过程" class="headerlink" title="3. URL地址到Servlet程序的访问过程"></a>3. URL地址到Servlet程序的访问过程</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210131110407795.png" alt="image-20210131110407795"></p><h3 id="4-Servlet的生命周期"><a href="#4-Servlet的生命周期" class="headerlink" title="4. Servlet的生命周期"></a>4. Servlet的生命周期</h3><ol><li>执行Servlet构造器方法</li><li>执行init方法（第一二步是在第一次访问的时候创建Servlet程序会调用）</li><li>执行service方法（每次访问都会调用）</li><li>执行destory方法（停止的时候才会执行）</li></ol><h3 id="5-GET请求和POST请求的分发处理"><a href="#5-GET请求和POST请求的分发处理" class="headerlink" title="5. GET请求和POST请求的分发处理"></a>5. GET请求和POST请求的分发处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;3 service === Hello Servlet 被访问了&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 类型转换（因为它有getMethod()方法,ServletRequest没有这样的方法，HttpServletRequest是ServletRequest的子类）</span></span><br><span class="line">       HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">       <span class="comment">// 获取请求的方式</span></span><br><span class="line">       String method = httpServletRequest.getMethod();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">           doGet();</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">          doPost();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 做get请求的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;get请求&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;get请求&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 做post请求的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">&quot;post请求&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;post请求&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-通过继承HttpServlet实现Servlet程序"><a href="#6-通过继承HttpServlet实现Servlet程序" class="headerlink" title="6. 通过继承HttpServlet实现Servlet程序"></a>6. 通过继承HttpServlet实现Servlet程序</h3><p>一般在实际项目开发中，都是使用继承 HttpServlet 类的方式实现 Serlvet 程序</p><ol><li>编写一个类去继承 Httpservlet 类</li><li>根据业务需要重写 doGet 或者doPost 方法</li><li>到web.xml文件中配置 Servlet 程序的访问地址</li></ol><h3 id="7-使用IDEA-创建-Servlet-程序"><a href="#7-使用IDEA-创建-Servlet-程序" class="headerlink" title="7. 使用IDEA 创建 Servlet 程序"></a>7. 使用IDEA 创建 Servlet 程序</h3><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210131112916266.png" alt="image-20210131112916266" style="zoom:50%;" /><p>而且还会帮你在web.xml文件中配置部分<servlet></p><h3 id="8-Servlet类的继承体系"><a href="#8-Servlet类的继承体系" class="headerlink" title="8. Servlet类的继承体系"></a>8. Servlet类的继承体系</h3><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210131114658790.png" alt="image-20210131114658790" style="zoom:50%;" /><h2 id="2-ServletConfig-类"><a href="#2-ServletConfig-类" class="headerlink" title="2. ServletConfig 类"></a>2. ServletConfig 类</h2><p>ServletConfig是Servlet程序的配置信息类，Servlet 程序和 ServletConfig 对象都是由 Tomcat对象负责创建，我们负责使用。</p><p>Servlet程序默认是第一次访问的时候创建，ServletConfig 是每个 Servlet 程序创建时，就创建一个对应的ServletConfig 对象。ServletConfig就封装了<strong>初始化配置的信息</strong>。</p><p>Servlet 里面的 ServletConfig对象是不能获取其他Servlet 的配置信息的。</p><h3 id="1-ServletConfig-类的三大作用"><a href="#1-ServletConfig-类的三大作用" class="headerlink" title="1.ServletConfig 类的三大作用"></a>1.ServletConfig 类的三大作用</h3><ul><li>获取Servlet程序的别名 servlet-name的值</li><li>获取初始化参数 init-param</li><li>获取 ServletContext 对象</li></ul><h2 id="3-ServletContext类"><a href="#3-ServletContext类" class="headerlink" title="3. ServletContext类"></a>3. ServletContext类</h2><h3 id="1-什么是ServletContext"><a href="#1-什么是ServletContext" class="headerlink" title="1. 什么是ServletContext"></a>1. 什么是ServletContext</h3><ul><li><p>ServletContext 是一个接口，表示一个servlet 上下文对象。</p></li><li><p>一个web工程，只会有一个 ServletContext对象实例。</p></li><li><p>ServletContext是一个域对象。</p><p>域对象是可以像Map一样存取数据的对象，叫做域对象。域对象指的是存取数据的<strong>操作范围</strong>，也就是整个web工程。</p></li><li><p>ServletContext是在web工程部署的启动的时候创建，在web工程停止的时候销毁。</p></li></ul><table><thead><tr><th></th><th>存数据</th><th>取数据</th><th>删除数据</th></tr></thead><tbody><tr><td>Map</td><td>put</td><td>get</td><td>remove()</td></tr><tr><td>域对象</td><td>setAttribute()</td><td>getAttribute()</td><td>removeAttribute()</td></tr></tbody></table><h3 id="2-ServletContext类有什么作用？"><a href="#2-ServletContext类有什么作用？" class="headerlink" title="2. ServletContext类有什么作用？"></a>2. ServletContext类有什么作用？</h3><ol><li>获取web.xml文件中配置的上下文参数</li><li>获取当前的工程路径</li><li>获取工程部署后在服务器硬盘上的绝对路径</li><li>像Map一样存取数据</li></ol><h2 id="4-Http协议"><a href="#4-Http协议" class="headerlink" title="4. Http协议"></a>4. Http协议</h2><h3 id="1-什么是Http协议"><a href="#1-什么是Http协议" class="headerlink" title="1.什么是Http协议"></a>1.什么是Http协议</h3><p>协议是指双方或者多方，相互约定好，大家都需要遵守的规则，叫做协议。</p><p>Http协议也就是客户端和服务器之间通信时，发送的数据，需要遵守的规则，叫做Http协议，Http协议中的数据又称作报文。</p><h3 id="2-请求的Http协议格式"><a href="#2-请求的Http协议格式" class="headerlink" title="2.请求的Http协议格式"></a>2.请求的Http协议格式</h3><p>客户端给服务器发送的数据叫做请求。</p><p>服务器给客户端的回传数据叫做响应。</p><ol><li>Get请求</li></ol><ul><li><p>请求行</p><ul><li>请求的方式                      GET</li><li>请求的资源路径【+?+请求参数】</li><li>请求协议的版本号。     Http/1.1</li></ul></li><li><p>请求头</p><p>Key:value 组成 ，不同的键值对表示不同的含义</p></li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210131153750111.png" alt="image-20210131153750111"></p><ol start="2"><li>Post请求</li></ol><ul><li><p>请求行</p><ul><li>请求的方式                      Post</li><li>请求的资源路径【+?+请求参数】</li><li>请求协议的版本号。     Http/1.1</li></ul></li><li><p>请求头</p><p>Key:value 组成 ，不同的键值对表示不同的含义</p></li><li><p>请求体，就是发送给服务器的数据</p></li></ul><ol start="3"><li>常用请求头的说明</li></ol><p>Accept：表示客户端可以接收的数据类型</p><p>Accept-Language：表示客户端可以接受的语言类型</p><p>User-Agent：表示客户端浏览器的信息</p><p>Host： 表示请求的服务器ip和端口号</p><ol start="4"><li>Get请求有哪些？Post请求有哪些？</li></ol><p>GET请求：</p><ul><li>form标签 method=get</li><li>a标签</li><li>link标签引入css</li><li>Script标签引入js文件</li><li>img标签引入图片</li><li>iframe引入html页面</li><li>在浏览器地址栏中输入地址后会车</li></ul><p>POST请求：</p><ul><li>form标签 form=post</li></ul><h3 id="3-响应的Http协议格式"><a href="#3-响应的Http协议格式" class="headerlink" title="3.响应的Http协议格式"></a>3.响应的Http协议格式</h3><ol><li><p>响应行</p><ol><li>响应的协议和版本号（HTTP/1.1）</li><li>响应状态吗（200、302、404、500）</li><li>响应状态描述符</li></ol></li><li><p>响应头</p><ol><li>Key:value 不同的响应头，有不同的含义</li></ol></li><li><p>响应体（就是回传给客户端数据）</p></li></ol><h2 id="5-HttpServletRequest类"><a href="#5-HttpServletRequest类" class="headerlink" title="5. HttpServletRequest类"></a>5. HttpServletRequest类</h2><h3 id="1-httpServletRequest类有什么作用？"><a href="#1-httpServletRequest类有什么作用？" class="headerlink" title="1.httpServletRequest类有什么作用？"></a>1.httpServletRequest类有什么作用？</h3><h1 id="EL表达式-amp-JSTL"><a href="#EL表达式-amp-JSTL" class="headerlink" title="EL表达式 &amp; JSTL"></a>EL表达式 &amp; JSTL</h1><h2 id="1-EL表达式"><a href="#1-EL表达式" class="headerlink" title="1. EL表达式"></a>1. EL表达式</h2><h3 id="1-什么是EL表达式"><a href="#1-什么是EL表达式" class="headerlink" title="1.什么是EL表达式"></a>1.什么是EL表达式</h3><p>EL表达式说的全称：Expression Language 是表达式语言</p><p>EL表达式作用：EL表达式主要是替代jsp页面中的表达式脚本在jsp页面进行数据的输出，</p><p>为什么用EL表达式来代替jsp页面表达式脚本？因为比jsp脚步简洁。</p><p>格式： ${}</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        <span class="attr">request.setAttribute</span>(&quot;<span class="attr">key</span>&quot;,&quot;值&quot;);</span></span><br><span class="line"><span class="tag">    %&gt;</span></span><br><span class="line">    表达式脚本输出key的值是：<span class="tag">&lt;<span class="name">%=request.getAttribute(&quot;key1&quot;)==null?&quot;&quot;:request.getAttribute(&quot;key1&quot;)%</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    EL表达式输出key的值是：$&#123;key&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-EL表达式搜索域数据的顺序"><a href="#2-EL表达式搜索域数据的顺序" class="headerlink" title="2. EL表达式搜索域数据的顺序"></a>2. EL表达式搜索域数据的顺序</h3><p>EL表达式主要是在jsp页面中输出数据，</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        //往四个域中都保存了相同的<span class="attr">key</span>的数据。</span></span><br><span class="line"><span class="tag">        <span class="attr">request.setAttribute</span>(&quot;<span class="attr">key</span>&quot;, &quot;<span class="attr">request</span>&quot;);</span></span><br><span class="line"><span class="tag">        <span class="attr">session.setAttribute</span>(&quot;<span class="attr">key</span>&quot;, &quot;<span class="attr">session</span>&quot;);</span></span><br><span class="line"><span class="tag">        <span class="attr">application.setAttribute</span>(&quot;<span class="attr">key</span>&quot;, &quot;<span class="attr">application</span>&quot;);</span></span><br><span class="line"><span class="tag">        <span class="attr">pageContext.setAttribute</span>(&quot;<span class="attr">key</span>&quot;, &quot;<span class="attr">pageContext</span>&quot;);</span></span><br><span class="line"><span class="tag">    %&gt;</span></span><br><span class="line">    $&#123; key &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">//输出pageContext，若是注掉pageContext一行，输出request，注掉request，显示session，关闭浏览器，注掉session，显示application</span><br></pre></td></tr></table></figure><p>当四个域中都有相同的数据时，EL表达式会按照四个域中从小到大的顺序去进行搜索，找到就输出。</p><p>域范围 : pageContext&lt;request&lt;session&lt;application</p><h3 id="3-EL表达式输出Bean的普通属性，数组属性，List集合属性，Map集合属性"><a href="#3-EL表达式输出Bean的普通属性，数组属性，List集合属性，Map集合属性" class="headerlink" title="3. EL表达式输出Bean的普通属性，数组属性，List集合属性，Map集合属性"></a>3. EL表达式输出Bean的普通属性，数组属性，List集合属性，Map集合属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">        <span class="attr">Person</span> <span class="attr">person</span> = <span class="string">new</span> <span class="attr">Person</span>();</span></span><br><span class="line"><span class="tag">        <span class="attr">person.setName</span>(&quot;国哥好帅！&quot;);</span></span><br><span class="line"><span class="tag">        <span class="attr">person.setPhones</span>(<span class="attr">new</span> <span class="attr">String</span>[]&#123;&quot;<span class="attr">18610541354</span>&quot;,&quot;<span class="attr">18688886666</span>&quot;,&quot;<span class="attr">18699998888</span>&quot;&#125;);</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line">        List&lt;String&gt; cities = new ArrayList&lt;String&gt;();</span><br><span class="line">        cities.add(&quot;北京&quot;);</span><br><span class="line">        cities.add(&quot;上海&quot;);</span><br><span class="line">        cities.add(&quot;深圳&quot;);</span><br><span class="line">        person.setCities(cities);</span><br><span class="line"></span><br><span class="line">        Map<span class="tag">&lt;<span class="name">String,Object</span>&gt;</span>map = new HashMap<span class="tag">&lt;&gt;</span>();</span><br><span class="line">        map.put(&quot;key1&quot;,&quot;value1&quot;);</span><br><span class="line">        map.put(&quot;key2&quot;,&quot;value2&quot;);</span><br><span class="line">        map.put(&quot;key3&quot;,&quot;value3&quot;);</span><br><span class="line">        person.setMap(map);</span><br><span class="line"></span><br><span class="line">        pageContext.setAttribute(&quot;p&quot;, person);</span><br><span class="line">    %&gt;</span><br><span class="line"></span><br><span class="line">    输出Person：$&#123; p &#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    输出Person的name属性：$&#123;p.name&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的pnones数组属性值：$&#123;p.phones[2]&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的cities集合中的元素值：$&#123;p.cities&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的List集合中个别元素值：$&#123;p.cities[2]&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的Map集合: $&#123;p.map&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的Map集合中某个key的值: $&#123;p.map.key3&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    输出Person的age属性：$&#123;p.age&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-EL表达式–运算"><a href="#4-EL表达式–运算" class="headerlink" title="4.  EL表达式–运算"></a>4.  EL表达式–运算</h3><h5 id="1-关系运算、逻辑运算、算术运算"><a href="#1-关系运算、逻辑运算、算术运算" class="headerlink" title="1.关系运算、逻辑运算、算术运算"></a>1.关系运算、逻辑运算、算术运算</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    $&#123; 12 == 12 &#125; 或 $&#123; 12 eq 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 != 12 &#125; 或 $&#123; 12 ne 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 &lt; 12 &#125; 或 $&#123; 12 lt 12 &#125; &lt;br&gt;</span><br><span class="line">    $&#123; 12 &gt; 12 &#125; 或 $&#123; 12 gt 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 &lt;= 12 &#125; 或 $&#123; 12 le 12 &#125; &lt;br&gt;</span><br><span class="line">    $&#123; 12 &gt;= 12 &#125; 或 $&#123; 12 ge 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    $&#123; 12 == 12 &amp;&amp; 12 &gt; 11 &#125; 或 $&#123; 12 == 12 and 12 &gt; 11 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 == 12 || 12 &gt; 11 &#125; 或 $&#123; 12 == 12 or 12 &gt; 11 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; ! true &#125; 或 $&#123; not true &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    $&#123; 12 + 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 - 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 12 * 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 18 / 12 &#125; 或 $&#123; 18 div 12 &#125;<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    $&#123; 18 % 12 &#125; 或 $&#123; 18 mod 12 &#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-empty运算"><a href="#2-empty运算" class="headerlink" title="2. empty运算"></a>2. empty运算</h5><p>可以判断一个数据是否为空，如果空，为输出true，不为空，输出false。</p><p>以下几种情况为空：</p><ul><li>值为 null 的时候</li><li>空串</li><li>Object类型数组，长度为0</li><li>list集合，元素个数0</li><li>map集合，元素个数0</li></ul><h5 id="3-三元运算"><a href="#3-三元运算" class="headerlink" title="3. 三元运算"></a>3. 三元运算</h5><p>表达式1？表达式2:表达式3</p><h5 id="4-“-”点运算-和-“-”-中括号运算"><a href="#4-“-”点运算-和-“-”-中括号运算" class="headerlink" title="4. “.”点运算 和 “[]” 中括号运算"></a>4. “.”点运算 和 “[]” 中括号运算</h5><p>“.”点运算可以输出Bean对象中某个属性的值</p><p>“[]” 中括号运算，可以输出有序集合中某个元素的值，</p><p>并且[]中括号运算，可以输出map集合里含有特殊字符的key的值</p><h3 id="5-EL表达式中11个隐含对象"><a href="#5-EL表达式中11个隐含对象" class="headerlink" title="5. EL表达式中11个隐含对象"></a>5. EL表达式中11个隐含对象</h3><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210201150612549.png" alt="image-20210201150612549" style="zoom: 67%;" /><h2 id="2-JSTL表达式"><a href="#2-JSTL表达式" class="headerlink" title="2.JSTL表达式"></a>2.JSTL表达式</h2><h1 id="文件的上传和下载"><a href="#文件的上传和下载" class="headerlink" title="文件的上传和下载"></a>文件的上传和下载</h1><p>文件的上传和下载功能非常常见，经常使用，扣扣头像，邮箱中附件的上传和下载功能。</p><h2 id="1-文件的上传介绍"><a href="#1-文件的上传介绍" class="headerlink" title="1. 文件的上传介绍"></a>1. 文件的上传介绍</h2><ol><li>要有一个form标签，method=post请求</li><li>form标签的enctype属性，值必须是multipart/form-data值。</li><li>在form标签中使用input type = file 添加上传的文件</li><li>编写服务器代码（这里使用servlet进行接收）接收，处理上传的数据。</li></ol><p>enctype=multipart/form-data表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的方式进行发送，发送给服务器。</p><h2 id="2-文件上传时协议内容"><a href="#2-文件上传时协议内容" class="headerlink" title="2. 文件上传时协议内容"></a>2. 文件上传时协议内容</h2><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210202150927155.png" alt="image-20210202150927155"></p><h2 id="3-commons-fileload-jar-常用API介绍说明"><a href="#3-commons-fileload-jar-常用API介绍说明" class="headerlink" title="3. commons-fileload.jar 常用API介绍说明"></a>3. commons-fileload.jar 常用API介绍说明</h2><p>commons-fileload.jar 需要commons-io.jar这个包，所以导入这两个包。</p><p>第一步：导入这两个包</p><p>commons-fileload.jar和commons-io.jar中常用的类有哪些？</p><p><strong>ServletFileUpload 类</strong>：用于解析上传的数据。</p><p><strong>FileItem类</strong> ：表示没一个表单项，有普通的表单项，还是上传的类型</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210202152417085.png" alt="image-20210202152417085"></p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210202152949156.png" alt="image-20210202152949156" style="zoom:67%;" /><h2 id="4-文件的下载"><a href="#4-文件的下载" class="headerlink" title="4. 文件的下载"></a>4. 文件的下载</h2><p>见代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DownloadServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//       1. 获取要下载的文件名</span></span><br><span class="line">        String download = <span class="string">&quot;1.jpeg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        2. 读取要下载的文件内容(通过ServletContext对象可以获取)</span></span><br><span class="line">        ServletContext servletContext = getServletContext();</span><br><span class="line"></span><br><span class="line"><span class="comment">//      获取要下载的文件类型</span></span><br><span class="line">        String mimeType = servletContext.getMimeType(<span class="string">&quot;/file/1.jpeg&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;下载的文件类型:&quot;</span>+mimeType);</span><br><span class="line"><span class="comment">//        4. 在回传前，通过响应头告诉客户端返回的数据类型</span></span><br><span class="line">        resp.setContentType(mimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        5. 还要告诉客户端收到的数据是用于下载使用（还是使用响应头）</span></span><br><span class="line"><span class="comment">//        Content-Disposition响应头，表示收到的数据怎么处理</span></span><br><span class="line"><span class="comment">//        attachment表示附件，filename表示指定的文件名（这里的指定的文件名不一定要和上面的文件名一致，可以自己设置）</span></span><br><span class="line">        resp.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=1.jpeg&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        第一个斜杠表示工程路径</span></span><br><span class="line">        InputStream resourceAsStream = servletContext.getResourceAsStream(<span class="string">&quot;/file/1.jpeg&quot;</span>);</span><br><span class="line"><span class="comment">//         获取响应的输出流</span></span><br><span class="line">        OutputStream outputStream = resp.getOutputStream();</span><br><span class="line"><span class="comment">//        3. 把下载的文件回传给客户端</span></span><br><span class="line">        IOUtils.copy(resourceAsStream,outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="1-什么是Cookie"><a href="#1-什么是Cookie" class="headerlink" title="1.什么是Cookie"></a>1.什么是Cookie</h2><ol><li>Cookie翻译过来是饼干</li><li>Cookie是服务器通知客户端保存键值对的一种技术</li><li>客户端有了 Cookie 以后，每次请求都发送给服务器。</li><li>每个Cookie 端大小不能超过 4kb</li></ol><h2 id="2-如何创建Cookie？"><a href="#2-如何创建Cookie？" class="headerlink" title="2. 如何创建Cookie？"></a>2. 如何创建Cookie？</h2><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210203141258607.png" alt="image-20210203141258607"></p><h2 id="3-服务器如何获取Cookie"><a href="#3-服务器如何获取Cookie" class="headerlink" title="3. 服务器如何获取Cookie"></a>3. 服务器如何获取Cookie</h2><p>Cookie是保存在客户端的，但是客户端每次请求都会发给服务器。那么服务器是如何获取Cookie？只需要一行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.getCookies():Cookie[]</span><br></pre></td></tr></table></figure><h2 id="4-Cookie值的修改"><a href="#4-Cookie值的修改" class="headerlink" title="4. Cookie值的修改"></a>4. Cookie值的修改</h2><p>方案一：</p><ol><li>先创建一个要修改的同名的Cookie对象</li><li>在构造器，同时赋予新的Cookie值</li><li>调用response.addCookie(Cookie);</li></ol><p>方案二：</p><ol><li>先查找到需要修改的Cookie对象</li><li>调用setValue()方法赋于新的Cookie值。</li><li>调用response.addCookie()通知客户端保存修改</li></ol><h2 id="5-浏览器查看Cookie"><a href="#5-浏览器查看Cookie" class="headerlink" title="5. 浏览器查看Cookie"></a>5. 浏览器查看Cookie</h2><h3 id="1-谷歌浏览器查看Cookie"><a href="#1-谷歌浏览器查看Cookie" class="headerlink" title="1.谷歌浏览器查看Cookie"></a>1.谷歌浏览器查看Cookie</h3><p>F12 找到Application，然后找到Cookies，就可以看到Cookie的信息。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210203144148799.png" alt="image-20210203144148799"></p><h3 id="2-火狐浏览器查看Cookie"><a href="#2-火狐浏览器查看Cookie" class="headerlink" title="2.火狐浏览器查看Cookie"></a>2.火狐浏览器查看Cookie</h3><p>F12 找到存储，找到Cookie。然后操作。</p><h2 id="6-Cookie的生命控制"><a href="#6-Cookie的生命控制" class="headerlink" title="6. Cookie的生命控制"></a>6. Cookie的生命控制</h2><p>Cookie的生命控制指的是如何管理Cookie 什么时候被销毁，主要是被setMaxAge()方法操控。</p><p>正数：表示在指定的秒数后过期</p><p>负数：表示浏览器一关，Cookie就会被删除</p><p>0: 表示马上删除Cookie</p><h2 id="7-Cookie有效路径Path的设置"><a href="#7-Cookie有效路径Path的设置" class="headerlink" title="7.Cookie有效路径Path的设置"></a>7.Cookie有效路径Path的设置</h2><p>Cookie的path属性可以有效的过滤那些Cookie可以发送给服务器，那些不发。path属性是通过请求的地址来进行有效的过滤。</p><p>例子：</p><p>CookieA    path=/工程路径</p><p>CookieB    path=/工程路径/abc</p><ol><li><a href="http://ip:port/工程路径/a.html">http://ip:port/工程路径/a.html</a></li></ol><p>CookieA    发送</p><p>CookieB    不发送</p><ol start="2"><li><a href="http://ip:port/工程路径/abc/a.html">http://ip:port/工程路径/abc/a.html</a></li></ol><p>CookieA    发送</p><p>CookieB    发送</p><h2 id="8-Cookie练习–免输入用户名密码登录"><a href="#8-Cookie练习–免输入用户名密码登录" class="headerlink" title="8. Cookie练习–免输入用户名密码登录"></a>8. Cookie练习–免输入用户名密码登录</h2><p>登录细节：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210205111540262.png" alt="image-20210205111540262"></p><h1 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h1><h2 id="1-什么是Session会话"><a href="#1-什么是Session会话" class="headerlink" title="1. 什么是Session会话"></a>1. 什么是Session会话</h2><ol><li>Session是一个接口（HttpSession） </li><li>Session就是会话，它是用来维护一个客户端和服务器之间关联的一种技术。</li><li>每个客户端都有自己的一个Session会话</li><li>Session会话中，我们经常有一个来保存用户登录之后的信息。</li></ol><p>cookie是保存在客户端，而session是保存在服务器端。</p><h2 id="2-如何创建Session-和获取（id号，是否为新）"><a href="#2-如何创建Session-和获取（id号，是否为新）" class="headerlink" title="2. 如何创建Session 和获取（id号，是否为新）"></a>2. 如何创建Session 和获取（id号，是否为新）</h2><p>通过request.getsession()，第一次调用是创建，之后调用都是获取前面创建好的Session会话对象。</p><p>isNew()，判断到底是不是新创建的。</p><p>每个会话都有一个身份号码，都有一个ID值，且唯一。</p><p>getId() 得到Session会话的id值</p><h2 id="3-Session-域数据的存取"><a href="#3-Session-域数据的存取" class="headerlink" title="3. Session 域数据的存取"></a>3. Session 域数据的存取</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       req.getSession().setAttribute(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">       resp.getWriter().write(<span class="string">&quot;已经往Session中保存了数据&quot;</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">getAttribute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">       Object attribute = req.getSession().getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">       resp.getWriter().write(<span class="string">&quot;从Session中获取出key1的数据是：&quot;</span> + attribute);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="4-Session-生命周期控制"><a href="#4-Session-生命周期控制" class="headerlink" title="4. Session 生命周期控制"></a>4. Session 生命周期控制</h2><p> public void setMaxInactiveInterval(int interval); 设置Session的超时时间，超过指定的时长，Seesion就会被销毁。值为正数的时候，设置为Session的超时时长，负数是永不超时（一般不用）。</p><p> public void getMaxInactiveInterval(int interval); 获取Session的超时时间，默认30分钟(1800秒),因为在tomcat的xml文件中配置了30分钟。也可以进行修改。</p><p>如果你希望你的web工程，默认的session的超时时长为其他时长，你可以在你的web.xml配置文件中做以上相同的配置，就可以修改tomcat里配置文件中的默认时长。</p><p>如果你想只修改个别的Session的超时时长，就可以使用上面的API，setMaxInactiveInterval(int interval)来进行单独的设置。</p><h2 id="5-浏览器和Session之间的技术内幕"><a href="#5-浏览器和Session之间的技术内幕" class="headerlink" title="5. 浏览器和Session之间的技术内幕"></a>5. 浏览器和Session之间的技术内幕</h2><p>Session技术，其实是基于Cookie技术实现的。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210205173453678.png" alt="image-20210205173453678"></p><h1 id="Filter过滤器"><a href="#Filter过滤器" class="headerlink" title="Filter过滤器"></a>Filter过滤器</h1><h2 id="1-什么是过滤器及过滤器的应用场景"><a href="#1-什么是过滤器及过滤器的应用场景" class="headerlink" title="1. 什么是过滤器及过滤器的应用场景"></a>1. 什么是过滤器及过滤器的应用场景</h2><ol><li>Filter 过滤器它是 JavaWeb 的三大组件之一。三大组件分别是:Servlet 程序、Listener 监听器、Filter 过滤器</li><li>Filter是javaweb的规范，也就是接口。</li><li>Filter过滤器它的作用是：<strong>拦截请求</strong>，过滤响应。</li></ol><p>拦截请求的常见的应用场景有：</p><ol><li>权限检查</li><li>日记操作</li><li>事务管理</li><li>……</li></ol><h2 id="2-Filter-体验一番"><a href="#2-Filter-体验一番" class="headerlink" title="2. Filter 体验一番"></a>2. Filter 体验一番</h2><p>要求：在你的web工程下，有一个admin，这个admin目录下的所有资源必须是用户登录以后才可以进行访问。比如：html文件、jpg文件、jsp文件等。</p><p>思考:根据之前我们学过内容。我们知道，用户登录之后都会把用户登录的信息保存到 Session 域中。所以要检查用户是否</p><p>登录，可以判断 Session 中否包含有用户登录的信息即可!!!</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210224120934086.png" alt="image-20210224120934086"></p><p>Filter 的工作流程图:</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210222175830683.png" alt="image-20210222175830683"></p><p>Filter的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdminFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123; </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">* doFilter 方法，专门用于拦截请求。可以做权限检查</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpSession session = httpServletRequest.getSession(); Object user = session.getAttribute(<span class="string">&quot;user&quot;</span>);</span><br><span class="line"><span class="comment">// 如果等于 null，说明还没有登录</span></span><br><span class="line"><span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">servletRequest.getRequestDispatcher(<span class="string">&quot;/login.jsp&quot;</span>).forward(servletRequest,servletResponse); <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 让程序继续往下访问用户的目标资源 filterChain.doFilter(servletRequest,servletResponse);</span></span><br><span class="line">&#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml 中的配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--给 filter 起一个别名--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AdminFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置 filter 的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--filter-mapping 配置 Filter 过滤器的拦截路径--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--filter-name 表示当前的拦截路径给哪个 filter 使用--&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AdminFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line">  <span class="comment">&lt;!--url-pattern 配置拦截路径</span></span><br><span class="line"><span class="comment">/表示请求地址为:http://ip:port/工程路径/ 映射到IDEA的web目录</span></span><br><span class="line"><span class="comment">/admin/* 表示请求地址为:http://ip:port/工程路径/admin/* --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Filter 过滤器的使用步骤: </p><ol><li>编写一个类去实现 Filter 接口 </li><li>实现过滤方法 doFilter()</li><li>到 web.xml 中去配置 Filter 的拦截路径</li></ol><h2 id="3-Filter-的生命周期"><a href="#3-Filter-的生命周期" class="headerlink" title="3. Filter 的生命周期"></a>3. Filter 的生命周期</h2><p>Filter 的生命周期包含几个方法 </p><p>1、构造器方法</p><p>2、init 初始化方法<br> 第 1，2 步，在 web 工程启动的时候执行(Filter 已经创建)</p><p>3、doFilter 过滤方法<br> 第 3 步，每次拦截到请求，就会执行</p><p>4、destroy 销毁<br> 第 4 步，停止 web 工程的时候，就会执行(停止 web 工程，也会销毁 Filter 过滤器)</p><h2 id="4-FilterConfig-类"><a href="#4-FilterConfig-类" class="headerlink" title="4. FilterConfig 类"></a>4. FilterConfig 类</h2><p>FilterConfig 类见名知义，它是 Filter 过滤器的配置文件类。</p><p>Tomcat 每次创建 Filter 的时候，也会同时创建一个 FilterConfig 类，这里包含了 Filter 配置文件的配置信息。</p><p>FilterConfig 类的作用是获取 filter 过滤器的配置内容 </p><ol><li>获取 Filter 的名称 filter-name 的内容 </li><li>获取在 Filter 中配置的 init-param 初始化参数 </li><li>获取 ServletContext 对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123; </span><br><span class="line">  System.out.println(<span class="string">&quot;2.Filter 的 init(FilterConfig filterConfig)初始化&quot;</span>);</span><br><span class="line"><span class="comment">//1、获取 Filter 的名称 filter-name 的内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;filter-name 的值是:&quot;</span> + filterConfig.getFilterName());</span><br><span class="line"><span class="comment">//2、获取在 web.xml 中配置的 init-param 初始化参数 </span></span><br><span class="line">System.out.println(<span class="string">&quot;初始化参数username的值是:&quot;</span>+filterConfig.getInitParameter(<span class="string">&quot;username&quot;</span>)); System.out.println(<span class="string">&quot;初始化参数 url 的值是:&quot;</span> + filterConfig.getInitParameter(<span class="string">&quot;url&quot;</span>));</span><br><span class="line"><span class="comment">//3、获取 ServletContext 对象</span></span><br><span class="line">System.out.println(filterConfig.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--filter 标签用于配置一个 Filter 过滤器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--给 filter 起一个别名--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>AdminFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--配置 filter 的全类名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.atguigu.filter.AdminFilter <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-FilterChain-过滤器链"><a href="#5-FilterChain-过滤器链" class="headerlink" title="5. FilterChain 过滤器链"></a>5. FilterChain 过滤器链</h2><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210224122812200.png" alt="image-20210224122812200"></p><h2 id="6-Filter的拦截路径"><a href="#6-Filter的拦截路径" class="headerlink" title="6. Filter的拦截路径"></a>6. Filter的拦截路径</h2><ol><li>精确匹配</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/target.jsp<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的路径，表示请求地址必须为:<a href="http://ip:port/工程路径/target.jsp">http://ip:port/工程路径/target.jsp</a></p><ol start="2"><li>目录匹配</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/admin/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的路径，表示请求地址必须为:<a href="http://ip:port/工程路径/admin/">http://ip:port/工程路径/admin/</a>*</p><ol start="3"><li>后缀名匹配</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的路径，表示请求地址必须以.html 结尾才会拦截到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的路径，表示请求地址必须以.do 结尾才会拦截到</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的路径，表示请求地址必须以.action 结尾才会拦截到</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven笔记</title>
      <link href="2021/01/28/Maven%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/28/Maven%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<center> 远处的钟声迴荡在雨里</center><center>我们在屋簷底下牵手听</center><a id="more"></a><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/%E5%B0%9A%E7%A1%85%E8%B0%B7_Maven%E7%AC%94%E8%AE%B0.png" alt="尚硅谷_Maven笔记"  />]]></content>
      
      
      <categories>
          
          <category> Maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea永久破解</title>
      <link href="2021/01/18/IDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/"/>
      <url>2021/01/18/IDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>技术文档：<a href="https://tech.souyunku.com/?p=30970">https://tech.souyunku.com/?p=30970</a></p><p>压缩包下载：<a href="https://souyunku.lanzous.com/b0aki3kna">https://souyunku.lanzous.com/b0aki3kna</a></p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="2021/01/11/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/01/11/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<center>若女生没有暗示，男人就不敢追</center><center> 一个暗示一个勾搭，一个调戏一个愿意，促成一段苟且</center><center>事后的不甘，纯属你俩分赃不均。</center><a id="more"></a><h1 id="Spring-5"><a href="#Spring-5" class="headerlink" title="Spring 5"></a>Spring 5</h1><h2 id="主要内容："><a href="#主要内容：" class="headerlink" title="主要内容："></a>主要内容：</h2><ul><li>Spring 框架概述</li><li>IOC容器<ol><li>IOC底层原理</li><li>IOC接口（BeanFactory）</li><li>IOC具体操作（基于xml的Bean管理）</li><li>IOC具体操作（基于注解的Bean管理）</li></ol></li><li>AOP</li><li>JdbcTemplate</li><li>事务管理</li><li>Spring5新特性</li></ul><h2 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h2><ol><li><p>Spring框架是一个开放源代码的J2EE应用程序框架</p></li><li><p>解决企业应用开发的复杂性</p></li><li><p>Spring有两个核心部分：IOC部分和AOP部分</p><ul><li>IOC：控制反转（之前创建对象是自己new一个类，现在是把创建对象的过程交给Spring进行管理）</li><li>AOP：面向切面（如果增强功能，可以做到不修改原代码进行代码增强）</li></ul></li><li><p>Spring特点</p><ul><li><p><strong>方便解耦，简化开发</strong>（有IOC，降低耦合度）</p></li><li><p>对AOP的支持</p></li><li><p>方便程序的测试</p></li><li><p>方便集成其他框架</p></li><li><p>降低Java EE API的使用难度</p></li><li><p>方便事务的操作</p></li><li><p>Java源码是经典学习范例</p><p>Spring的源码设计精妙、结构清晰、匠心独运，处处体现着大师对<a href="https://baike.baidu.com/item/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">Java设计模式</a>灵活运用以及对Java技术的高深造诣。Spring框架源码无疑是Java技术的最佳实践范例。如果想在短时间内迅速提高自己的Java技术水平和应用开发水平，学习和研究Spring源码将会使你收到意想不到的效果。</p></li></ul></li></ol><h3 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h3><ol><li>下载Spring5 <a href="https://repo.spring.io/release/org/springframework/spring/">地址</a></li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119140619780.png" alt="image-20210119140619780"></p><p>解压后文件目录：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119140952443.png" alt="image-20210119140952443"></p><p>关于lib文件</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119141818763.png" alt="image-20210119141818763"></p><ol start="2"><li>使用Idea创建普通java工程</li></ol><p>新建项目，选择java，然后选择</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119141428868.png" alt="image-20210119141428868"></p><p>最后创建一个项目</p><ol start="3"><li>导入相关包</li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119142125405.png" alt="image-20210119142125405"></p><p>找的相关包进行导入</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119142233650.png" alt="image-20210119142233650"></p><p>除此之外，还需要日志包</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119142918774.png" alt="image-20210119142918774"></p><p>然后Project Structure –&gt; Modules</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119143200971.png" alt="image-20210119143200971"></p><ol start="4"><li>使用（用Spring的方式进行使用）。创建一个普通的类，然后在再写几个方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.Spring5;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;add。。。。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>创建对象有多种方法，这里使用Spring方式创建对象，创建Spring配置文件，在配置文件创建对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置一下User类对象创建--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li>测试代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//1.加载Spring配置文件 ClassPathXmlApplicationContext 是在类路径下</span></span><br><span class="line">      ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br><span class="line"><span class="comment">//2.获取配置创建的对象，其中&quot;user&quot;是在配置文件中的id值，也就是别名。不是对象的名字，是通过id值得到对应的类，然后进行创建对象，第二个参数进行得到什么类型的对象</span></span><br><span class="line">      User user = context.getBean(<span class="string">&quot;user&quot;</span>, User.class);<span class="comment">//这就是通过Spring得到的对象。</span></span><br><span class="line">      System.out.println(user);</span><br><span class="line">user.add();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="IOC-概念及原理"><a href="#IOC-概念及原理" class="headerlink" title="IOC(概念及原理)"></a>IOC(概念及原理)</h3><ol><li><p>什么是IOC</p><ul><li>控制反转，把对象的创建和对象之间的调用过程，交给Spring管理</li></ul><p><strong>举例</strong>：在Servlet中我们需要使用Service，然而我们之前的做法是在Servlet中创建Service对象， 增加了耦合度，我们现在就把这些对象的创建交给Spring来管理。</p><ul><li>使用IOC的目的：是为了<strong>降低</strong>耦合度</li><li>入门案例就是IOC的实现</li></ul></li><li><p>IOC底层原理主要用到的3个技术</p><ul><li>xml文件的解析</li><li>工厂模式</li><li>反射</li></ul></li><li><p>底层原理-画图</p><ul><li>原始方式</li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119151941904.png" alt="image-20210119151941904"></p><ul><li>工厂方式（通常的解决方案，不是最终的方案）</li></ul><p>此种方式的出现就是为了解耦合，此种方法虽然是解决了Service和Dao之间的耦合度，但是还是引入了Userfactory，也是增加了耦合度。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119152030500.png" alt="image-20210119152030500"></p><ul><li>IOC方式（主要技术：xml文件的解析、工厂模式、反射）</li></ul><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119152140670.png" alt="image-20210119152140670"></p></li></ol><p>好处说明：比如我们的UserDao路径变了，那么Service是也需要改，但是现在我们只需要更改配置文件就可以了。</p><h3 id="IOC接口"><a href="#IOC接口" class="headerlink" title="IOC接口"></a>IOC接口</h3><ol><li><p>IOC的思想基于IOC容器完成，IOC容器底层就是<strong>对象工厂</strong></p></li><li><p>Spring提供了IOC实现的两种方式：（两个接口）</p><p>这两个接口实现的功能相似，都能实现加载配置文件，然后通过工厂这个过程去创建对象。</p><ul><li><strong>BeanFactory</strong> (IOC容器基本实现，是Spring内部使用的接口，一般不提供我们开发人员使用，但是可以使用)</li></ul><p>也就是说</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean1.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>可以换为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanFactory context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;);</span><br></pre></td></tr></table></figure></li></ol><ul><li><strong>ApplicationContext</strong> （是BeanFactory 接口的一个子接口，提供了更多，更强大的功能，提供我们开发人员进行使用）</li></ul><p><strong>区别</strong>：若使用BeanFactory是只是加载配置文件，而不是去创建对象，而我们在使用对象的时候，才去创建对象。ApplicationContext在加载配置文件过程中，如果在里面进行了配置<bean>,那么将把声明的所有对象都进行了创建。（其实使用ApplicationContext这种方式是最好的）</p><ol start="3"><li>ApplicationContext 接口有实现类</li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210119153715972.png" alt="image-20210119153715972"></p><h3 id="IOC操作（Bean管理操作）"><a href="#IOC操作（Bean管理操作）" class="headerlink" title="IOC操作（Bean管理操作）"></a>IOC操作（Bean管理操作）</h3><h4 id="1-什么是Bean管理"><a href="#1-什么是Bean管理" class="headerlink" title="1. 什么是Bean管理"></a>1. 什么是Bean管理</h4><p>Bean管理分为两个操作：</p><ol><li><p>Spring 创建对象</p></li><li><p>Spring 注入属性</p></li></ol><h4 id="2-Bean管理操作的两种方式"><a href="#2-Bean管理操作的两种方式" class="headerlink" title="2.Bean管理操作的两种方式"></a>2.Bean管理操作的两种方式</h4><ul><li><p><strong>基于xml文件的方式</strong></p></li><li><p><strong>基于注解的方式</strong></p></li></ul><h5 id="2-1-基于xml方式创建对象"><a href="#2-1-基于xml方式创建对象" class="headerlink" title="2.1.基于xml方式创建对象"></a>2.1.基于xml方式创建对象</h5><p>在 Spring 配置文件中，使用 Bean 标签，标签里面添加对应属性，就可以实现对象创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其他属性：</p><ul><li>id：唯一标识，这里使用的user，那么用的时候也是user</li><li>class：类全类名</li><li>name: 不怎么使用，可以使用特殊符号</li></ul><p>创建对象时，默认使用无参构造器进行创建，也就是说，如果在写实体类时，写了有参构造器，没写无参构造器，会出错。</p><h5 id="2-2-基于xml方式注入属性"><a href="#2-2-基于xml方式注入属性" class="headerlink" title="2.2.基于xml方式注入属性"></a>2.2.基于xml方式注入属性</h5><pre><code>1. DI ：依赖注入，就是注入属性（要在创建对象的基础之上）</code></pre><p><strong>面试：IOC 与 DI的区别？</strong></p><p><strong>答：DI 是 IOC 里面的一种具体实现，就是注入属性，他是在创建完对象进行注入。</strong></p><p>传统方式注入：</p><ol><li>set 注入。(创建一个实体类，有set方法，new对象时使用set方法进行注入初始化)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String bname;</span><br><span class="line">    <span class="keyword">private</span> String bauthor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBname</span><span class="params">(String bname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bname = bname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBauthor</span><span class="params">(String bauthor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bauthor = bauthor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Book&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;bname=&#x27;&quot;</span> + bname + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, bauthor=&#x27;&quot;</span> + bauthor + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring配置文件配置对象创建，配置属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring源码解析&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lgy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>有参构造注入（创建有参构造器，在new对象时传递参数进行注入初始化）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String oname;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String oname, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oname = oname;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Spring配置文件配置对象创建，配置属性注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;order&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;oname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;顺丰&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;山东省&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>了解内容：（另外一种属性注入的方式）</p><p>使用P名称空间在配置文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行属性注入，在bean标签里面进行操作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.bean.Book&quot;</span> <span class="attr">p:bname</span>=<span class="string">&quot;九阳神功&quot;</span> <span class="attr">p:bauthor</span>=<span class="string">&quot;无名氏&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-XML注入其他属性"><a href="#2-3-XML注入其他属性" class="headerlink" title="2.3.XML注入其他属性"></a>2.3.XML注入其他属性</h5><ol><li>字面量</li></ol><ul><li>空值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Spring源码解析&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bauthor&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>包含特殊符号</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.Book&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bname&quot;</span> &gt;</span></span><br><span class="line">          <span class="comment">&lt;!--&lt;&lt;Spring源码解析&gt;&gt;--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                &lt;![CDATA[&lt;&lt;Spring源码解析&gt;&gt;]]&gt;&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;bauthor&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lgy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>注入属性 – 外部Bean</li></ol><p>Service调用dao层就是引用外部Bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.service.UserService&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name属性值：类里面的属性名称--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--也就是在UserServlce里面private UserDao userDao的值userDao--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>      </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.dao.UserDaoImpl&quot;</span>&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>注入属性 – 内部 Bean 和 级联属性</li></ol><ul><li>一对多关系：部门：员工</li></ul><p>在实体类中表示一对多的关系</p><ol start="4"><li>注入数组类型的属性</li><li>注入 List 集合类型的属性</li><li>注入map集合类型的属性</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.bean.Stu&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组类型的属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sourses&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java 课程<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>数据库<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--List类型属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>历史<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--map类型的属性注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maps&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JAVA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;java&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;JSP&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>在集合里面设置对象类型的信息</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!--给每个学生注入list集合类型，值是对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;courseList&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;course2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建多个course对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.bean.Course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;数学&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;course2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.bean.Course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;cname&quot;</span> <span class="attr">value</span>=<span class="string">&quot;英语&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="7"><li>把集合注入部分提取出来(未记)</li></ol><h4 id="3-FactoryBean"><a href="#3-FactoryBean" class="headerlink" title="3.FactoryBean"></a>3.FactoryBean</h4><p>Spring中有两种Bean，一种是自己创建的Bean，一种是工厂Bean（FactoryBean）</p><p>两者区别，普通Bean定义什么类型就返回什么类型，工厂Bean定义什么类型不一定就返回什么类型，可以不一样。</p><p>工厂Bean演示：</p><ol><li>创建类，让这个类作为工厂bean，只需要实现接口FactoryBean</li><li>实现接口里面的方法</li></ol><p>在配置文件中配置Mybean，按说是返回 MyBean 的对象的，但是在实现接口FactoryBean后，返回的对象就可能是course对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line"><span class="comment">//    定义类型可以和返回类型可以不一样，在返回方法里面进行定义就好了。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Course <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course();</span><br><span class="line">        course.setCname(<span class="string">&quot;优化方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-Bean-的作用域"><a href="#4-Bean-的作用域" class="headerlink" title="4.Bean 的作用域"></a>4.Bean 的作用域</h4><p>什么是Bean的作用域？</p><p>答：在Spring里面可以设置bean 的单实例，还是多实例，默认的是单实例对象，但是可以配置多实例，至于Bean实例是个单实例还是多实例这就是作用域。</p><ol start="2"><li><p>如何设置多实例？</p><p>spring的配置文件bean里面有一个scope属性，用于设置单实例还是多实例。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210121111620970.png" alt="image-20210121111620970"></p><p>若是不设置，使用默认的也就是单实例，singleton，在加载配置文件的时候，就把对象创建出来了，</p><p>若是设置多实例，使用prototype，这里面加载Spring的时候，不会创建对象，只有在调用getBean方法的时候才会创建。</p></li></ol><h4 id="5-Bean-的生命周期"><a href="#5-Bean-的生命周期" class="headerlink" title="5.Bean 的生命周期"></a>5.Bean 的生命周期</h4><ol><li>生命周期（从创建到销毁的过程）</li></ol><ul><li>创建Bean实例（通过构造器）</li><li>为bean 的属性设置值和对其他bean的引用（调用set方法）</li><li>调用bean 的初始化方法（需在配置文件里面进行配置init-method属性值，方法定义在bean中，在xml文件中使用）</li><li>bean可以使用了，也就是可以获得了。</li><li>当容器关闭的时候，会调用bean销毁的方法（需要进行配置销毁的方法destory-method属性值，方法定义在bean中，在xml文件中使用）</li></ul><h4 id="6-Bean-的后置处理器"><a href="#6-Bean-的后置处理器" class="headerlink" title="6.Bean 的后置处理器"></a>6.Bean 的后置处理器</h4><p>Bean的后置处理器是在上面第5个问题上继续完善的。</p><ul><li>创建Bean实例，（通过构造器）</li><li>为bean 的属性设置值和对其他bean的引用（调用set方法）</li><li><strong>初始化之前 在Bean 的实例传递给Bean的后置处理器（需要在配置文件里面配置处理器，然后配置文件里面的所有bean都会调用前置后置处理器）</strong></li><li>调用bean 的初始化方法（需进行配置）</li><li><strong>把Bean 的实例传递给Bean的后置处理器，</strong>初始化之后。</li><li>bean可以使用了（也就是获取到了bean实例）</li><li>当容器关闭的时候，会调用bean销毁的方法（需要进行配置销毁的方法）</li></ul><p>第三步和第五中种需要创建一个类实现BeanPostProcessor,然后重写此接口中的方法。最后在xml配置文件中进行bean配置，只要是这样写了以后，就在所有xml文件中配置的所有bean都加上第三步和第五步。</p><h4 id="7-xml的自动装配（用的很少）"><a href="#7-xml的自动装配（用的很少）" class="headerlink" title="7.xml的自动装配（用的很少）"></a>7.xml的自动装配（用的很少）</h4><ol><li>什么是自动装配</li></ol><p>在<property>里面设置初始化的值，这是手动装配。</p><p>自动装配：Spring 是根据<strong>属性类型</strong>或者<strong>属性名称</strong>进行自动装配。</p><ol start="2"><li>演示自动装配的过程</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--autowire=&quot;byName&quot; 是根据属性名称找到，实体中属性名字 与 bean中的id 的值名字 要相同 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--autowire=&quot;byType&quot; 是根据类型找到--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;emp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.autowire.Emp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--手动装配--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name=&quot;dept&quot; ref=&quot;dept&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dept&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.Spring5.autowire.Dept&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是根据类型进行注入，但是配置文件中有多个bean，类型相同但是命名不相同，这个时候就会出现问题。就会报错。</p><h4 id="8-外部属性文件（比如数据库连接信息文件）"><a href="#8-外部属性文件（比如数据库连接信息文件）" class="headerlink" title="8.外部属性文件（比如数据库连接信息文件）"></a>8.外部属性文件（比如数据库连接信息文件）</h4><ol><li>直接配置数据库信息</li></ol><ul><li>配置连接池（Druid连接池）</li><li>引入Druid连接池依赖jar包，并把该jar包引入依赖中</li></ul><p>然后在配置文件中引入context名称空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>是为了在xml配置文件中，引入properties文件，然后在properties配置文件中写入数据。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="9-基于注解的方式"><a href="#9-基于注解的方式" class="headerlink" title="9.基于注解的方式"></a>9.基于注解的方式</h4><h5 id="9-1-什么是注解"><a href="#9-1-什么是注解" class="headerlink" title="9.1 什么是注解"></a>9.1 什么是注解</h5><p>注解是特殊标记。格式@注解名称(属性名称= 属性值，属性名称=属性值 ..)</p><h5 id="9-2-哪里可以使用注解"><a href="#9-2-哪里可以使用注解" class="headerlink" title="9.2 哪里可以使用注解"></a>9.2 哪里可以使用注解</h5><p>注解可以在<strong>方法、类上、属性</strong>上都可以加注解</p><h5 id="9-3-为什么用注解？"><a href="#9-3-为什么用注解？" class="headerlink" title="9.3 为什么用注解？"></a>9.3 为什么用注解？</h5><p>为了简化xml配置</p><p>Spring针对Bean管理中创建的对象提供注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Component //普通的注解</span><br><span class="line">@Service //一般用在业务逻辑层</span><br><span class="line">@Controller //一般用在web层（控制层）</span><br><span class="line">@Respository //一般用在持久层（dao层）</span><br></pre></td></tr></table></figure><p>上面的四个注解功能是一样的，都用来创建Bean实例</p><h5 id="9-4-基于注解方式实现对象的创建"><a href="#9-4-基于注解方式实现对象的创建" class="headerlink" title="9.4 基于注解方式实现对象的创建"></a>9.4 基于<strong>注解方式</strong>实现对象的创建</h5><p>第一步：需要引入aop的jar包</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210123103222813.png" alt="image-20210123103222813"></p><p>第二步：开启组建扫描</p><p>在开启组件扫描之前还需要进行引入context名称空间，要是已经引入了就不需要了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组建扫描--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--若扫描多个包，也可以使用,隔开 ，或者扫描父包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lgy.annotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第三步：创建类，在类的上面添加对象注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解里面的value可以不写，默认的是把类名字就是为userService，默认就是创建类名小写的对象。</span></span><br><span class="line"><span class="meta">@Service(value = &quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;UserService.add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一点提醒：</strong>这里是自己配置的过滤器，把默认的过滤器进行了屏蔽，然后这里扫描的是com.lgy.annotation下的标有@Controller注解的类。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--use-default-filters=&quot;false&quot;关闭默认的过滤器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--然后扫描要扫描包下的所有标有 Controller 的注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lgy.annotation&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同理，这是不扫描。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lgy.annotation&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="9-5-基于注解的方式实现属性注入"><a href="#9-5-基于注解的方式实现属性注入" class="headerlink" title="9.5 基于注解的方式实现属性注入"></a>9.5 基于注解的方式实现属性注入</h5><ol><li><strong>@AutoWired</strong>：根据<strong>属性类型</strong>进行自动装配。</li></ol><p>第一步：把Service和dao的对象进行创建，在service和dao类添加创建对象注解</p><p>第二步：在service注入dao对象，在service类中添加dao类型属性，在属性上面使用注解</p><ol start="2"><li>@<strong>Qualifier</strong>：根据<strong>属性名称</strong>进行注入。</li></ol><p>@Qualifier 与 @AutoWired 一起使用</p><p>为什么一起使用？</p><p>举例：比如UserService这个接口可以有多个实现类，，如果有多个实现类，那么类型注入不知道找哪个实现类？这时候我们加入@Qualifier就可以根据名称进行注入。</p><ol start="3"><li>@<strong>Resource</strong>： 可以根据类型注入，可以根据名称注入。</li></ol><p>只有一个@Resource是类型注入，@Resource（name=”userDaoImpl”）,是根据名称进行注入。</p><ol start="4"><li>==@Value== ：注入普通属性类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value=&quot;123&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><h4 id="10-纯（完全）注解开发"><a href="#10-纯（完全）注解开发" class="headerlink" title="10. 纯（完全）注解开发"></a>10. 纯（完全）注解开发</h4><ol><li>创建一个配置类，为了替代xml配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.annotation.config;</span><br><span class="line"><span class="comment">//是为了去除Spring配置文件</span></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">//把当前类变为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.lgy.annotation&quot;&#125;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>编写测试类（之前其他的不变）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Test3</span><span class="params">()</span></span>&#123;    </span><br><span class="line">        <span class="comment">//加载配置类</span></span><br><span class="line">       ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">       UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">       System.out.println(userService);</span><br><span class="line"></span><br><span class="line">       userService.addUserService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是完全注解开发。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h3><p>面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑的各部分之间的耦合度降低，提高程序的可重用行，同时提高开发效率。</p><p><strong>也就是说再不修改源代码的基础上，在主干功能基础上增加新的功能。</strong></p><p>举例：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesCC1B6FF7A3316FB8AD31E1F271947F2A.png" alt="CC1B6FF7A3316FB8AD31E1F271947F2A"></p><ul><li>连接点：在一个类中，哪一个方法能够被增强，那这个方法就叫做连接点</li></ul><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">  add();</span><br><span class="line">  delete();</span><br><span class="line">  update();</span><br><span class="line">  query();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>切入点：<strong>实际</strong>被真正增强的方法叫做切入点（因为并不是所有的连接点都被增强）</p></li><li><p>通知/增强</p><ul><li><strong>实际增强的逻辑的部分</strong>就是通知，比如在add（）方法后加了一个输出语句，那么那个输出语句就是通知</li><li>通知有多种类型<ul><li>前置通知（在执行之前执行）</li><li>后置通知（在执行之后执行）</li><li>环绕通知（前后都执行）</li><li>异常通知（出现异常的时候执行）</li><li>最终通知（不管怎么样，都会执行）</li></ul></li></ul></li><li><p>切面：是动作，是把<strong>通知</strong>应用到<strong>切入点</strong>的过程</p></li></ul><h3 id="AOP底层原理"><a href="#AOP底层原理" class="headerlink" title="AOP底层原理"></a>AOP底层原理</h3><ol><li>AOP底层使用动态代理</li></ol><ul><li>有两种情况的动态代理</li></ul><p>第一种：有接口的情况，使用JDK动态代理</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/images129F5C335BF42EDF428477B6336F26BC.png" alt="129F5C335BF42EDF428477B6336F26BC"></p><p>第二种：没有接口的情况，使用<strong>CGLIB</strong>动态代理</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesEB70BE5F744FAEC3B48B198634757EC8.png" alt="EB70BE5F744FAEC3B48B198634757EC8"></p><h3 id="AOP-JDK动态代理"><a href="#AOP-JDK动态代理" class="headerlink" title="AOP (JDK动态代理)"></a>AOP (JDK动态代理)</h3><ol><li>使用JDK动态代理，使用Proxy类里面的方法创建代理对象,Proxy是 java.lang.reflect.Proxy包下的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数：类的加载器，就是获取被代理类的类的加载器，被代理类是什么加载的，那代理类就用一样的类加载器</span></span><br><span class="line"><span class="comment">//第二个参数：获取被代理类的所有接口，被代理类实现了什么接口，那代理类就实现什么接口。 </span></span><br><span class="line"><span class="comment">//第三个参数：实现这个接口InvocationHander，创建代理对象，写增强的方法</span></span><br><span class="line">Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler)</span><br></pre></td></tr></table></figure><p>反射的时候讲的动态代理代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.java;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 动态代理举例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> LGY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span> 2021-10-04 15:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取信仰</span></span><br><span class="line">    <span class="function">String <span class="title">getBelife</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">implements</span> <span class="title">Human</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBelife</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;i believe i can fly&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃：&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用动态代理，需要解决的问题：</span></span><br><span class="line"><span class="comment"> * 问题一：如何根据加载内存中的被代理类，动态创建一个代理类及其对象</span></span><br><span class="line"><span class="comment"> * 问题二：当通过代理类的对象调用方法时，如何动态调用被代理类中的同名方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回代理类的对象。为了解决问题一</span></span><br><span class="line">    <span class="comment">//返回值Object就是返回的代理类的类型，不能写成具体的某一个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getProxyInstance</span><span class="params">(Object obj)</span></span>&#123;<span class="comment">//被创建的代理类的对象</span></span><br><span class="line">        <span class="comment">//handler作为参数，会自动调用invoke方法</span></span><br><span class="line">        MyInvocationhandler handler = <span class="keyword">new</span> MyInvocationhandler();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个参数：类的加载器，就是获取被代理类的类的加载器，被代理类是什么加载的，那代理类就用一样的类加载器</span></span><br><span class="line">        <span class="comment">//第二个参数：获取被代理类的所有接口，被代理类实现了什么接口，那代理类就实现什么接口。</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationhandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//赋值时，也需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">bind</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a 的功能就声明在invoke()中</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理类要执行的方法，就声明在invoke()中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类对象调用的方法，此方法也就作为被代理类对象要调用的方法</span></span><br><span class="line">        Object returnValue = method.invoke(obj,args);</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SuperMan superMan = <span class="keyword">new</span> SuperMan();</span><br><span class="line">        <span class="comment">//proxyInstance就是代理类的对象</span></span><br><span class="line">        Human proxyInstance = (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        proxyInstance.getBelife();</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="AOP术语-1"><a href="#AOP术语-1" class="headerlink" title="AOP术语"></a>AOP术语</h3><ol><li>连接点</li></ol><p>在一个类里面，==哪些方法可以被增强==，哪些方法就可以被称为==连接点==。</p><ol start="2"><li>切入点</li></ol><p>==实际真正被增强的方法==就被称为切入点。</p><ol start="3"><li>通知（增强）</li></ol><p>比如我们增强一个方法，==实际增强的逻辑部分==就叫做通知。</p><p>通知有多种类型，有5种</p><ul><li>前置通知 （在被增强的方法执行之前会执行）</li><li>后置通知 （在被增强的方法执行之后会执行）</li><li>环绕通知（在被增强的方法执行==之前之后都会执行==）</li><li>异常通知（在被增强的方法==出现异常==会执行）</li><li>最终通知（类似于finally中，一定会被执行）</li></ul><ol start="4"><li>切面</li></ol><p>是一个动作的操作，==把我们的通知应用到切入点的过程==，就叫做切面。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/images35BC5D54C05C329B0B8D5F7E1DB8060A.png" alt="35BC5D54C05C329B0B8D5F7E1DB8060A"></p><h3 id="AOP的操作"><a href="#AOP的操作" class="headerlink" title="AOP的操作"></a>AOP的操作</h3><ol><li>在Spring框架中，一般基于AspectJ 实现 AOP 的操作</li></ol><p>什么是 AspectJ ？</p><p>答：AspectJ不是Spring 的组成部分，独立于AOP框架，一般把 AspectJ 和Spring 框架一起使用，完成AOP操作。</p><ol start="2"><li><p>基于 AspectJ 实现AOP的操作</p><p>(1) 基于XML配置文件的实现</p><p>(2) 基于注解的方式实现（使用）</p></li><li><p>在项目工程中引入AOP项目依赖</p></li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210123170228106.png" alt="image-20210123170228106" style="zoom:50%;" /><p>mvn代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/net.sourceforge.cglib/com.springsource.net.sf.cglib --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sourceforge.cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.net.sf.cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aopalliance/com.springsource.org.aopalliance --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aopalliance<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.aopalliance<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.aspectj/com.springsource.org.aspectj.weaver --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>com.springsource.org.aspectj.weaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>切入点的表达式<ul><li>切入点表达式的作用：知道对哪个类型里面的哪个方法进行增强</li><li>语法结构<ul><li>execution([权限修饰符] [返回类型] [类全路径] [方法名称] ([参数列表])</li></ul></li></ul></li></ol><p>举例1：对com.lgy.dao.BookDao 类里面的 add()方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  * 表示任意的修饰符,返回类型没有没写，参数列表用了(..)</span></span><br><span class="line">execution(* com.lgy.dao.BookDao.add(..))</span><br></pre></td></tr></table></figure><p>举例2：对com.lgy.dao.BookDao 类里面的所有方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* 表示任意的修饰符,返回类型没有没写，参数列表用了(..)</span></span><br><span class="line">execution(* com.lgy.dao.BookDao.*(..))</span><br></pre></td></tr></table></figure><p>举例3：对com.lgy.dao 包里面的所有类及类里面的所有方法进行增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//* 表示任意的修饰符,返回类型没有没写，参数列表用了(..)</span></span><br><span class="line">execution(* com.lgy.dao.*.*(..))</span><br></pre></td></tr></table></figure><p>####AspectJ注解</p><ol><li>创建一个类，在类里面定义一个方法进行增强</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User.add 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建增强类（编写增强逻辑，让不同的方法做不同的通知）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增强的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> </span>&#123;</span><br><span class="line"><span class="comment">//想作为前置通知</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before ..&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>进行通知配置</p><ol><li>在Spring配置文件中，开启注解扫描</li><li>使用注解创建 User 和UserProxy 对象</li><li>在增强类上面增加@Aspect</li><li>在spring配置文件中开启生成代理对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--注意：加入context 和 aop--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启组建扫描--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--若扫描多个包，也可以使用,隔开 ，或者扫描父包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lgy.aop.Annotation&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--开启Aspect生成代理对象--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--这句话的意思就是到要扫描到包里面去找一下哪个类上有 @Aspect 注解，就生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置不同类型的通知</p></li></ol><p>在增强类的里面，在作为通知方法上面添加通知类型的注解，使用切入点表达式进行配置。</p><ol start="5"><li><p>相同的切入点抽取</p></li><li><p>有多个增强类对同一个方法进行增强，设置增强类对优先级</p><p>在增强类上面添加注解 @Order（数字类型的值），值越小优先级越高</p></li></ol><p>完全使用注解配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//把当前类变为配置类，替代xml配置文件</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.lgy.annotation&quot;&#125;)</span> <span class="comment">//开启组件扫描</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AspectJ配置文件（了解）"><a href="#AspectJ配置文件（了解）" class="headerlink" title="AspectJ配置文件（了解）"></a>AspectJ配置文件（了解）</h4><ol><li>创建两个类，一个增强类，一个被增强类，创建方法。</li><li>在spring配置文件中创建两个类对象</li><li>在spring配置文件中配置切入点</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.aop.aopxml.bean.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.aop.aopxml.bean.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"><span class="comment">&lt;!--配置aop的增强--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span> &gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其中切入点id叫 p--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lgy.aop.aopxml.bean.Book.buy(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置增强作用在具体点方法上--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span>s</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><h3 id="JdbcTemplate的概念"><a href="#JdbcTemplate的概念" class="headerlink" title="JdbcTemplate的概念"></a>JdbcTemplate的概念</h3><p>Spring 框架对JDBC进行封装，使用JdbcTemplate方便实现对数据库的操作</p><ol><li>准备工作<ul><li>引入相关依赖</li></ul></li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210125161357017.png" alt="image-20210125161357017" style="zoom:50%;" /><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210125161940389.png" alt="image-20210125161940389" style="zoom:50%;" /><ol start="2"><li>在Spring配置文件里面配置连接池</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><ol start="3"><li>配置JdbcTemplate对象，注入DataSource</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--JdbcTemplate对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>创建service,创建dao，在dao注入JdbcTemplate对象</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.JdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>servcie</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>dao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title">BookDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    注入JdbcTemplate</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate操作数据库"><a href="#JdbcTemplate操作数据库" class="headerlink" title="JdbcTemplate操作数据库"></a>JdbcTemplate操作数据库</h3><p>添加、修改、删除、查询在代码中实现了</p><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><h3 id="事务概念"><a href="#事务概念" class="headerlink" title="事务概念"></a>事务概念</h3><p>事务是数据库操作最基本的单元，指的是==逻辑上的一组操作==，要么都成功，要是有一个失败，所有的操作都失败。</p><p>典型场景：银行转账</p><h3 id="事务特性（ACID特性）"><a href="#事务特性（ACID特性）" class="headerlink" title="事务特性（ACID特性）"></a>事务特性（ACID特性）</h3><ul><li>原子性</li><li>一致性</li><li>隔离型</li><li>持久性</li></ul><p>原子性：要么都成功，要么都失败</p><p>一致性：操作之前，操作之后的总量是不变的。</p><p>隔离型：在多事务操作的时候，他们之间不会相互影响</p><p>持久性：提交以后，一旦改变，就不会再回去了。</p><h3 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h3><h4 id="搭建事务操作环境"><a href="#搭建事务操作环境" class="headerlink" title="搭建事务操作环境"></a>搭建事务操作环境</h4><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesCC8B3520E8581E5CFAA463F13C40F4F1.png" alt="CC8B3520E8581E5CFAA463F13C40F4F1"></p><ol><li><p>创建数据库，添加表。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211014100458305.png" alt="image-20211014100458305"></p></li><li><p>创建service、搭建dao、完成对象相关注入。</p><ul><li>service注入dao，dao中注入JdbcTemplate，在JdbcTemplate中注入DataSource</li></ul></li></ol><p>具体操作见代码：Spring_shangguigu/src/com/lgy/tx包。</p><p>事务操作过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.开启事务</span></span><br><span class="line">            <span class="comment">//2.进行业务操作</span></span><br><span class="line">            <span class="comment">//lucy少100</span></span><br><span class="line">            userDao.reduceMoney();</span><br><span class="line">            <span class="comment">//模拟异常</span></span><br><span class="line">            <span class="keyword">int</span> i= <span class="number">10</span> /<span class="number">0</span>;</span><br><span class="line">            <span class="comment">//mary多100</span></span><br><span class="line">            userDao.addMoney();</span><br><span class="line">            <span class="comment">//3.没有异常，提交事务</span></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//第四步 出现异常，事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Spring事务管理介绍"><a href="#Spring事务管理介绍" class="headerlink" title="Spring事务管理介绍"></a>Spring事务管理介绍</h4><ol><li><p>一般我们把事务会加到Service层（业务逻辑层）</p></li><li><p>在Spring中进行事务操作有两种方式（编程式事务管理和声明式事务管理）</p><p>我们主要是用==声明式事务管理==，</p></li><li><p>声明式事务管理</p><ul><li>基于注解方式</li><li>基于xml配置文件的方式</li></ul></li><li><p>在Spring进行声明式事务管理，底层使用AOP（面向切面）</p></li><li><p>Spring事务管理API</p><ul><li>提供了一个接口==PlatformTransactionManager==，代表事务管理器，这个接口针对不同的框架提供了不同的实现类</li></ul></li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211014134801005.png" alt="image-20211014134801005"></p><h4 id="注解声明式事务管理"><a href="#注解声明式事务管理" class="headerlink" title="注解声明式事务管理"></a>注解声明式事务管理</h4><ol><li>在Spring配置文件中配置事务管理器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--注入数据源，指定对哪个数据库进行数据操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在spring配置文件，开启事务注解</p><p>(1).在spring配置文件引入名称空间tx</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-context.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    (2).开启事务的注解</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在service类上面（获取service类里面方法上面）添加事务注解@Transactional</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span> <span class="comment">//事务注解（可以添加到类上面，也可以添加到方法上面）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accountMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把这个注解添加到类上面，这个类里面所有的方法都添加事务。</p><p>如果是添加到类里面的方法上面，只是为类的方法添加注解。</p><p>事务代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userDao.reduceMoney();</span><br><span class="line"><span class="keyword">int</span> i= <span class="number">10</span> /<span class="number">0</span>;</span><br><span class="line">userDao.addMoney();</span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testaccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;tx.xml&quot;</span>);</span><br><span class="line">UserService userService = context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">userService.accountMoney();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="声明式事务管理参数配置"><a href="#声明式事务管理参数配置" class="headerlink" title="声明式事务管理参数配置"></a>声明式事务管理参数配置</h4><p>@Transactional后面是可以添加参数的</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20211014142651086.png" alt="image-20211014142651086"></p><h5 id="propagation"><a href="#propagation" class="headerlink" title="propagation"></a>propagation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = )</span><span class="comment">//事务的传播行为</span></span><br></pre></td></tr></table></figure><p>事务的传播行为：多事务方法直接进行调用，这个过程中事务是如何进行管理的</p><p>事务方法：对数据库表数据进行变化的操作（查询不算）</p><p>多事务方法就是多张数据</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesFE3D3CE898B8A2E442DE1A726655444C.png" alt="FE3D3CE898B8A2E442DE1A726655444C"></p><p>七种传播行为（只需要掌握前两种）</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/images324B78931CDF13E8E39F5289B0FBDA69.png" alt="324B78931CDF13E8E39F5289B0FBDA69"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation = Propagation.REQUIRED)</span><span class="comment">//不写默认也是它</span></span><br></pre></td></tr></table></figure><h5 id="isolation"><a href="#isolation" class="headerlink" title="isolation"></a>isolation</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = )</span><span class="comment">//事务的隔离级别</span></span><br></pre></td></tr></table></figure><ol><li>事务有一个特性：隔离型，多事务操作之间不会产生影响，不考虑隔离性产生很多问题</li><li>有三个读问题：脏读、不可重复度、虚（幻）读</li></ol><ul><li><p>脏读：就是事务一修改了表中的一行数据，这时候事务二读取了事务一修改后的数据，之后事务一因为某种原因回滚，那么事务二读取的数据就是脏的。</p></li><li><p>不可重复读：一个未提交事务读取到另一提交事务修改数据</p><p>也就是：两个事务读到了相同的数据，但是其中一个修改了数据，并进行了提交，另外一个再次进行读取的时候出现两次读取结果不一样的情况。</p></li><li><p>幻读：一个未提交事务读取到另一个提交事务添加数据</p></li></ul><p>通过设置事务的隔离性就可以解决读的问题</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesBE65CD944AF072FE13B6830250342B6E.png" alt="BE65CD944AF072FE13B6830250342B6E"></p><p>mysql中默认的是第三个隔离级别。</p><h5 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout = )</span><span class="comment">//超时时间</span></span><br></pre></td></tr></table></figure><p>事务需要在一定的时间内进行提交，如果不提交会进行回滚</p><p>timeout默认值为-1，也就是不超时。设置时间以秒为单位</p><h5 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(readOnly = )</span><span class="comment">//是否只读</span></span><br></pre></td></tr></table></figure><p>读：查询操作，写：添加修改删除操作</p><p>readOnly默认值是false，表示可以进行查询，可以添加修改删除操作。</p><p>可以设置true，表示只可以进行查询操作，不能进行修改操作。</p><h5 id="rollbackFor"><a href="#rollbackFor" class="headerlink" title="rollbackFor"></a>rollbackFor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = )</span><span class="comment">//回滚</span></span><br></pre></td></tr></table></figure><p>设置查询哪些异常进行事务回滚</p><h5 id="noRollbackFor"><a href="#noRollbackFor" class="headerlink" title="noRollbackFor"></a>noRollbackFor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(noRollbackFor = )</span><span class="comment">//不回滚</span></span><br></pre></td></tr></table></figure><p>设置出现哪些异常不进行事务回滚</p><h4 id="xml声明式事务管理"><a href="#xml声明式事务管理" class="headerlink" title="xml声明式事务管理"></a>xml声明式事务管理</h4><p>接下来的操作在配置文件==tx1.xml==中设置的</p><ol><li><p>在Spring配置文件中进行配置</p><ol><li><p>配置事务管理器</p></li><li><p>配置通知</p></li><li><p>配置切入点、切面</p></li></ol></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1.事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源，指定对哪个数据库进行数据操作--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务的相关参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定那种规则的方法上添加事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;accountMoney&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.配置切入点还有切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pt&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.lgy.tx.service.UserService.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:pointcut</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="完全注解声明式事务管理"><a href="#完全注解声明式事务管理" class="headerlink" title="完全注解声明式事务管理"></a>完全注解声明式事务管理</h4><ol><li>创建配置类，使用配置类(具体见代码)</li></ol><h2 id="Spring5新特性"><a href="#Spring5新特性" class="headerlink" title="Spring5新特性"></a>Spring5新特性</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><p>@ResponseBody的作用其实是将java对象转为json格式的数据。</p><p>@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据。<br>注意：在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。</p><p>@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】。<br>注意：在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">后台 Controller类中对应的方法：</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(String name, String password, HttpSession session)</span> </span>&#123;</span><br><span class="line">user = userService.checkLogin(name, password);</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JsonResult(user);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RequestBody</span>是作用在形参列表上，用于将前台发送过来固定格式的数据【xml格式 或者 json等】封装为对应的 JavaBean 对象，</span><br><span class="line">封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。</span><br><span class="line">如上面的登录后台代码可以改为：</span><br><span class="line"><span class="meta">@RequestMapping(&quot;/login.do&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> User loginUuser, HttpSession session)</span> </span>&#123;</span><br><span class="line">user = userService.checkLogin(loginUser);</span><br><span class="line">session.setAttribute(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JsonResult(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ssm框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea中遇见的问题</title>
      <link href="2021/01/11/IDEA%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8/"/>
      <url>2021/01/11/IDEA%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<center>止语是上等的智慧，止心是上等的律己</center><a id="more"></a><h3 id="1-Idea忽略文件设置"><a href="#1-Idea忽略文件设置" class="headerlink" title="1. Idea忽略文件设置"></a>1. Idea忽略文件设置</h3><p>（上传git忽略的文件，忽略后不上传也不显示）</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210111170308538.png" alt="image-20210111170308538"></p><h3 id="2-control-h，能显示继承关系"><a href="#2-control-h，能显示继承关系" class="headerlink" title="2. control+h，能显示继承关系"></a>2. control+h，能显示继承关系</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210131113627423.png" alt="image-20210131113627423"></p><h3 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3.快捷键"></a>3.快捷键</h3><table><thead><tr><th>功能描述</th><th>Mac</th><th>Windows</th></tr></thead><tbody><tr><td>显示构造器参数信息</td><td>control+option+m</td><td></td></tr><tr><td>Try/catch</td><td>option+command+z</td><td></td></tr><tr><td>整体上移</td><td>option+上</td><td></td></tr></tbody></table><ul><li>显示构造器参数信息快捷键设置</li></ul><p>Preferences——&gt;key map——&gt;Main menu——&gt;view——&gt;Parameter Info进行设置</p><h3 id="4-关于Debug"><a href="#4-关于Debug" class="headerlink" title="4. 关于Debug"></a>4. 关于Debug</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/images6BDF773FE84A5700A2DB5E4CBB95908E.png" alt="6BDF773FE84A5700A2DB5E4CBB95908E"></p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idea中遇见的问题</title>
      <link href="2021/01/11/idea%E4%B8%AD%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2021/01/11/idea%E4%B8%AD%E9%81%87%E8%A7%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<center>沅有芷兮澧有兰，思公子兮未敢言</center><a id="more"></a><h3 id="问题1-关于项目导入idea不识别module-的问题及解决方法"><a href="#问题1-关于项目导入idea不识别module-的问题及解决方法" class="headerlink" title="问题1. 关于项目导入idea不识别module 的问题及解决方法"></a>问题1. 关于项目导入idea不识别module 的问题及解决方法</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210111164220243.png" alt="image-20210111164220243"></p><p>解决方法：</p><ol><li>右键父项目、选择Open Module Settings.   或者选择Project Structrue</li></ol><ol start="2"><li><p>第三步选择Import Module<img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210111164703630.png" alt="image-20210111164703630" style="zoom:50%;" /></p></li><li><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210111164941255.png" alt="image-20210111164941255"></p></li><li><p>如果是maven项目选择maven，不是就选择第一项，然后一直next<img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210111165025101.png" alt="image-20210111165025101"></p></li><li><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210111165141910.png" alt="image-20210111165141910"></p></li><li><p>遇见错误Error creating bean with name ‘org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping#0’ </p></li></ol><p>情况：确保项目没有错，是因为修改了子模块的名字导致的</p><p>解决方法：找到maven，然后clean后再install，就可以了。</p><ol start="7"><li>修改子模块的名称</li></ol><p>若要是修改子模块的名称，需要修改文件目录还有模块目录，然后在父工程的pom文件夹里面进行修改，然后点击Project Structure进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> Idea </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis复习总结（未完结）</title>
      <link href="2021/01/09/SpringMVC/"/>
      <url>2021/01/09/SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web.html">SpringMVC官网</a></p><p><a href="https://docs.spring.io/spring-framework/docs/4.3.24.RELEASE/spring-framework-reference/">SpringMVC</a></p><p>SSM: spring SpringMVC Mybatis</p><p>MVC三层架构：</p><p>学习过程：</p><p>JavaSE：基础</p><p>JavaWeb：基础</p><p>框架：研究官方文档，锻炼<strong>自学</strong>能力，锻炼笔记能力，锻炼项目能力。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210225204634862.png" alt="image-20210225204634862"></p><p><strong>SpringMVC执行流程:</strong></p><ol><li>用户发送请求至前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</li><li>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器Handler(Controller，也叫页面控制器)。</li><li>Handler执行完成返回ModelAndView</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</li><li>DispatcherServlet响应用户。</li></ol>]]></content>
      
      
      <categories>
          
          <category> ssm框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis复习总结（未完结）</title>
      <link href="2021/01/09/MyBatis/"/>
      <url>2021/01/09/MyBatis/</url>
      
        <content type="html"><![CDATA[<center>技术没有高低之分，只有使用的人有高低之分。</center><center>先把ssm中的MyBatis重新再来一遍！</center><a id="more"></a><p>基础代码github地址：<a href="https://github.com/dllgdxlgy/Mybatis">https://github.com/dllgdxlgy/Mybatis</a></p><p>时间：2020.12.29</p><p>环境：</p><ul><li>JDK 1.8</li><li>Mysql 5.7</li><li>Maven 3.6.1</li><li>IDEA</li></ul><p>回顾：</p><ul><li>JDBC</li><li>Mysql （基本的增删改查）</li><li>Java基础</li><li>Maven</li><li>Junit</li></ul><p>ssm框架学习都需要配置配置文件，都需要看<a href="https://mybatis.org/mybatis-3/zh/index.html">官网文档</a></p><h1 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h1><h2 id="1-1、什么是Mybatis"><a href="#1-1、什么是Mybatis" class="headerlink" title="1.1、什么是Mybatis"></a>1.1、什么是Mybatis</h2><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201229201021860.png" alt="image-20201229201021860" style="zoom:67%;" /><ul><li>MyBatis 是一款优秀的<strong>持久层框架</strong>，</li><li>它支持自定义 SQL、存储过程以及高级映射。</li><li>MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</li><li>MyBatis 可以通过<strong>简单的 XML</strong> 或<strong>注解</strong>来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</li></ul><p>百度百科：</p><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。</p><p>获取Mybatis的方式</p><ul><li>Maven </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>GitHub <a href="https://github.com/search?q=mybatis">github上的mybatis</a></li><li><a href="https://mybatis.org/mybatis-3/zh/index.html#">中文文档</a> </li></ul><h2 id="1-2、什么是持久化"><a href="#1-2、什么是持久化" class="headerlink" title="1.2、什么是持久化"></a>1.2、什么是持久化</h2><ul><li>数据持久化，持久化就是将程序的数据在持状态和顺势状态转化的过程</li><li>内存： <strong>断电即失</strong></li><li>数据库：io文件的持久化</li><li>生活中：冷藏，也是持久化，就是延长保留</li></ul><p><strong>为什么需要持久化？</strong></p><ul><li>有些数据需要保留</li><li>内存太贵</li></ul><h2 id="1-3、持久层"><a href="#1-3、持久层" class="headerlink" title="1.3、持久层"></a>1.3、持久层</h2><p>Dao层，Service层，Controller层</p><ul><li>能完成持久化工作的代码块</li><li>层界限十分明显</li></ul><h2 id="1-4、为什么需要Mybatis"><a href="#1-4、为什么需要Mybatis" class="headerlink" title="1.4、为什么需要Mybatis"></a>1.4、为什么需要Mybatis</h2><ul><li><p>方便</p></li><li><p>传统的JDBC太复杂，简化，框架，自动化</p></li><li><p>帮助我们进行数据保存</p></li><li><p>其实不用Mybatis也可以，现在主流公司都需要进行学习。</p></li></ul><h2 id="1-5、Mybatis特点"><a href="#1-5、Mybatis特点" class="headerlink" title="1.5、Mybatis特点"></a>1.5、Mybatis特点</h2><ul><li>简单易学：本身就很小且简单。没有任何第三方依赖，最简单安装只要两个jar文件+配置几个sql映射文件易于学习，易于使用，通过文档和源代码，可以比较完全的掌握它的设计思路和实现。</li><li>灵活：mybatis不会对应用程序或者数据库的现有设计强加任何影响。 sql写在xml里，便于统一管理和优化。通过sql语句可以满足操作数据库的所有需求。</li><li>解除sql与程序代码的耦合：通过提供DAO层，将业务逻辑和数据访问逻辑分离，使系统的设计更清晰，更易维护，更易单元测试。sql和代码的分离，提高了可维护性。</li><li>提供映射标签，支持对象与数据库的orm字段关系映射</li><li>提供对象关系映射标签，支持对象关系组建维护</li><li>提供xml标签，支持编写动态sql。</li></ul><p><strong>最重要的一点：使用的人多！</strong></p><h1 id="2、第一个Mybatis程序"><a href="#2、第一个Mybatis程序" class="headerlink" title="2、第一个Mybatis程序"></a>2、第一个Mybatis程序</h1><p>思路：搭建环境 –&gt;导入Mybatis –&gt; 编写代码 –&gt;测试</p><h2 id="2-1、搭建环境"><a href="#2-1、搭建环境" class="headerlink" title="2.1、搭建环境"></a>2.1、搭建环境</h2><ol><li>搭建数据库</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USE mybaties;</span><br><span class="line">create table user(</span><br><span class="line"> id INT(20) NOT NULL PRIMARY KEY,</span><br><span class="line"> name VARCHAR(20)DEFAULT NULL,</span><br><span class="line"> pwd VARCHAR(30) DEFAULT NUll</span><br><span class="line">)ENGINE=INNODB DEFAULT charset= utf8;</span><br><span class="line"></span><br><span class="line">insert into user(id,name,pwd) values(1,&#x27;gy&#x27;,&#x27;123&#x27;),(2,&#x27;lgy&#x27;,&#x27;123&#x27;),(3,&#x27;y&#x27;,&#x27;123&#x27;);</span><br></pre></td></tr></table></figure><p>新建项目：</p><ol><li>新建一个普通的maven项目</li><li>删除src目录，就可以当作父工程了。为了能进行创建子工程。</li><li>导入maven依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/junit/junit --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入mybatis--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导入数据库驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.45<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2、创建一个模块"><a href="#2-2、创建一个模块" class="headerlink" title="2.2、创建一个模块"></a>2.2、创建一个模块</h2><p>new一个model，然后</p><ul><li>编写mybatis的核心配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--可以配置多个环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/BlogMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写mybatis的工具类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写mybatis的工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">mybatisUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取mybatis的sqlSessionFactory对象</span></span><br><span class="line">            String resource = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2-3、编写代码"><a href="#2-3、编写代码" class="headerlink" title="2.3、编写代码"></a>2.3、编写代码</h2><ul><li>编写实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String pwd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPwd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPwd</span><span class="params">(String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name, String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.pwd = pwd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>然后写Dao接口 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.dao;</span><br><span class="line"><span class="keyword">import</span> com.lgy.pojo.User;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>最后写实现类(由原来的UserDaoImpl转换为Mapper配置文件)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--namespace绑定一个对应的Dao/Mapper接口,就相当于之前实现了接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lgy.dao.userDao&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--查询语句--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id对应着方法名字，因为之前需要写一个实现类进行实现userDao，这里没有实现，</span></span><br><span class="line"><span class="comment">    只是写了一个配置文件，实现类要重写之前的方法，但是这里没有重写，只是用select标签代替了--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--resultType要写他的全类名，这是返回类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lgy.pojo.User&quot;</span> &gt;</span></span><br><span class="line">    select * from mybatis.user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4、测试"><a href="#2-4、测试" class="headerlink" title="2.4、测试"></a>2.4、测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lgy.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lgy.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.lgy.utils.mybatisUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取sqlsession对象</span></span><br><span class="line">        SqlSession sqlSession = mybatisUtils.getSqlSession();</span><br><span class="line">        <span class="comment">//执行SQl</span></span><br><span class="line">        userDao userDao = sqlSession.getMapper(userDao.class);</span><br><span class="line">        List&lt;User&gt; userList = userDao.getUserList();</span><br><span class="line">        <span class="keyword">for</span> (User user:userList)&#123;</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭SqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可能遇见的问题</p><ul><li>配置文件没有注册</li><li>绑定接口错误</li><li>方法名不对</li><li>返回类型不对</li><li>maven导出资源问题</li></ul><h1 id="3、CRUD"><a href="#3、CRUD" class="headerlink" title="3、CRUD"></a>3、CRUD</h1><p>namespace里面的包名要和接口的包名一致</p><ol><li><p>select 选择语句</p><ul><li>id：就是对应的namespace里面的方法名</li><li>resultset： 就是结果的返回值</li><li>parameterType：参数类型</li></ul></li><li><p>insert</p></li><li><p>update</p></li><li><p>delete</p></li></ol><p>流程：<strong>编写接口—&gt;写Mapper里面的sql语句—&gt;测试</strong>。 <strong>增删改需要提交事务</strong></p><ol start="5"><li>万能的map</li></ol><p><strong>问题描述</strong>：如果要是传递一个实体类，比如进行修改密码，只传一个id和密码就可以， 其他的信息不需要，而进行传递一个实体类很麻烦，还带有其他信息，这时候需要map就可以， 需要什么信息直接穿进去，而且名字可以随意起，只要在mapper里面用对就可以。如果实体类中的字段或者参数过多，可以使用map。</p><h1 id="4、配置解析"><a href="#4、配置解析" class="headerlink" title="4、配置解析"></a>4、配置解析</h1><h2 id="4-1、核心配置文件"><a href="#4-1、核心配置文件" class="headerlink" title="4.1、核心配置文件"></a>4.1、核心配置文件</h2><ul><li>Mybatis-config.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">properties（属性）</span><br><span class="line">settings（设置）</span><br><span class="line">typeAliases（类型别名）</span><br><span class="line">typeHandlers（类型处理器）</span><br><span class="line">objectFactory（对象工厂）</span><br><span class="line">plugins（插件）</span><br><span class="line">environments（环境配置）</span><br><span class="line">environment（环境变量）</span><br><span class="line">transactionManager（事务管理器）</span><br><span class="line">dataSource（数据源）</span><br><span class="line">databaseIdProvider（数据库厂商标识）</span><br><span class="line">mappers（映射器）</span><br></pre></td></tr></table></figure><h2 id="4-2、环境配置"><a href="#4-2、环境配置" class="headerlink" title="4.2、环境配置"></a>4.2、环境配置</h2><p>可以配置多套环境</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--事务管理器--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--默认是有数据库连接池的--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis? useSSL=true<span class="symbol">&amp;amp;</span>useUnicode=true<span class="symbol">&amp;amp;</span>characterEncoding=UTF-8&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">           <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-3、属性"><a href="#4-3、属性" class="headerlink" title="4.3、属性"></a>4.3、属性</h2><p>除了上面的代码直接写入数据库连接信息，还可进行配置文件的配置</p><p>db.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#这里面参数连接不需要进行&amp;amp;</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><p>在核心配置文件中引用</p><p>遇到的问题：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210104102832311.png" alt="image-20210104102832311"></p><p>这里面规定了配置文件中标签的顺序，所以不能乱了顺序写。</p><p>引用后</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--引入外部配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;db.properties&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里面还可以进行写其他属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以直接引入外部配置文件</li><li>也可以在其中mybatis-config.xml 的properties文件中增加配置</li><li>如果两个文件有同一个字段，优先使用配置文件的中属性。</li></ul><h2 id="4-4、别名"><a href="#4-4、别名" class="headerlink" title="4.4、别名"></a>4.4、别名</h2><p>起别名就是就是为了在XXXMapper.xml文件中的result类型中使用更方便，但是要注意在mybatis-config.xml文件的要正确使用<typeAliases>标签。</p><p>有两种使用方式，第一种，直接指定某一个实体类</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">&quot;com.lgy.pojo.User&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeAlias</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种：可以指定某一个包名，Mybatis会自动扫描该包下的 java Bean,默认别名就是实体类的小写格式。</p><p>使用情况：</p><ul><li>在实体类比较少的时候可以使用第一种，这种就是比较简单，而且能够进行自己定义</li><li>如果要使用第二种且要进行自己定义，不使用他默认的格式，可以添加@alias注解。</li></ul><h2 id="4-5、设置"><a href="#4-5、设置" class="headerlink" title="4.5、设置"></a>4.5、设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里只注意mapUnderscoreToCamelCase就可以了。</p><h2 id="4-6、映射器"><a href="#4-6、映射器" class="headerlink" title="4.6、映射器"></a>4.6、映射器</h2><p>方式一：<strong>使用相对于类路径的资源引用</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用相对于类路径的资源引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/lgy/dao/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>方式二：使用class文件进行绑定</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用映射器接口实现类的完全限定类名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.pojo.UserMapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>接口和他的Mapper配置文件必须相同</li><li>接口和他的配置文件必须在同一个包下</li></ul><p>方式三：使用扫描包进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.lgy.pojo&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>接口和他的Mapper配置文件必须相同</li><li>接口和他的配置文件必须在同一个包下</li></ul><h1 id="5、解决属性名和字段名不一致的问题"><a href="#5、解决属性名和字段名不一致的问题" class="headerlink" title="5、解决属性名和字段名不一致的问题"></a>5、解决属性名和字段名不一致的问题</h1><p>数据库的字段名</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210104152441089.png" alt="image-20210104152441089" style="zoom:50%;" /><p>实体类的属性名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure><p>但是查出来password显示为空</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210104154030017.png" alt="image-20210104154030017"></p><p>解决方法1：在xml文件的相应sql中进行修改，</p><p>解决方法2: resultMap（结果集映射）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--resultMap--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- resultMap中的id与&lt;select&gt;标签里面的resultMap里面的值要一样，要代表引用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;usermap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--column代表数据库中字段，property代表实体类中的属性--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span>  <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lgy.pojo.User&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;usermap&quot;</span>&gt;</span></span><br><span class="line">  select * from mybatis.user where id = #&#123;id&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6、日志"><a href="#6、日志" class="headerlink" title="6、日志"></a>6、日志</h1><h2 id="6-1、日志工厂"><a href="#6-1、日志工厂" class="headerlink" title="6.1、日志工厂"></a>6.1、日志工厂</h2><p>如果数据库操作出现了异常，我们需要排错，日志就是最好的助手！这里使用日志工厂</p><p>只需要在mybatis-config.xml文件里显示添加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">settings&gt;</span><br><span class="line"><span class="comment">&lt;!--注意name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;不要有空格--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210104203938105.png" alt="image-20210104203938105"></p><h2 id="6-2、Log4j"><a href="#6-2、Log4j" class="headerlink" title="6.2、Log4j"></a>6.2、Log4j</h2><ol><li>导入Log4j依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入log4j依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在resources中创建log4j.properties文件并写入：</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里是日志输出的位置</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">DEBUG,console,file</span></span><br><span class="line"><span class="meta">log4j.additivity.org.apache</span>=<span class="string">true</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.Threshold</span>=<span class="string">INFO</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d %p [%c,%L] - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#log4j.appender.logfile.encoding=UTF-8</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile=org.apache.log4j.RollingFileAppender</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile.File=$&#123;lms.root&#125;/WEB-INF/logs/lms.log</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile.MaxFileSize=512KB</span></span><br><span class="line"><span class="comment"># Keep three backup files.</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile.MaxBackupIndex=3</span></span><br><span class="line"><span class="comment"># Pattern to output: date priority [category] - message</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile.layout=org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="comment">#log4j.appender.logfile.layout.ConversionPattern=%d %p [%c,%L] - %m%n</span></span><br><span class="line"></span><br><span class="line"><span class="meta">log4j.logger.orga.mybatis</span>=<span class="string">DEBUG</span></span><br><span class="line"><span class="meta">log4j.logger.org.springframework</span>=<span class="string">INFO</span></span><br><span class="line"><span class="meta">log4j.logger.com.opensymphony.xwork2</span>=<span class="string">INFO</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.struts2</span>=<span class="string">INFO</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在mybatis-config.xml文件中配置</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里LOG4J必须大写--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;LOG4J&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">setting</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="4"><li><p>Log4j的使用</p><ol><li>在要使用Log4j类中导入包</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br></pre></td></tr></table></figure><ol start="2"><li>日志对象，参数为当前类的class</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Logger logger = Logger.getLogger(UserDaoTest.class);</span><br></pre></td></tr></table></figure><ol start="3"><li>日志级别 info、debug、error</li></ol></li></ol><h1 id="7、分页"><a href="#7、分页" class="headerlink" title="7、分页"></a>7、分页</h1><h2 id="7-1使用limit分页"><a href="#7-1使用limit分页" class="headerlink" title="7.1使用limit分页"></a>7.1使用limit分页</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> limitstartIndex,pageMax;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="number">0</span>,<span class="number">2</span>;  </span><br></pre></td></tr></table></figure><p>使用mybatis实现分页，核心就是使用sql</p><ol><li>接口</li><li>MapperXml</li><li>测试</li></ol><h2 id="7-2使用mybatis插件实现分页"><a href="#7-2使用mybatis插件实现分页" class="headerlink" title="7.2使用mybatis插件实现分页"></a>7.2使用mybatis插件实现分页</h2><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210106140128103.png" alt="image-20210106140128103" style="zoom:50%;" /><p><a href="https://pagehelper.github.io/">mybatis插件</a></p><h1 id="8、使用注解开发"><a href="#8、使用注解开发" class="headerlink" title="8、使用注解开发"></a>8、使用注解开发</h1><p>使用mybatis大多数使用配置文件，而是用其他的是使用注解的方式</p><h2 id="8-1、面向接口编程"><a href="#8-1、面向接口编程" class="headerlink" title="8.1、面向接口编程"></a>8.1、面向接口编程</h2><p>面向接口编程的根本原因就是为了<strong>解耦</strong>，是定义与实现的分离。</p><h2 id="8-2、使用注解开发"><a href="#8-2、使用注解开发" class="headerlink" title="8.2、使用注解开发"></a>8.2、使用注解开发</h2><p>使用注解对于简单的可以去写，但是对于有些繁杂的还是需要进行xml文件配置。</p><ol><li>注解在接口上的实现</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注解就是简化开发的作用</span></span><br><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ol start="2"><li>需要在核心配置文件中绑定</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--之前是绑定配置文件，这里是进行绑定接口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">&quot;com.lgy.dao.userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>测试</li></ol><p>实现本质：反射</p><p>底层：动态代理</p><h2 id="8-3、基于注解的CRUD"><a href="#8-3、基于注解的CRUD" class="headerlink" title="8.3、基于注解的CRUD"></a>8.3、基于注解的CRUD</h2><ol><li>可以设置自动提交事务(可不做)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//true代表着自动提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写接口</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">userDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注解就是简化开发的作用</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里本应该就一个参数id，但是由多个参数的时候一定要使用 @Param 注解，@Param 里面的id对应于sql语句里面的#&#123;id&#125;</span></span><br><span class="line">    <span class="meta">@Select(&quot;select *from user where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="keyword">int</span> id,<span class="meta">@Param(&quot;String&quot;)</span> String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入数据</span></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user (id,name,pwd) values (#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>编写测试类</li></ol><h1 id="9、Lombok"><a href="#9、Lombok" class="headerlink" title="9、Lombok"></a>9、Lombok</h1><p>Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.<br>Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.</p><p>翻译：Lombok项目是一个Java库，它会自动插入您的编辑器和构建工具中，从而使您的Java更加生动有趣。永远不要再写另一个getter或equals方法，带有一个注释的您的类有一个全功能的生成器，自动化您的记录变量，等等。</p><p>说白了就是写bean更方便了。</p><ol><li><p>首先需要在idea里面进行插件的安装</p><p>preferences –&gt;plugins,进行搜索Lombok插件，然后选择进行安装。</p></li><li><p>在项目中导入Lombok的包，如果使用maven直接在maven仓库里面进行搜索。</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>可以加注解进行使用</li></ol><p>可以使用的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Getter and @Setter</span><br><span class="line">@FieldNameConstants</span><br><span class="line">@ToString</span><br><span class="line">@EqualsAndHashCode</span><br><span class="line">@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor</span><br><span class="line">@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog</span><br><span class="line">@Data</span><br><span class="line">@Builder</span><br><span class="line">@SuperBuilder</span><br><span class="line">@Singular</span><br><span class="line">@Delegate</span><br><span class="line">@Value</span><br><span class="line">@Accessors</span><br><span class="line">@Wither</span><br><span class="line">@With</span><br><span class="line">@SneakyThrows</span><br><span class="line">@val</span><br><span class="line">@var</span><br><span class="line">experimental @var</span><br><span class="line">@UtilityClass</span><br><span class="line">Lombok config system</span><br><span class="line">Code inspections</span><br><span class="line">Refactoring actions (lombok and delombok)</span><br></pre></td></tr></table></figure><p>@Data : 生成无参构造，get、set、toString、hashcode、equals。</p><ol start="4"><li>举例子</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span> </span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> Grage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="10、多对一"><a href="#10、多对一" class="headerlink" title="10、多对一"></a>10、多对一</h1><p>举例：一个老师对应多个学生，多个学生对应（关联）一个老师。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210115115059452.png" alt="image-20210115115059452" style="zoom: 50%;" /><p>关于XXXMapper.xml文件模版：</p><p>只需要改动是把mybatis 的核心配置文件，把configuration换为mapper，然后把config换为mapper即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XXXMapper.xml文件模版</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--核心配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="10-1、测试环境搭建"><a href="#10-1、测试环境搭建" class="headerlink" title="10.1、测试环境搭建"></a>10.1、测试环境搭建</h2><ol><li>导入Lombok</li><li>创建实体类Teacher，Student</li><li>建立Mapper接口</li><li>建立Mapper.xml文件</li><li>在核心配置文件中绑定注册我们的Mapper接口或者文件</li><li>测试查询是否成功</li></ol><h2 id="10-2、查询处理"><a href="#10-2、查询处理" class="headerlink" title="10.2、查询处理"></a>10.2、查询处理</h2><h3 id="12-2-1、按照嵌套查询处理"><a href="#12-2-1、按照嵌套查询处理" class="headerlink" title="12.2.1、按照嵌套查询处理"></a>12.2.1、按照嵌套查询处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.lgy.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;select id=&quot;getStudent&quot; resultType=&quot;com.lgy.pojo.Student&quot;&gt;--&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--select * from student--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/select&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">     select * from student</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lgy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property实体 column 对应数据库--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--复杂的属性 进行单独处理--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--对象的时候使用--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;association property=&quot;&quot;&gt;&lt;/association&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--集合的时候使用--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;collection property=&quot;&quot;&gt;&lt;/collection&gt;        --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--javaType 对应的 Teacher 类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lgy.pojo.Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacher&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lgy.pojo.Teacher&quot;</span>&gt;</span></span><br><span class="line">        select * from teacher where id = #&#123;id&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="10-2-2、按照结果查询处理"><a href="#10-2-2、按照结果查询处理" class="headerlink" title="10.2.2、按照结果查询处理"></a>10.2.2、按照结果查询处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--按照结果查询处理--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher2&quot;</span>&gt;</span></span><br><span class="line">      select s.id sid,s.name sname ,t.name tname from student s, teacher t  where s.tid = t.id</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lgy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.lgy.pojo.Teacher&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="11、一对多"><a href="#11、一对多" class="headerlink" title="11、一对多"></a>11、一对多</h1><ul><li>一个老师教多个学生，对于老师而言，是1对多</li></ul><h2 id="11-1、查询处理"><a href="#11-1、查询处理" class="headerlink" title="11.1、查询处理"></a>11.1、查询处理</h2><h3 id="11-1-1、按照结果查询处理"><a href="#11-1-1、按照结果查询处理" class="headerlink" title="11.1.1、按照结果查询处理"></a>11.1.1、按照结果查询处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;st&quot;</span>&gt;</span></span><br><span class="line">       select s.id sid, s.name sname, t.name tname,t.id tid from</span><br><span class="line">       student s, teacher t where s.tid=t.id and t.id = #&#123;tid&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;st&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lgy.pojo.Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--集合用collection--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--javaType 是指定属性的类型，所以这里不行写com.lgy.pojo.Student,因为是集合，这里使用ofType--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.lgy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="11-1-2、按照查询嵌套处理"><a href="#11-1-2、按照查询嵌套处理" class="headerlink" title="11.1.2、按照查询嵌套处理"></a>11.1.2、按照查询嵌套处理</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--子查询--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher2&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line">       select * from teacher where id = #&#123;tid&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;ts&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.lgy.pojo.Teacher&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span>  <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.lgy.pojo.Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudentByTeacherId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.lgy.pojo.Student&quot;</span>&gt;</span></span><br><span class="line">       select  *from student where tid = #&#123;tid&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>javaType 用来指定实体类中的类型</li><li>ofType 用来指定映射到List或者集合中的pojo类型，范型中的约束类型</li></ul><h1 id="12、动态SQL"><a href="#12、动态SQL" class="headerlink" title="12、动态SQL"></a>12、动态SQL</h1><p>什么是动态sql：<strong>动态sql就是指根据不同的条件生成不同的sql语句</strong>    见官网</p><h1 id="13、缓存（了解）"><a href="#13、缓存（了解）" class="headerlink" title="13、缓存（了解）"></a>13、缓存（了解）</h1><h2 id="13-1、简介"><a href="#13-1、简介" class="headerlink" title="13.1、简介"></a>13.1、简介</h2><p>什么是缓存【Cache】：</p><ul><li>缓存是存在内存中的临时数据</li><li>将用户经常用的数据存放在缓存（内存）中，用户去查询数据就不用从磁盘上进行查询，而是直接在缓存中进行查询。</li></ul><p>为什么使用缓存：</p><ul><li>能够提高查询速度，节省时间，能解决高并发系统的性能问题。</li></ul><p>什么样的数据能够使用缓存：</p><ul><li>经常查询，并且经常使用的数据。</li><li>不经常修改。</li></ul><h2 id="13-2-Mybatis缓存"><a href="#13-2-Mybatis缓存" class="headerlink" title="13.2 Mybatis缓存"></a>13.2 Mybatis缓存</h2>]]></content>
      
      
      <categories>
          
          <category> ssm框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的工具</title>
      <link href="2021/01/08/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
      <url>2021/01/08/%E5%A5%BD%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<center>其他的路都不会获取真正的自由，唯有自身这条路没有堵死，所以...全靠自己。</center><a id="more"></a><ol><li>好用的链接：<a href="https://www.guoxingjun.com/">小蜜蜂工具</a></li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210108115439868.png" alt="image-20210108115439868"></p><ol start="2"><li>比较好用的电子书下载网站<a href="https://www.jiumodiary.com/">鸠摩搜书</a></li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20210109124906150.png" alt="image-20210109124906150" style="zoom:50%;" /><ol start="3"><li>在线画图软件：<a href="https://www.processon.com/">Process On</a></li></ol><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210115093826228.png" alt="image-20210115093826228"></p><ol start="4"><li>可以下载音乐的网站</li></ol><p><a href="http://www.333ttt.com/">http://www.333ttt.com/</a></p><ol start="5"><li><a href="https://whoer.net/zh">检查自己的ip地址和DNS地址</a></li></ol><p>判断翻墙的信息</p><ol start="6"><li>激活Jetbrains全家桶网站vrg123.com</li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用于图的半监督学习的图随机神经网络</title>
      <link href="2020/11/27/%E7%94%A8%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E9%9A%8F%E6%9C%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>2020/11/27/%E7%94%A8%E4%BA%8E%E5%9B%BE%E7%9A%84%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%9B%BE%E9%9A%8F%E6%9C%BA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C--%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<center>总体来说，没有什么迫在眉睫一定要得到的东西。这一路上也不曾感觉有所失去。所以，我是一个幸福的人!</center><a id="more"></a><h2 id="题目：用于图的半监督学习的图随机神经网络"><a href="#题目：用于图的半监督学习的图随机神经网络" class="headerlink" title="题目：用于图的半监督学习的图随机神经网络"></a>题目：用于图的半监督学习的图随机神经网络</h2><p><strong>摘要</strong>：研究了图的半监督学习问题，然而GNN存在许多缺点，过度平滑，鲁棒性差（也就是不稳定）标记节点稀缺时泛化能力一般，本论文提出了一个GRAND框架，能有效解决这些问题。</p><p>怎么解决：</p><ol><li>设计随机传播策略来实现图数据的扩展</li><li>然后利用一致性正则化来优化未标记节点在不同数据扩展中的预测一致性。</li></ol><p>结果：在半监督分类上面，此方法比GNN好。</p><p><img src="image-20210315191146422.png" alt="image-20210315191146422"></p><p>GNN：确定性传播，GRAND：不确定性传播</p><p><strong>介绍</strong>：本篇论文的目的是”能有效预测一个给定图中只有一小部分标记节点的未标记节点的类别“</p><p>设计思想：思想是设计一种传播策略来随机生成多个图，进行数据扩充，在此基础上提出一种一致性正则化训练来提高半监督设置下的泛化能力。</p><p>提的问题</p><p>关于激活函数：</p><p>什么是激活函数，有哪几种激活函数，他们的作用是什么？使用不同的激活函数有什么样的效果？</p><ol><li><p>激活函数的引入是为了增加神经网络模型的非线性，没有激活函数每层就相当于矩阵相乘。每一层输出都是上层的输入的线性函数，无论神经网络多少层，输出都是输入的线性组合，就是最原始的感知机</p></li><li><p>加入激活函数，给神经元引入非线性因素，神经网络可以任意逼近任何非线性函数，这样神经网络就可以应用到众多的非线性模型中。</p></li></ol><p>ReLU函数，还有sigmod激活函数、tanh激活函数，除了ReLU激活函数，还有其变形ELU函数和PReLU函数。<a href="https://blog.csdn.net/tian_panda/article/details/82113203?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">链接</a></p><p>文中使用ReLU激活函数的作用是：1. 克服梯度消失的问题 2. 能加快训练速度。</p><h2 id="题目：推荐系统的知识图卷积网络"><a href="#题目：推荐系统的知识图卷积网络" class="headerlink" title="题目：推荐系统的知识图卷积网络"></a>题目：推荐系统的知识图卷积网络</h2><p>一般推荐系统：基于协同过滤的，缺点就是稀疏性与冷启动问题</p><p>而知识图卷积网络：是挖掘相关属性来捕获实体间的隐藏关系。</p><p>目的：是为了发现知识图谱的高阶结构信息和语意信息</p><p>思想：我们从知识图谱中每个实体的邻居那里取样，作为他们能够接受的属性，然后在计算给定实体的表示时，将邻居信息与偏差结合起来。</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20210316093255041.png" alt="image-20210316093255041"></p><p>KGCN的目的：是为了捕获高阶结构的邻近性</p><p>之所以去掉一部分邻居，是因为显示生活中，关系可能太多，这里是直接取半。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-143-重排链表</title>
      <link href="2020/10/20/LeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/"/>
      <url>2020/10/20/LeetCode-143-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ，<br>将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><a id="more"></a><p>示例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure><p>实例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure><p>解题思路：</p><p>如果是直接去把L<del>n</del>取出来添加到L<del>1</del>下，不仅第一次需要遍历整个链表，第二次还需要遍历，很麻烦，很浪费时间。</p><p>我们不如直接把整个链表遍历一遍，放在List里面（跟数组一样），然后定义两个整数，一个在前面，一个在后面，把后面的数添加到前面的数的后面，然后前面的加，后面的减。直到最后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//存到 list 中去</span></span><br><span class="line">    List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        list.add(head);</span><br><span class="line">        head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头尾指针依次取元素</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = list.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        list.get(i).next = list.get(j);</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">//偶数个节点的情况，会提前相遇</span></span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(j).next = list.get(i);</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    list.get(i).next = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)<em>O</em>(<em>N</em>)，其中 N<em>N</em> 是链表中的节点数。</li><li>空间复杂度：O(N)<em>O</em>(<em>N</em>)，其中 N<em>N</em> 是链表中的节点数。主要为线性表的开销。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebStorm常用快捷键</title>
      <link href="2020/10/17/WebStorm%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>2020/10/17/WebStorm%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<center>一天 24 小时。学习 24 小时，休息 24 小时。</center><a id="more"></a><p>file —&gt;Setting—&gt;Keymap  例如：搜索duplicate即可找到关于复制的快捷键设置，双击设置。</p><table><thead><tr><th>操作</th><th>快捷键</th><th>备注</th></tr></thead><tbody><tr><td>复制当前行并粘贴到下一行（windows）</td><td>Ctrl+D</td><td></td></tr><tr><td>快速上移一行</td><td>shift+Alt+上</td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebStorm </tag>
            
            <tag> 快捷键 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac安装brew</title>
      <link href="2020/10/15/mac%E5%AE%89%E8%A3%85brew/"/>
      <url>2020/10/15/mac%E5%AE%89%E8%A3%85brew/</url>
      
        <content type="html"><![CDATA[<center>一人为轴，一人悬空～</center><a id="more"></a><p>mac上执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/zsh -c <span class="string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></span><br></pre></td></tr></table></figure><p>就完美解决～</p><p>以下是我的安装过程～</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">Last login: Thu Oct <span class="number">15</span> <span class="number">14</span>:<span class="number">17</span>:<span class="number">49</span> on ttys000</span><br><span class="line">LGYdeMacBook-Pro:~ lvguangyue$ brew search wget</span><br><span class="line">-bash: brew: command not found</span><br><span class="line">LGYdeMacBook-Pro:~ lvguangyue$ ruby -e “$（curl -fsSL /homebrew/go“</span><br><span class="line">ruby: invalid option -f  (-h will show valid options) (RuntimeError)</span><br><span class="line">LGYdeMacBook-Pro:~ lvguangyue$ /bin/zsh -c <span class="string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span></span><br><span class="line"></span><br><span class="line">              开始执行Brew自动安装程序</span><br><span class="line">             [cunkai.wang@foxmail.com]</span><br><span class="line">           [<span class="number">2020</span><span class="number">-10</span><span class="number">-15</span> <span class="number">14</span>:<span class="number">22</span>:<span class="number">57</span>][<span class="number">10.13</span>]</span><br><span class="line">       https:<span class="comment">//zhuanlan.zhihu.com/p/111014448</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">请选择一个下载镜像，例如中科大，输入<span class="number">1</span>回车。</span><br><span class="line">源有时候不稳定，如果git克隆报错重新运行脚本选择源。cask非必须，有部分人需要。</span><br><span class="line"><span class="number">1</span>、中科大下载源 <span class="number">2</span>、清华大学下载源 <span class="number">3</span>、北京外国语大学下载源 <span class="number">4</span>、腾讯下载源（不显示下载进度） <span class="number">5</span>、阿里巴巴下载源(缺少cask源)</span><br><span class="line">请输入序号: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  你选择了中国科学技术大学下载源</span><br><span class="line"></span><br><span class="line">！！！此脚本将要删除之前的brew(包括它下载的软件)，请自行备份。</span><br><span class="line">-&gt;是否现在开始执行脚本（N/Y）y</span><br><span class="line"></span><br><span class="line">--&gt; 脚本开始执行</span><br><span class="line">==&gt; 通过命令删除之前的brew、创建一个新的Homebrew文件夹</span><br><span class="line">(设置开机密码：在左上角苹果图标-&gt;系统偏好设置-&gt;<span class="string">&quot;用户与群组&quot;</span>-&gt;更改密码)</span><br><span class="line">(如果提示This incident will be reported. 在<span class="string">&quot;用户与群组&quot;</span>中查看是否管理员)</span><br><span class="line">请输入开机密码，输入过程不显示，输入完后回车</span><br><span class="line">Password:</span><br><span class="line">开始执行</span><br><span class="line">-&gt; 创建文件夹 /usr/local/Homebrew</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/Caskroom</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/Cellar</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/<span class="keyword">var</span>/homebrew</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/etc</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/sbin</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/opt</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/share/zsh</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/share/zsh/site-functions</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/<span class="keyword">var</span>/homebrew/linked</span><br><span class="line">此步骤成功</span><br><span class="line">-&gt; 创建文件夹 /usr/local/Frameworks</span><br><span class="line">此步骤成功</span><br><span class="line">git version <span class="number">2.23</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">下载速度觉得慢可以ctrl+c或control+c重新运行脚本选择下载源</span><br><span class="line">==&gt; 克隆Homebrew基本文件(<span class="number">32</span>M+)</span><br><span class="line"></span><br><span class="line">未发现Git代理（属于正常状态）</span><br><span class="line">Cloning into <span class="string">&#x27;/usr/local/Homebrew&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">164328</span>, done.</span><br><span class="line">remote: Total <span class="number">164328</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">164328</span>/<span class="number">164328</span>), <span class="number">40.57</span> MiB | <span class="number">2.42</span> MiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">122161</span>/<span class="number">122161</span>), done.</span><br><span class="line">此步骤成功</span><br><span class="line">==&gt; 创建brew的替身</span><br><span class="line">此步骤成功</span><br><span class="line">==&gt; 克隆Homebrew Core(<span class="number">224</span>M+) </span><br><span class="line">此处如果显示Password表示需要再次输入开机密码，输入完后回车</span><br><span class="line">Cloning into <span class="string">&#x27;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">806194</span>, done.</span><br><span class="line">remote: Total <span class="number">806194</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">806194</span>/<span class="number">806194</span>), <span class="number">320.67</span> MiB | <span class="number">2.25</span> MiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">541877</span>/<span class="number">541877</span>), done.</span><br><span class="line">Updating files: <span class="number">100</span>% (<span class="number">5552</span>/<span class="number">5552</span>), done.</span><br><span class="line">此步骤成功</span><br><span class="line">==&gt; 克隆Homebrew Cask(<span class="number">248</span>M+) 类似AppStore </span><br><span class="line">此处如果显示Password表示需要再次输入开机密码，输入完后回车</span><br><span class="line">Cloning into <span class="string">&#x27;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-cask&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: <span class="number">485405</span>, done.</span><br><span class="line">remote: Total <span class="number">485405</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)B | <span class="number">2.42</span> MiB/s</span><br><span class="line">Receiving objects: <span class="number">100</span>% (<span class="number">485405</span>/<span class="number">485405</span>), <span class="number">220.07</span> MiB | <span class="number">2.23</span> MiB/s, done.</span><br><span class="line">Resolving deltas: <span class="number">100</span>% (<span class="number">345258</span>/<span class="number">345258</span>), done.</span><br><span class="line">此步骤成功</span><br><span class="line">==&gt; 配置国内镜像源HOMEBREW BOTTLE</span><br><span class="line">此步骤成功</span><br><span class="line"></span><br><span class="line">==&gt; 安装完成，brew版本</span><br><span class="line"></span><br><span class="line">检测到你不是最新系统，会有一些报错，请稍等Ruby下载安装;</span><br><span class="line">    </span><br><span class="line">brew -v</span><br><span class="line"></span><br><span class="line">==&gt; Downloading https:<span class="comment">//mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles-portable-ruby/portable-ruby-2.6.3_2.yosemite.bottle.tar.gz</span></span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">==&gt; Pouring portable-ruby<span class="number">-2.6</span><span class="number">.3</span>_2.yosemite.bottle.tar.gz</span><br><span class="line">Homebrew <span class="number">2.5</span><span class="number">.6</span><span class="number">-41</span>-g8aa6502-dirty</span><br><span class="line">Homebrew/homebrew-core (git revision a7549a; last commit <span class="number">2020</span><span class="number">-10</span><span class="number">-15</span>)</span><br><span class="line">Homebrew/homebrew-cask (git revision <span class="number">499</span>c7; last commit <span class="number">2020</span><span class="number">-10</span><span class="number">-15</span>)</span><br><span class="line">Brew前期配置成功</span><br><span class="line"></span><br><span class="line">==&gt; brew update</span><br><span class="line"></span><br><span class="line">==&gt; Homebrew has enabled anonymous aggregate formula and cask analytics.</span><br><span class="line">Read the analytics documentation (and how to opt-out) here:</span><br><span class="line">  https:<span class="comment">//docs.brew.sh/Analytics</span></span><br><span class="line">No analytics have been recorded yet (or will be during <span class="built_in">this</span> <span class="string">`brew`</span> run).</span><br><span class="line"></span><br><span class="line">==&gt; Homebrew is run entirely by unpaid volunteers. Please consider donating:</span><br><span class="line">  https:<span class="comment">//github.com/Homebrew/brew#donations</span></span><br><span class="line">Already up-to-date.</span><br><span class="line"></span><br><span class="line">        上一句如果提示Already up-to-date表示成功</span><br><span class="line">            Brew自动安装程序运行完成</span><br><span class="line">              国内地址已经配置完成</span><br><span class="line"></span><br><span class="line">                初步介绍几个brew命令</span><br><span class="line"></span><br><span class="line">        本地软件库列表：brew ls</span><br><span class="line">        查找软件：brew search google（其中google替换为要查找的软件关键字）</span><br><span class="line">        查看brew版本：brew -v  更新brew版本：brew update</span><br><span class="line"></span><br><span class="line">现在可以输入命令open ~<span class="regexp">/.zshrc -e 或者 open ~/</span>.bash_profile -e 整理一下重复的语句(运行 echo $SHELL 可以查看应该打开那一个文件修改)</span><br><span class="line"></span><br><span class="line">        https:<span class="comment">//zhuanlan.zhihu.com/p/111014448  欢迎来给点个赞</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax学习笔记</title>
      <link href="2020/10/14/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2020/10/14/Ajax%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<center>文案</center><center>白天隐藏在入夜的灯，风躺进熟睡人的呼吸</center><center>芦苇是地底的云，你推窗望过来，瞳孔是距我最近的星🌟</center><a id="more"></a><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201014162325571.png" alt="image-20201014162325571"></p><p>完成高功能：局部刷新，但是不可以后退。</p><p>使用XMLHttpRequest对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr = <span class="keyword">new</span> XMLHttpReuqest();</span><br></pre></td></tr></table></figure><p>xhr拥有一些属性方法，</p><h3 id="什么是-Ajax？"><a href="#什么是-Ajax？" class="headerlink" title="什么是 Ajax？"></a>什么是 Ajax？</h3><p>不用刷新页面，但可以和服务端进行通信的方式，使用Ajax的主要方式是XMLHttpRequest对象</p><h3 id="Ajax-传送数据的3种方式"><a href="#Ajax-传送数据的3种方式" class="headerlink" title="Ajax 传送数据的3种方式"></a>Ajax 传送数据的3种方式</h3><p>(1 )xml：笨重，解析困难，但是 xml 是通用的数据交换模式。</p><p>(2) html：不需要解析直接放到文档中，若尽更新一部分数据，但传送数据不是很方便，且HTML代码需要拼装完成。</p><p>(3) JSON：小巧，有面向对象的特性，且第三方的 jar 包可以把 java 对象或集合转化为 JSON 字符串（用的最多）</p><h3 id="使用-jQuery-完成-AJAX-操作"><a href="#使用-jQuery-完成-AJAX-操作" class="headerlink" title="使用 jQuery 完成 AJAX 操作"></a>使用 jQuery 完成 AJAX 操作</h3><p>(1) load方法：可以用于 HTML 文档的元素节点，把结果直接加为对应的子元素，通常而言，load 方法加载后的数据是一个 HTML 片段，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $obj = ...</span><br><span class="line"></span><br><span class="line">Var url = ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> args = &#123;<span class="attr">key</span>:value,...&#125;</span><br><span class="line"></span><br><span class="line">$obj.load (url,args);</span><br></pre></td></tr></table></figure><p>(2). </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get ,  $post, $.getJSON: </span><br></pre></td></tr></table></figure><p>上面这3个方法更加灵活，除去使用 load 方法的情况， 大部分时候都使用这3个方法。</p>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好句子</title>
      <link href="2020/10/13/%E5%A5%BD%E5%8F%A5%E5%AD%90/"/>
      <url>2020/10/13/%E5%A5%BD%E5%8F%A5%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<center>总有一些句子，让我们理解很多东西</center><a id="more"></a><ol><li>我们，大多数，普通人，都是时代大潮下的游泳者。有人遇缓流，有人遇漩涡，有人游得好点，有人游得差点。有一技傍身，都不至于淹死。但好也罢，坏也罢，谁也抵抗不过潮水中的一波巨浪</li></ol>]]></content>
      
      
      <categories>
          
          <category> LQBZ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node学习笔记（1）</title>
      <link href="2020/10/12/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/"/>
      <url>2020/10/12/Node%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<center>人如果活着不学习，那么跟死了有什么区别～</center><a id="more"></a><p>1.命令行窗口(小黑屏)、CMD窗口、终端、shell<br>    - 开始菜单 –&gt; 运行 –&gt; CMD –&gt; 回车<br>    - 常用的指令：<br>        dir 列出当前目录下的所有文件<br>        cd 目录名 进入到指定的目录<br>        md 目录名 创建一个文件夹<br>        rd 目录名 删除一个文件夹    </p><pre><code>- 目录    . 表示当前目录    .. 表示上一级目录- 环境变量（windows系统中变量）        path        C:\work\jdk\jdk1.7.0_75/bin;        %CATALINA_HOME%/bin;        C:\work\soft\tools\AppServ\Apache24\bin;        C:\work\soft\tools\AppServ\php5;        C:\Users\lilichao\AppData\Local\Programs\Fiddler;        C:\work\environment\Egret\Egret Wing 3\bin;        C:\Users\lilichao\AppData\Roaming\npm;        C:\Program Files\MongoDB\Server\3.2\bin;        C:\Users\lilichao\Desktop\hello- 当我们在命令行窗口打开一个文件，或调用一个程序时，        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止        如果没找到则报错- 所以我们可以将一些经常需要访问的程序和文件的路径添加到path中，        这样我们就可以在任意位置来访问这些文件和程序了</code></pre><p>I/O (Input/Output)<br>    - I/O操作指的是对磁盘的读写操作</p><p>Node<br>    - Node是对ES标准一个实现，Node也是一个JS引擎<br>    - 通过Node可以使js代码在服务器端执行<br>    - Node仅仅对ES标准进行了实现，所以在Node中不包含DOM 和 BOM<br>    - Node中可以使用所有的内建对象<br>        String Number Boolean Math Date RegExp Function Object Array<br>        而BOM和DOM都不能使用<br>            但是可以使用 console 也可以使用定时器（setTimeout() setInterval()）</p><pre><code>- Node可以在后台来编写服务器    Node编写服务器都是单线程的服务器    - 进程        - 进程就是一个一个的工作计划（工厂中的车间）    - 线程        - 线程是计算机最小的运算单位（工厂中的工人）            线程是干活的- 传统的服务器都是多线程的    - 每进来一个请求，就创建一个线程去处理请求- Node的服务器单线程的    - Node处理请求时是单线程，但是在后台拥有一个I/O线程池</code></pre>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery复习（3）</title>
      <link href="2020/10/10/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
      <url>2020/10/10/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<center>继续学习~</center><a id="more"></a><ol><li>关于新添加的元素没有被绑定事件，解决方法：给要绑定的元素的父元素绑定（事件委托）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//问题：新添加的元素，点击以后不会变红</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">11111</span>&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">1111111</span>&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">111111111</span>&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">11111111111</span>&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;添加新的li&lt;/button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">$(<span class="string">&#x27;ul&gt;li&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  $(<span class="string">&#x27;#btn&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&#x27;ul&#x27;</span>).append(<span class="string">&#x27;&lt;li&gt;新增的li....&lt;/li&gt;&#x27;</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>事件委托(委派/代理):<br>将多个子元素(li)的事件监听委托给父辈元素(ul)处理<br>监听回调是加在了父辈元素上<br>当操作任何一个子元素(li)时, 事件会冒泡到父辈元素(ul)<br>父辈元素不会直接处理事件, 而是根据event.target得到发生事件的子元素(li), 通过这个子元素调用事件回调函数</p><p>事件委托的2方:<br>委托方: 业主  li<br>被委托方: 中介  ul</p><p>使用事件委托的好处<br>添加新的子元素, 自动有事件响应处理<br>减少事件监听的数量: n==&gt;1</p><p>jQuery的事件委托API<br>设置事件委托: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(parentSelector).delegate(childrenSelector, eventName, callback)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul&#x27;</span>).delegate(<span class="string">&#x27;li&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">   <span class="built_in">this</span>.style.background = <span class="string">&#x27;red&#x27;</span></span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>移除事件委托: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(parentSelector).undelegate(eventName)</span><br></pre></td></tr></table></figure></li><li><p>淡入淡出: 不断改变元素的透明度(opacity)来实现的<br>fadeIn(): 带动画的显示<br>fadeOut(): 带动画隐藏<br>fadeToggle(): 带动画切换显示/隐藏</p><p>fadeIn()无参数，效果会立刻出现</p><p>fadeIn(‘slow’)字符串参数</p><p>fadeIn(3000)   3秒</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#btn1&#x27;</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//$div1.fadeOut()</span></span><br><span class="line">    <span class="comment">//$div1.fadeOut(&#x27;slow&#x27;)</span></span><br><span class="line">   $div1.fadeOut(<span class="number">1000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">     alert(<span class="string">&#x27;动画完成了!!!&#x27;</span>)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chrome上的Ghelper插件</title>
      <link href="2020/10/09/Ghelper%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
      <url>2020/10/09/Ghelper%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
      
        <content type="html"><![CDATA[<center>能帮助我们打卡谷歌学术的插件～～～</center><a id="more"></a><p>我们时不时需要查阅资料，但是像在百度上搜不到，资料也比较少，这是我们就可能要“FQ”，但是还需要买服务器，很麻烦，这里我推荐一个插件，它能够帮我们进行查阅一些资料，像谷歌学术这类的网站能够快速进去</p><p>下载网址：<a href="http://googlehelper.net/">点这里</a></p><p>下载后，解压，然后打开谷歌浏览器，</p><p>点击：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201009091724613.png" alt="image-20201009091724613" style="zoom:67%;" /><p>然后依次点击 更过工具–&gt;扩展程序  或者直接在chrome上输入：chrome://extensions/</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201009091850917.png" alt="image-20201009091850917" style="zoom:67%;" /><p>然后按下图点击啊：</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201009092427481.png" alt="image-20201009092427481" style="zoom:67%;" /><p>把下载后解压的ghelper_source文件夹就可以了。</p><p>这时候就能上谷歌学术查阅资料辽～～～</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery复习（2）</title>
      <link href="2020/10/08/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
      <url>2020/10/08/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<center>赶快来学习～～</center><a id="more"></a><ol><li><p>选择p标签的第一个元素，并且把它的样式设置为红色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;p:first&#x27;</span>).css(<span class="string">&#x27;color&#x27;</span>，<span class="string">&#x27;red&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>选的是第二个p元素，这里设置了样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;p:eq(1)&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>内容尺寸<br>  height(): height<br>  width(): width<br>内部尺寸<br>  innerHeight(): height+padding<br>  innerWidth(): width+padding<br>外部尺寸<br>  outerHeight(false/true): height+padding+border  如果是true, 加上margin<br>  outerWidth(false/true): width+padding+border 如果是true, 加上margin</p></li><li><p>在jQuery对象中的元素对象数组中过滤出一部分元素来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">first()</span><br><span class="line">last()</span><br><span class="line">eq(index|-index)</span><br><span class="line">filter(selector)</span><br><span class="line">not(selector)</span><br><span class="line">has(selector)</span><br></pre></td></tr></table></figure></li><li><p>在已经匹配出的元素集合中根据选择器查找孩子/父母/兄弟标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">children(): 子标签中找</span><br><span class="line">find() : 后代标签中找</span><br><span class="line">parent() : 父标签</span><br><span class="line">prevAll() : 前面所有的兄弟标签</span><br><span class="line">nextAll() : 后面所有的兄弟标签</span><br><span class="line">siblings() : 前后所有的兄弟标签</span><br></pre></td></tr></table></figure></li><li><p>添加/替换元素<br>  append(content)</p><pre><code>向当前匹配的所有元素内部的最后插入指定内容</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> $ul1 = $(<span class="string">&#x27;#ul1&#x27;</span>)</span><br><span class="line"> <span class="comment">//$ul1.append(&#x27;&lt;span&gt;append()添加的span&lt;/span&gt;&#x27;)</span></span><br><span class="line"> $(<span class="string">&#x27;&lt;span&gt;appendTo()添加的span&lt;/span&gt;&#x27;</span>).appendTo($ul1)</span><br><span class="line"><span class="comment">//这两种方法都可以</span></span><br></pre></td></tr></table></figure><p> prepend(content)</p><pre><code>向当前匹配的所有元素内部的最前面插入指定内容</code></pre><p> before(content)</p><pre><code>将指定内容插入到当前所有匹配元素的前面</code></pre><p> after(content)</p><pre><code>将指定内容插入到当前所有匹配元素的后面替换节点</code></pre><p>replaceWith(content)</p><pre><code>用指定内容替换所有匹配的标签删除节点</code></pre><p>删除元素<br>empty()</p><pre><code>删除所有匹配元素的子元素</code></pre><p>remove()</p><pre><code>删除所有匹配的元素</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#ul2&gt;li&#x27;</span>).remove() <span class="comment">// 移除id为u12下的所有li元素</span></span><br></pre></td></tr></table></figure></li><li><p>事件绑定(2种)：</p><ol><li><p>eventName(function(){})</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#div&#x27;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>on(eventName, funcion(){})</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#div&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>优缺点:<br>   eventName: 编码方便, 但只能加一个监听, 且有的事件监听不支持<br>   on: 编码不方便, 可以添加多个监听, 且更通用</p></li><li><p>区别mouseover与mouseenter</p><p>mouseover: 在移入子元素时也会触发, 对应mouseout</p><p>mouseenter: 只在移入当前元素时才触发, 对应mouseleave</p><p>hover()使用的就是mouseenter()和mouseleave()</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雷哥诗句汇总</title>
      <link href="2020/10/08/%E9%9B%B7%E5%93%A5%E8%AF%97%E5%8F%A5%E6%B1%87%E6%80%BB/"/>
      <url>2020/10/08/%E9%9B%B7%E5%93%A5%E8%AF%97%E5%8F%A5%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<center>为了方便记住我大哥，特此开辟一个专栏，进行独家记忆。保证绝对有特色，绝对有深度。</center><a id="more"></a><ol><li>雷哥说：对女生过敏</li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/1E2139FC8D33A4A71DD91A1913993118.png" alt="1E2139FC8D33A4A71DD91A1913993118" style="zoom:67%;" /><ol start="2"><li>若为爱情故，一切皆可抛。</li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/9F67701569CB9B2FE4677C86983093B4.png" alt="9F67701569CB9B2FE4677C86983093B4" style="zoom:67%;" /><ol start="3"><li>两情若是长久时，又岂在朝朝暮暮。</li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/29B887625C7B9E7424162FACC5110DE0.png" alt="29B887625C7B9E7424162FACC5110DE0" style="zoom:67%;" /><ol start="4"><li>为人性癖耽佳句，语不惊人死不休。</li></ol><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/AC0E789655CD903CE9A4A002AE199242.png" alt="AC0E789655CD903CE9A4A002AE199242" style="zoom:67%;" /><ol start="5"><li><p>Love is confusing and life hard.</p></li><li><p>You have to forgive and start to heal.</p></li><li><p>车到山前必有路，船到桥头自然直。</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201010104408915.png" alt="image-20201010104408915"  /></li></ol><p>8.</p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/image-20201010181052953.png" alt="image-20201010181052953" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> LQBZ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗句 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-344-反转字符串</title>
      <link href="2020/10/08/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>2020/10/08/LeetCode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><a id="more"></a> <p>示例 1：</p><p>输入：[“h”,”e”,”l”,”l”,”o”]<br>输出：[“o”,”l”,”l”,”e”,”h”]<br>示例 2：</p><p>输入：[“H”,”a”,”n”,”n”,”a”,”h”]<br>输出：[“h”,”a”,”n”,”n”,”a”,”H”]</p><h3 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverseString</span><span class="params">(<span class="keyword">char</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">            <span class="keyword">char</span> tmp = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/reverse-string">https://leetcode-cn.com/problems/reverse-string</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="2020/10/07/JDBC/"/>
      <url>2020/10/07/JDBC/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> JDBC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery复习（1）</title>
      <link href="2020/10/07/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
      <url>2020/10/07/jQuery%E5%A4%8D%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<center>开始第一天复习jQuery</center><a id="more"></a><p>####基础知识</p><ol><li><p>$ 或 jQuery是一个函数，既是函数也是对象。</p></li><li><p>$( )返回的对象就是jQuery对象。</p></li><li><p>文档夹在完成才执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//绑定文件加载完成后的监听</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>引入jQuery后，当函数用：$(***)</p><p>当对象用：$.(***)</p></li><li><p>作为一般函数调用: $(param)<br>  1). 参数为函数 : 当DOM加载完成后，执行此回调函数<br>  2). 参数为选择器字符串: 查找所有匹配的标签, 并将它们封装成jQuery对象<br>  3). 参数为DOM对象: 将dom对象封装成jQuery对象<br>  4). 参数为html标签字符串 (用得少): 创建标签对象并封装成jQuery对象</p><p>作为对象使用: $.xxx()</p><p>1). $.each() : 隐式遍历数组</p><p>2). $.trim() : 去除两端的空格</p></li><li><p>jQuery对象是一个包含所有匹配的任意多个dom元素的伪数组对象，所谓的伪数组对象就是只拥有数组的属性，例如长度属性、数值下标属性，但是没有数组的方法。</p><p>基本行为</p><ul><li><p>size()/length: 包含的DOM元素个数</p></li><li><p>[index]/get(index): 得到对应位置的DOM元素</p></li><li><p>each(): 遍历包含的所有DOM元素</p></li><li><p>index(): 得到在所在兄弟元素中的下标</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $btn = $(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log($btn.size())</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h4><ol><li><p>是什么?</p><ul><li>有特定格式的字符串</li></ul></li><li><p>作用</p><ul><li>用来查找特定页面元素</li></ul></li><li><p>基本选择器</p><p>​        ‘#’id : id选择器</p><ul><li>element : 元素选择器</li><li>.class : 属性选择器</li><li>*: 任意标签</li><li>selector1,selector2,selectorN : 取多个选择器的并集(组合选择器)</li><li>selector1selector2selectorN : 取多个选择器的交集(相交选择器)</li></ul></li></ol><h4 id="层次选择器"><a href="#层次选择器" class="headerlink" title="层次选择器"></a>层次选择器</h4><p>层次选择器: 查找子元素, 后代元素, 兄弟元素的选择器</p><ol><li><p>ancestor descendant<br>  在给定的祖先元素下匹配所有的后代元素</p></li><li><p>parent&gt;child<br>  在给定的父元素下匹配所有的子元素</p></li><li><p>prev+next<br>匹配所有紧接在 prev 元素后的 next 元素</p></li><li><p>prev~siblings<br>匹配 prev 元素之后的所有 siblings 元素<br>–&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1. 选中ul下所有的的span</span></span><br><span class="line">$(<span class="string">&#x27;ul span&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//2. 选中ul下所有的子元素span</span></span><br><span class="line">$(<span class="string">&#x27;ul&gt;span&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 选中class为box的下一个li</span></span><br><span class="line">$(<span class="string">&#x27;.box+li&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//4. 选中ul下的class为box的元素后面的所有兄弟元素</span></span><br><span class="line">$(<span class="string">&#x27;ul .box~*&#x27;</span>).css(<span class="string">&#x27;background&#x27;</span>, <span class="string">&#x27;yellow&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="过滤选择器"><a href="#过滤选择器" class="headerlink" title="过滤选择器"></a>过滤选择器</h4><p>理解：在原有的选择器上进行进一步筛选</p><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 选择第一个div</span></span><br><span class="line"><span class="comment">// $(&#x27;div:first&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 选择最后一个class为box的元素</span></span><br><span class="line"><span class="comment">//$(&#x27;.box:last&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 选择所有class属性不为box的div</span></span><br><span class="line"><span class="comment">// $(&#x27;div:not(.box)&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)  //没有class属性也可以</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 选择第二个和第三个li元素</span></span><br><span class="line"><span class="comment">// $(&#x27;li:gt(0):lt(2)&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;) // 多个过滤选择器不是同时执行, 而是依次</span></span><br><span class="line"><span class="comment">//$(&#x27;li:lt(3):gt(0)&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 选择内容为BBBBB的li</span></span><br><span class="line"><span class="comment">// $(&#x27;li:contains(&quot;BBBBB&quot;)&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 选择隐藏的li</span></span><br><span class="line"><span class="comment">//console.log($(&#x27;li:hidden&#x27;).length, $(&#x27;li:hidden&#x27;)[0])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 选择有title属性的li元素</span></span><br><span class="line"><span class="comment">// $(&#x27;li[title]&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 选择所有属性title为hello的li元素</span></span><br><span class="line"><span class="comment">//$(&#x27;li[title=&quot;hello&quot;]&#x27;).css(&#x27;background&#x27;, &#x27;red&#x27;)</span></span><br></pre></td></tr></table></figure><h4 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h4><p>具体看相关文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input  type=<span class="string">&quot;text&quot;</span>    /&gt;  </span><br><span class="line">    &lt;input type=<span class="string">&quot;radio&quot;</span>  /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;:text&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h4><ol><li><p>$.each(): 遍历数组或对象中的数据</p></li><li><p>$.trim(): 去除字符串两边的空格</p></li><li><p>$ .type(obj): 得到数据的类型</p></li><li><p>$.isArray(obj): 判断是否是数组</p></li><li><p>$.isFunction(obj): 判断是否是函数</p></li><li><p>$.parseJSON(json) : 解析json字符串转换为js对象/数组</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>typora常用命令</title>
      <link href="2020/10/07/typora%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>2020/10/07/typora%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>​                先把用到的命令总结一下，之后遇见新的会继续维护此文档。</p><a id="more"></a><h2 id="Typora-的快捷键"><a href="#Typora-的快捷键" class="headerlink" title="Typora 的快捷键"></a>Typora 的快捷键</h2><table><thead><tr><th align="center">操作</th><th align="center">快捷键</th><th>备注</th></tr></thead><tbody><tr><td align="center">插入表格</td><td align="center">option+command+t</td><td></td></tr><tr><td align="center">代码块</td><td align="center">option+command+c 或者```</td><td></td></tr><tr><td align="center">最大标题</td><td align="center">command+1 或者 #</td><td>其他也类似</td></tr><tr><td align="center">有序列表</td><td align="center">数字+.+空格 或者option+command+o</td><td></td></tr><tr><td align="center">无序空心列表</td><td align="center"></td><td></td></tr><tr><td align="center">无序实心列表</td><td align="center">‘+’  + 空格 或者option+command+u</td><td></td></tr><tr><td align="center">取消继承格式</td><td align="center">command+[</td><td></td></tr><tr><td align="center">下划线</td><td align="center">command+u</td><td></td></tr><tr><td align="center">粗体</td><td align="center">commend+B</td><td></td></tr><tr><td align="center">超链接</td><td align="center">commend+k</td><td></td></tr><tr><td align="center">代码块整体前移</td><td align="center">shift+tab</td><td></td></tr><tr><td align="center">高亮文字</td><td align="center">====</td><td></td></tr></tbody></table><h2 id="Github上面的使用技巧"><a href="#Github上面的使用技巧" class="headerlink" title="Github上面的使用技巧"></a>Github上面的使用技巧</h2><p>搜索框里面：</p><p>in:name example        名字中有“example”<br>in:readme example        readme中有“example”<br>in:description example    描述中有“example”</p><p>stars:&gt;1000        star&gt;1000<br>forks:&gt;1000        fork&gt;1000<br>pushed:&gt;2019-09-01        2019年9月1日后有更新的</p><p>language:java        用Java编写的项目</p>]]></content>
      
      
      <categories>
          
          <category> 软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建终极解决方案</title>
      <link href="2020/09/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>2020/09/27/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%BB%88%E6%9E%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="gitee-git-hexo-typora打造终极博客"><a href="#gitee-git-hexo-typora打造终极博客" class="headerlink" title="gitee+git+hexo+typora打造终极博客"></a>gitee+git+hexo+typora打造终极博客</h1><p>连续花了4天多的时间，终于把我的博客搭建好了～～<a href="https://dllgdxlgy.github.io/">俺的博客</a>，</p><a id="more"></a><p>虽然有点累，但还是挺开心的，哈哈哈哈，我花的时间太多了，大神遇见不要笑我，期间遇见很多问题，也查到很多很多方案，今天有时间，在这里记录一下，我用的mac中，windows上搭建也是大同小异，需要的可以参考。</p><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>先看一张图片，上图</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20200930204251672.png" alt="image-20200930204251672"></p><h3 id="解决图片传输的终极方案"><a href="#解决图片传输的终极方案" class="headerlink" title="解决图片传输的终极方案"></a>解决图片传输的终极方案</h3><p>参考链接：<a href="https://blog.csdn.net/baidu_41656912/article/details/106431054">我在这呢</a></p><h4 id="GItee准备"><a href="#GItee准备" class="headerlink" title="GItee准备"></a>GItee准备</h4><ol><li><p>这里需要先准备一个Gitee账号</p></li><li><p>然后在Gitee里面建立一个账户，这里仓库必须公开，要是不公开是没有办法进行图片上传的，（我踩过坑）</p><p>新建仓库–&gt;然后给仓库起一个名字</p></li><li><p>然后点击头像–&gt;设置，在安全设置里面，选择私人令牌，然后生成新令牌，记得把令牌保存一下，一会要用。</p></li></ol><h4 id="PicGO配置"><a href="#PicGO配置" class="headerlink" title="PicGO配置"></a>PicGO配置</h4><ol><li><p>去官网下载<a href="https://molunerfinn.com/PicGo/">链接</a></p></li><li><p>然后安装好，点击插件设置，在搜索框输入gitee，安装gitee插件，据说两个都可以。随便安装一个</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201002201414373" alt="image-20201002201414373"></p></li><li><p>点击下面的设置按钮，进行插件设置</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201002201623841.png" alt="image-20201002201623841"></p><p>owner：是拥有者</p><p>repo：是图片仓库的名称</p><p>path：是在哪里文件夹下</p><p>token：是刚刚复制的令牌</p><p>message：可以不填。</p></li><li><p>然后进行图片上传，可以看到这里能进行上传了，</p></li><li><p>可以尝试去一下自己的gitee网站下，看一下是不是路径下有自己的图片存在，</p><p>（这里在上传图片时不要传太大的，要不回传上去，但是不显示在文档里）</p></li></ol><h4 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h4><ol><li><p>下载typora后，进行偏好设置</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201002202718374.png" alt="image-20201002202718374"></p></li></ol><ol start="2"><li><p>点击图像，可以插入图片时可以像我，这样设置（我这样设置的目的为了在本地有备份）也可以直接上传，接着选择上传服务，以及选择PicGo的安装路径，最后可以验证一下图片上传选项</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201002202851487.png" alt="image-20201002202851487"></p></li><li><p>这时候新建一个文件，就可以进行编辑了，图片自动上传到gitee，这样图片就不会丢失了。</p></li></ol><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><p>参考链接<a href="https://www.jianshu.com/p/13e64c9e2295">点这里</a></p><p>因为在typora上面写md文件特别舒服，但是在搭建博客的时候容易出现图片不显示问题，所以在这里重点解决一下图片显示问题。</p><p>方案：gitee+picgo+typora</p><p>思路：把typora图片上传到gitee，之所以不传到git，是因为git太慢了，本来图片就不小，加载太慢很容易丢失信心～，而PicGo很容易解决，在中间起中间支撑作用。再加上图片自动上传，那简直不要太爽～</p><hr><ol><li><p>安装Node.js <a href="https://nodejs.org/en/">链接在这</a></p><p>其主要目的是用来生成静态页面</p></li><li><p>安装Git</p><p>检查版本：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20200930205936952.png" alt="image-20200930205936952"></p></li><li><p>安装Hexo</p><ul><li><p>首先在终端执行下面代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo npm install -g hexo</span><br></pre></td></tr></table></figure></li><li><p>选择你要保存博客的根目录，接下来将要创建博客文件</p></li><li><p>假设你把文件保存在blog中，则在上一层文件中创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install</span><br></pre></td></tr></table></figure></li><li><p>执行如下命令，开启服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ul><p>此时，打开浏览器访问<a href="http://localhost:4000，就能看到如下页面">http://localhost:4000，就能看到如下页面</a></p></li></ol><p>   <img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20201001200925073.png" alt="image-20201001200925073"></p><ol start="4"><li><p>关联github</p><p>登陆账号，新建仓库，命名为<span style='color:red;background:yellow;font-size:文字大小;font-family:字体;'>用户名.github.io</span></p><p>此时blog文件夹下的文件目录为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_config.yml </span><br><span class="line">db.json </span><br><span class="line">node_modules </span><br><span class="line"><span class="keyword">package</span>.json</span><br><span class="line">scaffolds</span><br><span class="line">source</span><br><span class="line">themes</span><br></pre></td></tr></table></figure><p>然后进入到<span style='color:red;background:yellow;font-size:文字大小;font-family:字体;'>blog</span>文件夹下，使用vim命令打开_config.yml，命令如下：    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim _config.yml</span><br></pre></td></tr></table></figure><p>然后修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;dllgdxlgy&#x2F;dllgdxlgy.github.io.git</span><br><span class="line">  branch: master     </span><br></pre></td></tr></table></figure><p>你需要把dllgdxlgy换为自己的用户名，并且冒号里面需要空格，否则就出现错误。</p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -generate   或者 hexo g     </span><br></pre></td></tr></table></figure><p>目的：为了生成静态页面。</p><p>若出现以下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in ~&#x2F;blog</span><br><span class="line">ERROR Try runing: &#39;npm install hexo --save&#39;</span><br></pre></td></tr></table></figure><p>则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo --save</span><br></pre></td></tr></table></figure><p>若无报错，则忽略此步骤。</p><p>在执行配置命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy           或者：hexo d</span><br></pre></td></tr></table></figure><p>如果此步骤出现错误：无法连接git或找不到git</p><p>则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save      </span><br></pre></td></tr></table></figure><p>然后在执行hexo g 和 hexo d 命令</p><p>执行成功后就能在<a href="http://dllgdxlgy.github.io上看到和之前一样页面./">http://dllgdxlgy.github.io上看到和之前一样页面。</a></p></li></ol><ol start="5"><li>检查ssh keys是否存在Github上（我这里是存在的）</li></ol><ol start="6"><li><p>然后将ssh key 添加到github上。</p><p>Find前往文件夹<code>~/.ssh/id_rsa.pub</code>打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。</p><p>进入GitHub –&gt; Settings –&gt; SSH keys –&gt; add SSH key:</p><p>Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方<code>Add key</code>绿色按钮即可。</p></li><li><p>（小记：commend+[  就能稀释掉前面的样式）</p><p>发布文章，进入到blog文件夹下，打开命令行，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;文件夹名字&quot; </span><br></pre></td></tr></table></figure><p>会在文件夹下发现文档（md格式）</p><p>然后再用typora编写就可以</p></li></ol><h3 id="安装主题Next"><a href="#安装主题Next" class="headerlink" title="安装主题Next"></a>安装主题Next</h3><p>官网链接<a href="https://hexo.io/themes/">点击这里</a>，选自己喜欢的就行了，这里选择的是<span style='color:red;background:yellow;font-size:文字大小;font-family:字体;'>hexo-theme-next</span>主题，</p><p>终端进入到blog文件夹下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure><p>可以看到blog文件夹目录下的theme文件下多出了theme的文件，这就是刚下的文件，</p><p>然后进入到blog文件下的_config.xml文件下，修改他，可以用vscode改，也可以使用命令行的格式进行修改，</p><p>修改内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">landscape:next  (这里改为next)</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean           &#x2F;&#x2F;清除缓存文件 (db.json) 和已生成的静态文件 (public)</span><br><span class="line"></span><br><span class="line">$ hexo g             &#x2F;&#x2F;生成缓存和静态文件</span><br><span class="line"> </span><br><span class="line">$ hexo d             &#x2F;&#x2F;重新部署到服务器</span><br></pre></td></tr></table></figure><p>也可以修改其他的选项。</p><h4 id="关于执行hexo-d-命令卡住然后报错"><a href="#关于执行hexo-d-命令卡住然后报错" class="headerlink" title="关于执行hexo d 命令卡住然后报错"></a>关于执行hexo d 命令卡住然后报错</h4><p>解决方式：重启电脑</p><p>网上的解决方式：<a href="https://blog.csdn.net/weixin_41256398/article/details/117994899%EF%BC%8C%E6%9C%AA%E6%9B%BE%E5%B0%9D%E8%AF%95%E3%80%82">https://blog.csdn.net/weixin_41256398/article/details/117994899，未曾尝试。</a></p><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Linux </tag>
            
            <tag> typora </tag>
            
            <tag> Mac </tag>
            
            <tag> Gitee </tag>
            
            <tag> hexo </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux修改文件等命令</title>
      <link href="2020/09/26/Linux%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%AD%89%E5%91%BD%E4%BB%A4/"/>
      <url>2020/09/26/Linux%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E7%AD%89%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>1、 vi 文件名（编辑文件）</p><p>2、按insert按键，是编辑文件</p><p>3、esc退出编辑</p><p>4、:wq 保存并退出</p><p>5、:q! 不保存并退出</p><a id="more"></a><p>6、在没有编辑的情况下，当光标在最后一行的时候，输入o，不显示，但是可以插入一行，如图：</p><p><img src="https://dlutlgy-image-for-mac.oss-cn-beijing.aliyuncs.com/imagesimage-20200926190125902.png" alt="image-20200926190125902"></p><p>7、dd（删除光标所在一行）</p><p>8、</p><p>ls 显示当前下面的文件及文件夹</p><p>ls -a 显示<a href="https://www.baidu.com/s?wd=%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">当前目录</a>下的所有文件及文件夹包括隐藏的.和..等</p><p>ls -al 显示<a href="https://www.baidu.com/s?wd=%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">当前目录</a>下的所有文件及文件夹包括隐藏的.和..等并显示详细信息，详细信息包括大小，属组，创建时间</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>入党积极分子</title>
      <link href="2020/03/14/%E5%85%A5%E5%85%9A%E7%A7%AF%E6%9E%81%E5%88%86%E5%AD%90/"/>
      <url>2020/03/14/%E5%85%A5%E5%85%9A%E7%A7%AF%E6%9E%81%E5%88%86%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<center>跟党走～～～</center><a id="more"></a><ol><li><p>“四个全面”战略布局，即：<strong>全面建成小康社会、全面深化改革、全面依法治国、全面从严治党</strong>。</p></li><li><p>“五位一体”总体布局，即：<strong>经济建设、政治建设、文化建设、社会建设、生态文明建设</strong>–着眼于全面建成小康社会、实现社会主义现代化和中华民族伟大复兴，这是党的十八大报告对推进中国特色社会主义事业作出的“五位一体”总体布局。</p></li><li><p>“五大发展理念”即：“十三五”的新发展格局，将在“四个全面”战略布局下，坚持“五位一体”的发展思路。全面推进和落实<strong>创新、协调、绿色、开放和共享</strong>五大发展理念，这是当代中国共产党人的大思维、大战略、大格局、大智慧，从而为我国经济社会的平衡、包容和可持续发展提供坚实的支撑。是管全局、管根本、管长远的导向，具有战略性、纲领性、引领性。</p></li><li><p>四个自信：坚持中国特色社会主义<strong>道路自信、理论自信、制度自信、文化自信</strong>。</p></li><li><p>四个意识：牢固树立<strong>政治意识、大局意识、核心意识、看齐意识</strong>。</p></li><li><p>中国共产党人的初心和使命，就是<strong>为中国人民谋幸福，为中华民族谋复兴</strong></p></li><li><p>我国社会主要矛盾已经转化为<strong>人民日益增长的美好生活需要</strong>和<strong>不平衡不充分的发展</strong>之间的矛盾。</p></li><li><p>将新型冠状病毒感染的肺炎命名为“Covid-19”</p></li><li><p>根本政治制度：人民代表大会制度</p></li><li><p><strong>发展</strong>是我们党执政兴国的第一要务。<em>必须<strong>坚持以人民为中心</strong>的发展思想</em>，<em>坚持**</em>创新、协调、绿色、开放、共享**的发展理念。</p></li><li><p>发展党员，必须把<strong>政治标准</strong>放在首位。</p></li><li><p>党的根本宗旨：<strong>全心全意为人民服务</strong></p></li><li><p>我党最大的政治优势：<strong>密切联系群众</strong>。</p></li><li><p>中国共产党必须始终代表中国先进生产力的发展要求、中国先进文化的前进方向、中国最广大人民的根本利益，是我们党的<strong>立党之本、执政之基、力量之源</strong>。</p></li><li><p>科学发展观的基本原则：<strong>以人为本</strong></p></li><li><p><em>科学发展观</em>，第一要务是发展，核心是以人为本，<em>基本</em>要求是全面协调可持续发展，根本方法是统筹兼顾</p></li><li><p><strong>民主集中制</strong>是党的根本组织原则和领导制度</p></li><li><p>中国共产党的最高理想和最终目标是<strong>实现共产主义制度</strong></p></li><li><p>党的纪律处分有五种:<strong>警告、严重警告、撤销党内职务、留党察看、开除党籍。</strong></p></li><li><p>预备党员如果延长预备期，最长不能超过<strong>一年</strong></p></li><li><p>预备党员的预备期，从<strong>支部大会通过他为预备党员之日</strong>算起</p></li><li><p>把人民放在心中最高位置，一切工作<strong>要以人民利益为出发点</strong>是无产阶级的党性的根本要求。</p></li><li><p>2013年1月中共中央政治局会议上出台的新的党员发展工作“十六字方针”，即“<strong>控制总量、优化结构、提高质量、发挥作用</strong>”，对高校组织发展工作提出了新的要求。</p></li><li><p><strong>民主集中制</strong>是党的根本组织制度和领导制度，也是党最重要的组织纪律和政治纪律</p></li><li><p>第一个阶段，从2020年到2035年，在全面建成小康社会的基础上，再奋斗15年，<strong>基本实现社会主义现代化</strong>。</p><p>第二个阶段，从2035年到本世纪中叶，在基本实现现代化的基础上，再奋斗15年，把<strong>我国建成富强民主文明和谐美丽的社会主义现代化强国</strong>。</p></li></ol><ol><li>在对资本主义工商业的社会主义改造中，所谓初、中级国家资本主义的主要含义是，社会主义国家对资本主义工商业采取<strong>加工订货</strong>，高级阶段采取<strong>公私合营</strong></li><li>中共12大：1982年</li><li>1971年10月25日，第（<strong>26</strong> ）联合国大会通过决议，恢复中华人民共和国在联合国的合法席位。</li><li><strong>农业生产互助组、初级农业合作社、高级农业合作社</strong>实现农业合作化的过程</li><li>中国共产党在中国革命事业中的领导地位，是由<strong>党的性质</strong>决定的。</li><li><strong>统一战线，武装斗争，党的建设</strong>中国新民主主义革命胜利的三大法宝</li><li>大革命失败后，中共将工作重心由城市转向农村，标志着向农村进军新起点的是（ 秋收起义后建立了井冈山根据地 ）。</li><li>1967年2月批评“文化大革命”倒行逆施，1976年又领导粉碎“四人帮”的是（ <strong>叶剑英</strong>）。</li><li>1937年，中共洛川政治局扩大会议指出，争取全民族抗战胜利的关键是（实行全面抗战路线，反对片面抗战路线 ）</li><li>第一次提出“毛泽东思想”这一概念的是（ <strong>王稼祥</strong> ）</li></ol><p>To alleviate sparsity and cold start problem of collaborative filtering based recommender systems, researchers and engineers usually collect attributes of users and items, and design delicate algorithms to exploit these additional information. In general, the attributes are not isolated but connected with each other, which forms a knowl- edge graph (KG). In this paper, we propose Knowledge Graph Convolutional Networks (KGCN), an end-to-end framework that captures inter-item relatedness effectively by mining their associ- ated attributes on the KG. To automatically discover both high-order structure information and semantic information of the KG, we sam- ple from the neighbors for each entity in the KG as their receptive field, then combine neighborhood information with bias when cal- culating the representation of a given entity. The receptive field can be extended to multiple hops away to model high-order proximity information and capture users’ potential long-distance interests. Moreover, we implement the proposed KGCN in a minibatch fash- ion, which enables our model to operate on large datasets and KGs. We apply the proposed model to three datasets about movie, book, and music recommendation, and experiment results demonstrate that our approach outperforms strong recommender baselines.</p><p>为了缓解基于协同过滤的推荐系统的稀疏性和冷启动问题，研究人员和工程师通常收集用户和项目的属性，并设计精细的算法来利用这些附加信息。一般情况下，属性之间不是孤立的，而是相互联系的，形成一个知识边图。本文提出了一种端到端的知识图卷积网络（KGCN）框架，通过挖掘知识图卷积网络上的关联属性，有效地获取项目间的关联性。为了自动发现KG的高阶结构信息和语义信息，我们从KG中每个实体的邻域中抽取样本作为它们的感受野，然后在计算给定实体的表示时结合邻域信息和偏差。接收场可以扩展到多跳距离，以模拟高阶邻近信息并捕获用户的潜在远程兴趣。此外，我们以小批量方式实现了所提出的KGCN，这使得我们的模型能够在大数据集和KG上运行。我们将该模型应用于电影、书籍和音乐推荐的三个数据集，实验结果表明，该方法优于强推荐基线。</p><p>B:To alleviate … and …problem of collaborative filtering based recommender systems, researchers and engineers usually collect attributes of users and items, and design delicate algorithms to exploit these additional information.</p><p>For grayscale photos, how to  supplement its color is a question worth thinking about. This can clearly find that for some things , specific colors can be obtained through the semantic information and surface texture of the scene.</p>]]></content>
      
      
      <categories>
          
          <category> 入党 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 入党 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
