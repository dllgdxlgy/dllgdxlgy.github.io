<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dlutlgy.top","root":"/","scheme":"Pisces","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="最近在复盘 Java 基础，有些在之前的学习过程中遗忘，现在进行查缺补漏。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java语言">
<meta property="og:url" content="http://dlutlgy.top/2021/08/13/Java/index.html">
<meta property="og:site_name" content="酒窝里有酒">
<meta property="og:description" content="最近在复盘 Java 基础，有些在之前的学习过程中遗忘，现在进行查缺补漏。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210831130537444.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210817201217488.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210817195846461.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210818200735250.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210821101501463.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210830132449790.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20220102223958792.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210906192257236.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201124193827032.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201127142743534.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20201127144332468.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201127152144541.png">
<meta property="og:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201125121333135.png">
<meta property="article:published_time" content="2021-08-13T05:55:57.000Z">
<meta property="article:modified_time" content="2022-03-15T02:03:11.243Z">
<meta property="article:author" content="Dlutlgy">
<meta property="article:tag" content="Java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210831130537444.png">


<link rel="canonical" href="http://dlutlgy.top/2021/08/13/Java/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java语言 | 酒窝里有酒</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?610f3edfabbb82ef386946e8513bdacf";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">酒窝里有酒</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">盐于律己，甜以待人。生而温柔，却有力量，近朱者赤，近我者甜。众生皆草木，唯我是青山。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-guestbook">

    <a href="/guestbook/" rel="section"><i class="fa fa-book fa-fw"></i>留言板</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0"><span class="nav-text">Java语言学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Day01"><span class="nav-text">Day01</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day02"><span class="nav-text">Day02</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">变量的类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">算术运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">逻辑运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">位运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">三元运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">运算符的优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="nav-text">流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-text">顺序结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="nav-text">分支结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="nav-text">循环结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day06"><span class="nav-text">day06</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day08"><span class="nav-text">day08</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day09"><span class="nav-text">day09</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day10"><span class="nav-text">day10</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">this关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day12"><span class="nav-text">day12</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">单元测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="nav-text">基本数据类型与包装类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day14"><span class="nav-text">day14</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day15"><span class="nav-text">day15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">代码块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">final关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="nav-text">抽象类和抽象方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E4%BA%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB"><span class="nav-text">匿名对象于抽象类的匿名子类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3"><span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="nav-text">如何定义接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E4%BD%BF%E7%94%A8"><span class="nav-text">具体使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-text">内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day16"><span class="nav-text">day16</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-text">异常处理机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Try-catch-finally%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">Try-catch-finally的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#thows-%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B"><span class="nav-text">thows+异常类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="nav-text">如何选择？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="nav-text">用户自定义异常类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB%EF%BC%9F"><span class="nav-text">如何自定义异常类？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%BB%83%E4%B9%A0%EF%BC%9A%E8%A7%86%E9%A2%91382"><span class="nav-text">异常处理练习：视频382</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throws%E4%B8%8Ethrow-%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="nav-text">throws与throw 的不同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day17"><span class="nav-text">day17</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#day18-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">day18 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="nav-text">基本概念：程序、进程、线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">多线程创建的方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95Thread%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="nav-text">测试Thread中的常用方法：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F"><span class="nav-text">线程的声明周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="nav-text">线程的同步</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="nav-text">Java常用类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="nav-text">字符串相关的类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9FAPI"><span class="nav-text">时间日期API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E4%B8%8E%E6%96%B0%E6%B3%A8%E8%A7%A3"><span class="nav-text">枚举类与新注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89"><span class="nav-text">注解（Annotation）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#java%E9%9B%86%E5%90%88"><span class="nav-text">java集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="nav-text">Map的实现类的结构：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B"><span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-text">泛型方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%B5%81"><span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">1. 流的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">网络编程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%8F%8D%E5%B0%84"><span class="nav-text">Java 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-text">1. Java反射机制概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E8%BF%B0"><span class="nav-text">反射的概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80-%E4%B8%8E-%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="nav-text">动态语言 与 静态语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-text">Java反射机制研究与应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%90%86%E8%A7%A3Class%E7%B1%BB%E5%B9%B6%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="nav-text">2. 理解Class类并获取Class实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E7%B1%BB"><span class="nav-text">Class类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B-%EF%BC%88%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%89"><span class="nav-text">获取Class类的实例 （四种方法）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD-%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">3. 类的加载 与ClassLoader的理解（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B-%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-text">类的加载过程 （了解）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="nav-text">类加载器的作用：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="nav-text">类的加载器的种类：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="nav-text">4. 创建运行时类对象（重点）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="nav-text">5. 获取运行时类的完整结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="nav-text">6. 调用运行时类的指定结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="nav-text">动态代理</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Dlutlgy"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">Dlutlgy</p>
  <div class="site-description" itemprop="description">what kind of life do you want ~</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/dllgdxlgy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;dllgdxlgy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:L337cu@163.com" title="E-Mail → mailto:L337cu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://music.163.com/#/user/home?id=440399808" title="音乐 → https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;440399808" rel="noopener" target="_blank"><i class="fa fa-headphones fa-fw"></i>音乐</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://dlutlgy.top/2021/08/13/Java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="Dlutlgy">
      <meta itemprop="description" content="what kind of life do you want ~">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="酒窝里有酒">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java语言
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-08-13 13:55:57" itemprop="dateCreated datePublished" datetime="2021-08-13T13:55:57+08:00">2021-08-13</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2022-03-15 10:03:11" itemprop="dateModified" datetime="2022-03-15T10:03:11+08:00">2022-03-15</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span id="/2021/08/13/Java/" class="post-meta-item leancloud_visitors" data-flag-title="Java语言" title="阅读次数">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span class="leancloud-visitors-count"></span>
    </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2021/08/13/Java/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2021/08/13/Java/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>24k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>22 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210831130537444.png" alt="image-20210831130537444"></p>
<p>最近在复盘 Java 基础，有些在之前的学习过程中遗忘，现在进行查缺补漏。</p>
<a id="more"></a> 

<h1 id="Java语言学习"><a href="#Java语言学习" class="headerlink" title="Java语言学习"></a>Java语言学习</h1><h2 id="Day01"><a href="#Day01" class="headerlink" title="Day01"></a>Day01</h2><h2 id="Day02"><a href="#Day02" class="headerlink" title="Day02"></a>Day02</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>命名规范：</p>
<p>类名：XxxYyyZzz </p>
<p>包名：xxxyyyzzz</p>
<p>常量名、方法名还有多单词首字母大写时：xxxYyyZzz</p>
<p>常量名：所有字母都大写，多单词用下划线 XXX_YYY_ZZZ，除此之外还要见名知意。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量必须先声明再赋值</p>
<h4 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h4><p><strong>8种基本数据类型：</strong></p>
<p>byte：1字节，占8bit（位）、bit不是存0就是存1，标识范围：-128～127（-2*2的7次方～2的7次方-1）。</p>
<p>short：2字节。</p>
<p>int：4字节，经常用。</p>
<p>long：8字节：声明long型的变量，必须以l或者L结尾。只是标示一下。</p>
<p>float：4字节，精度有限，单精度，虽然也占4个字节，但是要比int表示的范围还要大。定义float类型要以f或者F结尾，只是标示。</p>
<p>doublt：8字节，双精度，精度要高。要用浮点型的话，经常用double，但是不如float存的多。</p>
<p>char：（1个字符等于2个字节，16位）例：char c1= ‘a’，只能写一个字符，不能写两个。char c2 = ‘\n’,表示换行</p>
<p>boolean：只能有两个值，一个是true，一个是false。</p>
<p><u>字符集，所有的东西在存储的时候都是01010…..，但是展现的时候是丰富多彩的，a = 3 ，美国的ASCII规定了每个字符代表着什么，比如，a为97，但是中国却不能一一对应，Unicode是使用最广的一种，但是落地的是UTF-8，我们都是用它。</u></p>
<p><strong>3种引用类型：</strong>（以后再说）</p>
<p>class：</p>
<p>interface</p>
<p>[]数组（字符串是一个类类型）</p>
<p><strong>7种基本数据类型（不包括boolean）之间的运算规则</strong>：</p>
<p>byte、char、short –&gt;int –&gt; long –&gt;float –&gt; double</p>
<ul>
<li>自动类型提升：</li>
</ul>
<ol>
<li>byte和int类型做运算，转为int型，转为long型也可以，使用float型也可以，会补小数点。</li>
<li>char和int做运算，转为int类型，但是byte和char还要short俩俩做运算时，只能使用int型。</li>
</ol>
<p><strong>总结：</strong>当容量小的变为数据类型转位容量大的类型的时候，自动提升为容量大的。</p>
<ul>
<li>强制类型转换（自动类型提升的逆运算）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> b1 = <span class="number">12.3</span></span><br><span class="line"><span class="keyword">int</span> i1 = (<span class="keyword">int</span>)b1</span><br><span class="line">结果：<span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>强制转换可能会导致精度损失</p>
<p><strong>String</strong></p>
<p>String属于引用数据类型，翻译为字符串，是可以和8种数据类型做运算的，且运算只能是连接运算，</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>要不停的敲，不停的写代码，边写边想，强化记忆，刚开始拿来题目不会很正常，但是要想且要敲就好了。</p>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>+、-、*、/、%、++、–、+（字符串连接）</p>
<p>a++、++a、（先写先加，后写后加），这种自增1不会改变原来的数据类型。</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>=、+=、-=、*=、/=，%=</p>
<p>+=：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> s1 = <span class="number">10</span>;</span><br><span class="line">s1 = s1 +<span class="number">2</span>;</span><br><span class="line">s1 += <span class="number">2</span>;</span><br><span class="line">第一种不会改变变量本身的数据类型，第二种会改变本身的数据类型。</span><br></pre></td></tr></table></figure>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>(结果是boolean型)</p>
<p>==、!=、&lt;、&gt;、&lt;=、&gt;=、instanceof</p>
<h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算符只能适用于布尔类型的变量</p>
<p>&amp;（逻辑与）、|（逻辑或）、！（逻辑非）、&amp;&amp;(短路与)、||（短路或）、^ （逻辑异或）</p>
<p>&amp;（逻辑与）：全为真才为真</p>
<p>|（逻辑或）：有一个为真就是真</p>
<p>&amp;&amp;(短路与)：全是真才为真</p>
<p>||（短路或）：有一个真就是真</p>
<p>^ （逻辑异或）：相同为false，不同就为true。</p>
<p>问题1:<strong>&amp;和&amp;&amp;之间的相同点与区别</strong></p>
<ol>
<li>都表示且对关系，只有当都满足（true）的时候才才为真</li>
<li>当左边是true 的时候，右边都执行。</li>
<li>当左边是false 的时候，&amp;&amp;左边为false 的时候，右边就不执行了。</li>
</ol>
<h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>&lt;&lt;（左移）、&gt;&gt;（右移）、&gt;&gt;&gt;（无符号右移）、&amp;（与运算）、|（或运算）、^（异或运算） 、～（）取反运算</p>
<h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>（条件表达式）？表达式1:表达式2；</p>
<p>true：执行表达式1，false：执行表达式2</p>
<p>三元运算符是可以嵌套的，除此之外，凡是可以使用三元运算符的，都是可以使用if else语句的。但是反过来是不一定的。</p>
<h4 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h4><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>if … else</p>
<p>switch….</p>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>for循环、while循环、do while循环</p>
<p><strong>break与continue的关系</strong></p>
<p>break应用在switch-case循环结构中，当调用break时，是结束<strong>当前</strong>循环</p>
<p>continue应用在循环结构中，只是结束<strong>当次</strong>循环。</p>
<h2 id="day06"><a href="#day06" class="headerlink" title="day06"></a>day06</h2><ol>
<li>Eclipse中的workspace就是工作空间，把所有的代码自动放在一个空间里。</li>
<li>eclipse导入到工作空间中，如果工作空间中有一个相同的项目，更改名字是不能够导入的，这时候要改一下工作空间中的项目名字，再把项目整进去，可以选择复制进去，然后进行删除页面的项目。</li>
<li>关于单个文件的乱码问题，可以单独用记事本打开，然后另存为UTF-8的格式，然后再粘进去。Notepad软件能够直接更改格式。</li>
</ol>
<h2 id="day08"><a href="#day08" class="headerlink" title="day08"></a>day08</h2><p>内存中的区域：方法区、虚拟机栈、本地方法栈、堆、程序计数器。</p>
<h2 id="day09"><a href="#day09" class="headerlink" title="day09"></a>day09</h2><ol>
<li><p>可变形参方法的函数中，如过还有一个确定的形参，需要把确定的形参放到前面，可变形参放到后面。</p>
</li>
<li><p>可变形参数一个方法只能有一个。</p>
</li>
<li><p>关于值传递机制：形参接受的是实参的地址值。</p>
</li>
</ol>
<h2 id="day10"><a href="#day10" class="headerlink" title="day10"></a>day10</h2><p>java规定的四种权限修饰符，private、缺省、provated、public</p>
<p>修饰类的话只能是public或者是缺省。其他的不能修饰类。</p>
<p>任何一个类，都有构造器。constructor：建造者。</p>
<p>默认的构造器的权限跟类的权限相同。</p>
<p>构造器的作用：</p>
<ol>
<li>创建对象。</li>
<li>还可以进行对对象进行初始化。</li>
</ol>
<p>new + 构造器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<p>只要显示定义了构造器，系统就不再提供空参构造器。</p>
<p>属性赋值的先后顺序：1.默认初始化值、2.显示初始化值（在类的属性中进行赋值）3.构造器赋值、4.方法赋值</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>可以修饰：属性、方法、构造器</p>
<p>this理解为：当前对象或者为正在创建的对象，可以this.属性或者this.方法，一般我们都不写this，但是当方法的形参和类的属性同名的时候，就要使用this。</p>
<p>this可以修饰构造器</p>
<p>原因：当不同构造器中含有很多相同的方法，除了把相同的方法写成一个函数，也可以调用构造器。</p>
<p>如果一个类中有n个构造器，那么最多有（n-1）个构造器使用了this（形参列表）</p>
<p>this（构造器）一定要放在构造器的首行。</p>
<p>构造器内部只能声明一个this（形参列表），用来调用其他的构造器。</p>
<h2 id="day12"><a href="#day12" class="headerlink" title="day12"></a>day12</h2><p>关于多态：</p>
<p>这里Person是父类，Man是子类。这里是：父亲的引用指向子类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = <span class="keyword">new</span> Man</span><br></pre></td></tr></table></figure>

<p>这里面执行的是子类重写父类的方法（work()方法在子类的方法中重写过）也就是子父类都有walk()方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.work()</span><br></pre></td></tr></table></figure>

<p>而earnMoney()方法是子类特有的方法，但是p2.earnMoney()是不能调用的，因为父类中没有</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p2.earnMoney()</span><br></pre></td></tr></table></figure>

<p>多态时是运行时行为，</p>
<p>使用前提：1⃣️ 类的继承 2⃣️方法的重写</p>
<p>说明：</p>
<ol>
<li><p>如果子父类有一个相同的属性，在new完对象的时候，如果调用子父类都有的属性，调用的是父类的属性，所以说，多态适合于方法，而不适合于属性，</p>
</li>
<li><p>有了对象以后，我们在编译期，只能调用父类声明的方法，但在运行期，执行的是子类重写父类的方法。</p>
<p>有了对象的多态性以后，内存中实际上是加载了子类的属性和方法的，到那时由于变量声明为父类类型，</p>
<p>导致编译时，只能调用父类声明的属性和方法，子类特有的属性和方法不能够调用。</p>
</li>
</ol>
<p>如何能调用子类特有的属性和方法？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Man m1 = (Man)p2</span><br></pre></td></tr></table></figure>

<p>这里p2是父类类型的对象，进行父类向子类对象进行强转。也就是<strong>向下转型</strong>（父类向子类转）</p>
<p>使用强转时，可能会造成ClassCastExceotion的异常，比如Momen和Man都是Person的子类，但是如果这样使用就会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Women w1 = (Women)p2</span><br></pre></td></tr></table></figure>

<p>这样会报错，这里引入：instanceof关键字，使用情景，为了避免在向下转型出现异常，使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a <span class="keyword">instanceof</span> A</span><br></pre></td></tr></table></figure>

<p>如果是，那就继续执行，不是就不执行了。</p>
<p>如果a instanceof A为true，那么a instance B也一定对，那么B一定是A 的父类。</p>
<p>== 和equals() 的区别</p>
<p>== ：运算符</p>
<ol>
<li>可以使用在基本数据类型变量和引用数据类型变量中(但如果比较多是基本数据类型，知识比较多数据是否相等，类型不一定相同)</li>
<li>如果比较的是引用数据类型，那么比较多两个对象的地址值是不是相同。</li>
</ol>
<p>equals()：是一个方法</p>
<ol>
<li>只适用于引用数据类型 。</li>
<li>Object类中的equals()中与 == 相同。</li>
<li>但是，像String、Date、File等包装类都重写了Object类中的equals()，重写以后，比较的不是引用的地址值是不是相同，而是比较的是两个对象的“实体内容”是不是相同。</li>
</ol>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210817201217488.png" alt="image-20210817201217488"></p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>视频301</p>
<h3 id="基本数据类型与包装类"><a href="#基本数据类型与包装类" class="headerlink" title="基本数据类型与包装类"></a>基本数据类型与包装类</h3><p>int对应与Integer类，一般我们都需要进行如下操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">Intenger int1 = <span class="keyword">new</span> Intenger(i);</span><br></pre></td></tr></table></figure>

<p>此时，int1就为Integer 的对象，但是以下操作也是正确的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num2 = <span class="number">10</span>;</span><br><span class="line">Integer int1 = num2;</span><br></pre></td></tr></table></figure>

<p>这里面设计自动封箱，以前还需要进行包装，现在是不需要进行包装。</p>
<p>自动装箱和自动拆箱是JDK 5.0以后才有的，拿过来使用即可。</p>
<p>基本数据类型、包装类 —&gt; String类型：调用String重载的valueof()</p>
<p>重点：基本数据类型和包装类 转 String 使用valueof(),String转为基本数据类型、包装类的时候使用parseXXX(String).</p>
<h2 id="day14"><a href="#day14" class="headerlink" title="day14"></a>day14</h2><p>如果在类中声明了static类型的，那就不归某一个对象所拥有，所有创建的对象，都有static的这部分，翻译为静态的</p>
<p>static可以修饰：属性、方法、代码块、内部类。不能修饰构造器。</p>
<ol>
<li>static修饰属性叫做静态变量，</li>
</ol>
<p>属性：按是否使用static修饰，氛围静态属性 vs 非静态属性（实例变量）。</p>
<p>静态变量随着类的加载而加载，静态变量加载要早于对象的创建。由于类只加载一次，所以，静态变量也只加载一次，存在于<strong>方法区的静态域</strong>中。</p>
<p>举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println()</span><br></pre></td></tr></table></figure>

<p>没有声明但是可以进行使用，就因为是静态变量，不需要创建对象就可以使用。</p>
<ol>
<li>static修饰方法</li>
</ol>
<p>随着类的加载而加载，也就是说，在不创建对象的时候，也是可以进行调用的。</p>
<p>静态方法中，只能调用静态的方法或者属性</p>
<p>非静态方法中，既可以进行调用非静态的属性和方法，也可以调用静态的方法和属性。</p>
<p>开发中，如何确定一个属性是否应该声明为static的？</p>
<ul>
<li>属性不会随着对象的不同而不同的。</li>
</ul>
<p>开发中，如何确定一个属性是否应该声明为static的？</p>
<ul>
<li>如果一个属性被设置为静态的，调用这些属性的时候不需要造对象。还有一些经常用的工具类，也经常设置为静态的。</li>
</ul>
<p>饿汉式：一上来就造好了。</p>
<p>懒汉式：啥时候用啥时候造，属于懒汉式，什么时候用什么时候造。</p>
<p>区分饿汉式和懒汉式，（一般懒汉式比较好，延迟对象的创建）</p>
<p>饿汉式：坏处，对象加载时间过长，好处：线程安全的。</p>
<p>懒汉式：好处：延迟对象的创建，坏处：目前线程不安全，到多线程的时候在进行修改。</p>
<p>单例模式应用场景：</p>
<ol>
<li>网站的计数器</li>
<li>应用程序的日志应用</li>
<li>数据库连接池</li>
<li>读取配置文件的类</li>
<li>Application也是单例</li>
<li>windows 的任务管理器及回收站也是单例模式。</li>
</ol>
<h2 id="day15"><a href="#day15" class="headerlink" title="day15"></a>day15</h2><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>代码块也叫做初始化块，写在类里面哪里都可以，使用一对大括号{}表示</p>
<p>代码块的作用：用来初始化类、对象，<strong>只能使用static 修饰</strong>，不能使用其他的修饰</p>
<p>于是分为：<strong>静态代码块、非静态代码块</strong></p>
<ul>
<li>静态代码块</li>
</ul>
<ol>
<li>内部可以有输出语句</li>
<li><strong>随着类的加载而执行，而且只加载一次，</strong>静态方法是随着类的加载而加载，但是不调用就不会起作用，而静态代码块只要是类加载进去，就被调用。作用<strong>是可以初始化类的一些信息</strong>。</li>
<li>如果定义了多个静态代码块，那么按照先后顺序进行执行。</li>
<li>静态代码块的执行要优于非静态代码块的执行。</li>
<li>对于静态代码块内，只能调用静态的属性和方法，不能调用非静态的结构。</li>
</ol>
<ul>
<li>非静态代码块</li>
</ul>
<ol>
<li>内部可以有输出语句</li>
<li><strong>随着对象的创建而执行，</strong>每造一个对象就执行一次非静态代码块。也就是说，在创建对象时，<strong>对对象的属性进行初始化。</strong></li>
<li>如果定义了多个非静态代码块，那么按照先后顺序进行执行。</li>
<li>非静态代码块，可以调用静态的属性、静态的方法、或者非静态的属性、非静态的方法。</li>
</ol>
<p>对属性可以赋值的位置：</p>
<ol>
<li>默认初始化</li>
<li>显示初始化/在代码块中进行赋值（谁在前面谁先执行）</li>
<li>构造器中初始化</li>
<li>有了对象以后，可以通过“对象.属性”或”对象.方法”进行赋值。</li>
</ol>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p>final关键字可以修饰的结构：类、方法、变量</p>
<ul>
<li><p>final修饰类的时候：代表该类没有子类，绝了。像是String类、System类、StringBufffer类就是final的。</p>
</li>
<li><p>修饰方法的时候；表示该方法不能被子类进行重写，比如Object类中的getClass()方法就是final的。</p>
</li>
</ul>
<p>这里涉及到native关键字,native代表着调用底层的c或者c++</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<ul>
<li>final修饰变量，那么变量就变为常量，<ul>
<li>final修饰属性：可以考虑赋值的位置；显示初始化、代码块中赋值、构造器中初始化、其他的都不行</li>
<li>final修饰局部变量（局部变量有方法内部的局部变量，另一种是形参）<ul>
<li>尤其是使用final修饰形参时，这时候表明此形参为常量。当我们调用此方法时，会穿入一个数值，一旦传入后，就没办法改变了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>satatic final 组合可以修饰属性（我们成为全局常量）和方法（用的比较少）</p>
<h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><p>abstract关键字的使用</p>
<p>可以修饰类、方法（不可以修饰属性、构造器，也不能修饰私有方法和静态方法、final 的方法、final的类）</p>
<p>使用abstract修饰类的时候，一旦修饰类，就不能创建对象了，也就是不能实例化了。但是其子类可以进行创建对象，子类创建对象的时候，回调用父类中构造器，所有父类的构造器还是有用的。</p>
<p>修饰方法的时候，就没有方法体了,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>包含抽象方法的类，一定是抽象类。反之，抽象类是可以没有抽象方法的。</strong></p>
<p>子类继承抽象类的时候，要么重写一下，要么也写为抽象类。如果重写了父类的所有抽象方法的时候，此时子类才可以进行实例化。若子类没有全部重写抽象方法，那么子类也需要写为抽象类。</p>
<h3 id="匿名对象于抽象类的匿名子类"><a href="#匿名对象于抽象类的匿名子类" class="headerlink" title="匿名对象于抽象类的匿名子类"></a>匿名对象于抽象类的匿名子类</h3><p>匿名对象：只是new出来的一个对象，并没有进行赋值</p>
<p>抽象类的匿名子类</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口和类属于并列关系，但是在java中只能进行单继承，不能进行多继承，使用接口就可以实现多重继承的效果。</p>
<p>有时候我们需要在几个类中抽取一些相同的特征，但是他们之间有不适is-a的关系，只是具有相同行为的特征。</p>
<p>接口使用interface关键字</p>
<h4 id="如何定义接口"><a href="#如何定义接口" class="headerlink" title="如何定义接口"></a>如何定义接口</h4><p>接口中可以定义的成员：</p>
<p>JDK7及以前：只能定义全局常量和抽象方法</p>
<ul>
<li>全局常量：public static final 的，但是书写时可以不写public static final</li>
<li>抽象方法：public abstract 的</li>
</ul>
<p>JDK8：除了定义全局常量和抽象方法以外，还可以定义静态方法、默认方法（略）</p>
<p>接口中是不能定义构造器的，也就是说接口是不能进行实例化的</p>
<p>在java开发中，接口通过让类实现（implements）的方式来使用，如果实现类实现了抽象类中的所有抽象方法，那么此类就可以进行实例化。如果没有全部实现，那么此类还是抽象类，需要加入abstract。</p>
<p>java类可以实现多个接口，于是就弥补了单继承的局限性。</p>
<p>格式：class AA extends BB implements CC,DD,EE</p>
<p>接口和接口之间的关系是：继承，而且还是多继承，不像类一样只可以进行单继承。</p>
<h4 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h4><p>接口的具体使用，体现了多态性，接口实际上可以看做一种规范。（具体不明白接口定义了规范看视频351）</p>
<ol>
<li><p>在JDK8以后，如果在接口中定义了静态方法，子类实现接口的时候，并且在创建子类对象的时候，子类对象是拿不到接口中定义的静态方法。只能通过接口来调用，这时接口就有点像工具类了。</p>
</li>
<li><p>如果是默认方法，通过子类的实现接口，并且创建子类对象是可以调用默认方法的。如果想重写，直接在子类中进行重写。</p>
</li>
<li><p>如果一个子类继承了父类并且实现了一个接口，但是此时父类有一个和实现接口相同的同名同参数的默认方法，此时在子类实例中调用的时候，优先考虑父类中的方法，成为类优先原则。</p>
</li>
<li><p>如果一个子类只是实现了多个接口，但是接口中有相同的同名同参数的默认方法，那么在实现类中没有重写此方法的情况下，会报错，接口冲突，解决冲突就需要在子类中进行重写方法。</p>
</li>
<li><p>如何在子类的方法中调用父类、接口中重写的方法？</p>
<p>形式：接口.super.方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CompareA.<span class="keyword">super</span>.method();</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B就是内部类，类A就成为内部类</p>
<p>内部类有分为成员内部类和局部内部类，成员内部类和属性并列，局部内部类是定义在（类方法、代码块、构造器）里面的类。</p>
<p>成员内部类也是可以定义类的所有东西，可以被final修饰，可以被abstract修饰（不可被实例化）</p>
<h2 id="day16"><a href="#day16" class="headerlink" title="day16"></a>day16</h2><p>异常处理分为：Error和Exception,这里主要说明一下Exception。</p>
<p>Exception又分为编译时异常(非受检异常)和运行时异常(受检异常)</p>
<p>面试题：常见的异常有哪些？举例说明。</p>
<p>编译时异常：IOException、ClassNotFondException</p>
<p>运行时异常：</p>
<ul>
<li>NullPointerException(空指针异常)</li>
<li>ArrayIndexOutOfBoundException(数组角标越界)还有字符串角标越界</li>
<li>ClassCastException(类型转换异常)</li>
<li>NumberFormatException</li>
<li>InputMismatchException(输入不匹配异常)</li>
<li>ArithmeticException(算数异常)</li>
<li>······</li>
</ul>
<h3 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h3><p>两种方式：</p>
<p>方式一：Try-catch-finally</p>
<p>方式二：throws+异常类型</p>
<p>异常的处理：抓抛模型</p>
<p>过程一：“抛”：程序在执行的过程中，一旦出现异常，就会在异常代码出生成一个异常类对象。并将此对象抛出，一旦抛出异常对象以后，其后的代码就不再执行了。</p>
<p>过程二：“抓”：可以理解为异常处理的方式，也就是上面的两种方式。</p>
<h3 id="Try-catch-finally的使用"><a href="#Try-catch-finally的使用" class="headerlink" title="Try-catch-finally的使用"></a>Try-catch-finally的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//可能出现的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="comment">//处理异常类型的1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally是可选的，如果没得，如果在try{}里面出现异常，会出现一个异常类的对象，如果被捕获切匹配成功，则说明匹配，以后的catch{}就不执行了，跳出try-catch结构。继续执行后面的代码。</p>
<p>说明：catch中的异常类型，如果没有子父类关系，谁先谁后无所谓，如果是含有子父类关系，那么要求子类在先，父类在后，不这样做就会报错，显示后面的catch不可到达。</p>
<p>常用的异常对象处理的方式：1⃣️String getMessage() 2⃣️2printStackTrace</p>
<p>注意：在try{}里面声明的变量，出了结构以后就不能用了。解决方法：可以在外面声明，在里面进行赋值。</p>
<p>使用try-catch-finally处理编译时异常时，使得程序不在报错，但是在运行时可不一定不报错。</p>
<p>finally中声明的都是一定被执行的代码，即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</p>
<p>什么写在finally块内？</p>
<ul>
<li>想数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要手动的对资源进行释放，此时写在finally内。</li>
</ul>
<p>try-catch-finally也是可以进行嵌套的。</p>
<p>现实开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了，我们只针对编译型异常进行处理。</p>
<h3 id="thows-异常类型"><a href="#thows-异常类型" class="headerlink" title="thows+异常类型"></a>thows+异常类型</h3><p>样例：</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210817195846461.png" alt="image-20210817195846461"></p>
<p>throws + 异常类型写在方法的声明处，指明此方法执行时，可能会抛出的异常，一旦方法体执行时，出现异常，仍会在异常代码处声明一个异常类，此对象满足throws后异常类型时，就会被抛出，异常代码的后续代码，就不再执行了。</p>
<p>try-catch-finally :真正的将异常处理掉了</p>
<p>throws：只是把异常抛给了方法的调用者，并没有真正解决异常。</p>
<h3 id="如何选择？"><a href="#如何选择？" class="headerlink" title="如何选择？"></a>如何选择？</h3><p>如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法有异常，则必须使用try-catch-finally方式进行处理。    </p>
<p>关于异常的产生？</p>
<ol>
<li>系统自动生成</li>
<li>手动生成一个异常对象，并抛出(throw), 注意：throw 与throws不一样。</li>
</ol>
<h3 id="用户自定义异常类"><a href="#用户自定义异常类" class="headerlink" title="用户自定义异常类"></a>用户自定义异常类</h3><h4 id="如何自定义异常类？"><a href="#如何自定义异常类？" class="headerlink" title="如何自定义异常类？"></a>如何自定义异常类？</h4><ol>
<li>写一个类继承于现有的异常类：RuntimeException或Exception</li>
<li>提供全局常量：serialVersionUID，可以模仿父类里面的写，可以理解为对类的标识。</li>
<li>提供重载的构造器</li>
</ol>
<h4 id="异常处理练习：视频382"><a href="#异常处理练习：视频382" class="headerlink" title="异常处理练习：视频382"></a>异常处理练习：视频382</h4><h3 id="throws与throw-的不同"><a href="#throws与throw-的不同" class="headerlink" title="throws与throw 的不同"></a>throws与throw 的不同</h3><p>他俩没什么关系，顶多是在讲异常的时候一起讲的。</p>
<p>throws是异常处理的一种方式，声明在方法的声明处。</p>
<p>而throw是生成一个异常对象声明在方法体内，抛出对象的一种情况。</p>
<h2 id="day17"><a href="#day17" class="headerlink" title="day17"></a>day17</h2><h2 id="day18-多线程"><a href="#day18-多线程" class="headerlink" title="day18 多线程"></a>day18 多线程</h2><h3 id="基本概念：程序、进程、线程"><a href="#基本概念：程序、进程、线程" class="headerlink" title="基本概念：程序、进程、线程"></a>基本概念：程序、进程、线程</h3><p><strong>程序</strong>(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。<br><strong>进程</strong>(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期<br>例如：运行中的QQ，运行中的MP3播放器，程序是静态的，进程是动态的</p>
<p>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域<br><strong>线程</strong>(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。</p>
<ul>
<li><p>若一个进程同一时间并行执行多个线程，就是支持多线程的</p>
</li>
<li><p>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</p>
</li>
<li><p>一个进程中的多个线程共享相同的内存单元/内存地址空间à它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。</p>
</li>
</ul>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210818200735250.png" alt="image-20210818200735250"></p>
<h3 id="多线程创建的方式"><a href="#多线程创建的方式" class="headerlink" title="多线程创建的方式"></a>多线程创建的方式</h3><p>方式一：继承与Thread类</p>
<ol>
<li>写一个类继承于Thread类</li>
<li>重写Thread类里面的run()方法，把要执行的代码写在此方法里。</li>
<li>创建Thread类的子类对象</li>
<li>通过此对象调用start()方法</li>
</ol>
<p>方式二：实现Runnable接口</p>
<ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start()</li>
</ol>
<p>比较创建线程的两种方式:</p>
<ul>
<li><p>开发中：优先选择：实现Runnable接口的方式</p>
</li>
<li><p>原因：</p>
<ol>
<li><p>实现的方式没有类的单继承性的局限性</p>
</li>
<li><p>实现的方式更适合来处理多个线程有共享数据的情况。</p>
</li>
</ol>
</li>
<li><p>联系：public class Thread implements Runnable</p>
</li>
<li><p>相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。</p>
</li>
</ul>
<p>发现：Thread类本身也是实现类Runnable接口，方式一是继承Thread类，然后重写父类的run()方法，方式二是直接进行实现Runnable()接口，进而重写run()方法。</p>
<h3 id="测试Thread中的常用方法："><a href="#测试Thread中的常用方法：" class="headerlink" title="测试Thread中的常用方法："></a>测试Thread中的常用方法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1. start():启动当前线程；调用当前线程的run()</span><br><span class="line">2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中</span><br><span class="line">3. currentThread():静态方法，返回执行当前代码的线程</span><br><span class="line">4. getName():获取当前线程的名字</span><br><span class="line">5. setName():设置当前线程的名字</span><br><span class="line">6. yield():释放当前cpu的执行权</span><br><span class="line">7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才结束阻塞状态。</span><br><span class="line">8. stop():已过时。当执行此方法时，强制结束当前线程。</span><br><span class="line">9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前线程是阻塞状态。</span><br><span class="line">10. isAlive():判断当前线程是否存活</span><br></pre></td></tr></table></figure>

<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MAX_PRIORITY：10</span><br><span class="line">MIN _PRIORITY：1</span><br><span class="line">NORM_PRIORITY：5  --&gt;默认优先级</span><br></pre></td></tr></table></figure>

<p>如何获取和设置当前线程的优先级：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getPriority():获取线程的优先级</span><br><span class="line">setPriority(int p):设置线程的优先级</span><br><span class="line">说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。</span><br></pre></td></tr></table></figure>

<h3 id="线程的声明周期"><a href="#线程的声明周期" class="headerlink" title="线程的声明周期"></a>线程的声明周期</h3><p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210821101501463.png" alt="image-20210821101501463"></p>
<h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><p>问题；在买票过程中，出现重票、错票。就会导致线程安全问题</p>
<h2 id="Java常用类"><a href="#Java常用类" class="headerlink" title="Java常用类"></a>Java常用类</h2><h3 id="字符串相关的类"><a href="#字符串相关的类" class="headerlink" title="字符串相关的类"></a>字符串相关的类</h3><p>String：字符串，使用一对””引起来表示。</p>
<ol>
<li><p>String声明为final的，不可被继承</p>
</li>
<li><p>String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小</p>
</li>
<li><p>String内部定义了final char[] value用于存储字符串数据</p>
</li>
<li><p>String:代表不可变的字符序列。简称：不可变性。<br>体现：</p>
<p>1.当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。</p>
<ol start="2">
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。</li>
<li>当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。 </li>
</ol>
</li>
<li><p>通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
</li>
<li><p>字符串常量池中是不会存储相同内容的字符串的。</p>
</li>
</ol>
<p>String的实例化方式：<br>    方式一：通过字面量定义的方式<br>    方式二：通过new + 构造器的方式</p>
<p><strong>面试题</strong>：String s = new String(“abc”);方式创建对象，在内存中创建了几个对象？<br>            两个:一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210830132449790.png" alt="image-20210830132449790"></p>
<p>关字符串的拼接：</p>
<ol>
<li>常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。</li>
<li>只要其中有一个是变量，结果就在堆中。</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li>
</ol>
<p><strong>字符串相关的方法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span>：返回字符串的长度： return value.length</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span>： 返回某索引处的字符return value[index]</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：判断是否是空字符串：return value.length </span>== <span class="number">0</span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为小写</span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span>：使用默认语言环境，将 String 中的所有字符转换为大写</span></span><br><span class="line"><span class="function">String <span class="title">trim</span><span class="params">()</span>：返回字符串的副本，忽略前导空白和尾部空白</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span>：比较字符串的内容是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：与equals方法类似，忽略大小写</span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span>：将指定字符串连接到此字符串的结尾。 等价于用“+”</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span>：比较两个字符串的大小</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span>：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> ：返回一个新字符串，它是此字符串从beginIndex开始截取到<span class="title">endIndex</span><span class="params">(不包含)</span>的一个子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span>：测试此字符串是否以指定的后缀结束</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span>：测试此字符串是否以指定的前缀开始</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span>：当且仅当此字符串包含指定的 <span class="keyword">char</span> 值序列时，返回 <span class="keyword">true</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中第一次出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span>：返回指定子字符串在此字符串中最右边出现处的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">注：indexOf和lastIndexOf方法如果未找到都是返回-1</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">替换：</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span>：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</span></span><br><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">匹配:</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span>：告知此字符串是否匹配给定的正则表达式。</span></span><br><span class="line"><span class="function">切片：</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span>：根据给定正则表达式的匹配拆分此字符串。</span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</span></span><br></pre></td></tr></table></figure>

<p><strong>String 与基本数据类型、包装类之间的转换。</strong></p>
<p>String –&gt; 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)</p>
<p>基本数据类型、包装类 –&gt; String:调用String重载的valueOf(xxx)</p>
<p><strong>String 与 char[]之间的转换</strong></p>
<p>String –&gt; char[]:调用String的toCharArray()</p>
<p>char[] –&gt; String:调用String的构造器</p>
<p><strong>String 与 byte[]之间的转换</strong></p>
<p>编码：String –&gt; byte[]:调用String的getBytes()</p>
<p>解码：byte[] –&gt; String:调用String的构造器</p>
<p>编码：字符串 –&gt;字节  (看得懂 —&gt;看不懂的二进制数据)</p>
<p>解码：编码的逆过程，字节 –&gt; 字符串 （看不懂的二进制数据 —&gt; 看得懂）</p>
<p>说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。</p>
<p><strong>String、StringBuffer、StringBuilder三者的异同？</strong></p>
<p>String:不可变的字符序列；相同点：底层使用char[]存储</p>
<p>StringBuffer:可变的字符序列；线程安全的，效率低；底层使用char[]存储</p>
<p>StringBuilder:可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer的常用方法：</span><br><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span>：提供了很多的<span class="title">append</span><span class="params">()</span>方法，用于进行字符串拼接</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>：删除指定位置的内容</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span>：把[start,end)位置替换为str</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span>：在指定位置插入xxx</span></span><br><span class="line"><span class="function">StringBuffer <span class="title">reverse</span><span class="params">()</span> ：把当前字符序列逆转</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span>:返回一个从start开始到end索引结束的左闭右开区间的子字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">总结：</span></span><br><span class="line"><span class="function">增：<span class="title">append</span><span class="params">(xxx)</span></span></span><br><span class="line"><span class="function">删：<span class="title">delete</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">改：<span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> n ,<span class="keyword">char</span> ch)</span> / <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span></span><br><span class="line"><span class="function">查：<span class="title">charAt</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">插：<span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span></span></span><br><span class="line"><span class="function">长度：<span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">遍历：<span class="keyword">for</span>() + charAt() / toString()</span><br></pre></td></tr></table></figure>

<h3 id="时间日期API"><a href="#时间日期API" class="headerlink" title="时间日期API"></a>时间日期API</h3><p>（未学）</p>
<h2 id="枚举类与新注解"><a href="#枚举类与新注解" class="headerlink" title="枚举类与新注解"></a>枚举类与新注解</h2><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><p>一、枚举类的使用</p>
<p>1.枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p>
<p>2.当需要定义一组常量时，强烈建议使用枚举类</p>
<p>3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式。</p>
<p>二、如何定义枚举类</p>
<p>方式一：jdk5.0之前，自定义枚举类</p>
<p>方式二：jdk5.0，可以使用<strong>enum</strong>关键字定义枚举类</p>
<p>三、Enum类中的常用方法：</p>
<p>**values()**方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</p>
<p>**valueOf(String str)**：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。</p>
<p>**toString()**：返回当前枚举类对象常量的名称</p>
<p>四、使用enum关键字定义的枚举类实现接口的情况</p>
<p>情况一：实现接口，在enum类中实现抽象方法</p>
<p>情况二：让枚举类的对象分别实现接口中的抽象方法</p>
<h3 id="注解（Annotation）"><a href="#注解（Annotation）" class="headerlink" title="注解（Annotation）"></a>注解（Annotation）</h3><ol>
<li>注解的使用</li>
</ol>
<p>理解Annotation:</p>
<p>① jdk 5.0 新增的功能</p>
<p>② Annotation 其实就是代码里的特殊标记, 这些标记可以在编译, 类加载, 运行时被读取, 并执行相应的处理。</p>
<p>通过使用 Annotation,程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息。</p>
<p>③在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等。</p>
<ol start="2">
<li>Annocation的使用示例</li>
</ol>
<p>示例一：生成文档相关的注解</p>
<p>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</p>
<p>@Override: 限定重写父类方法, 该注解只能用于方法</p>
<p>@Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择</p>
<p>@SuppressWarnings: 抑制编译器警告</p>
<p>示例三：跟踪代码依赖性，实现替代配置文件功能</p>
<ol start="3">
<li>如何自定义注解：参照@SuppressWarnings定义</li>
</ol>
<p>① 注解声明为：@interface</p>
<p>② 内部定义成员，通常使用value表示</p>
<p>③ 可以指定成员的默认值，使用default定义</p>
<p>④ 如果自定义注解没有成员，表明是一个标识作用。</p>
<p>如果注解有成员，在使用注解时，需要指明成员的值，但是有默认值就不需要指定了 。自定义注解必须配上注解的信息处理流程(使用反射)才有意义。</p>
<p><strong>自定义注解通过都会指明两个元注解：Retention、Target</strong></p>
<ol start="4">
<li>jdk 提供的4种元注解 （元注解就是修饰其他注解的注解）（顺便说一下元数据，对现有数据的进行修饰的数据）</li>
</ol>
<p>元注解：对现有的注解进行解释说明的注解</p>
<p><strong>Retention：</strong>指定所修饰的 Annotation 的生命周期：<strong>SOURCE、CLASS（默认行为）、RUNTIME</strong>，只有声明为</p>
<p>RUNTIME生命周期的注解，才能通过反射获取。</p>
<p><strong>Target：</strong>用于指定被修饰的 Annotation 能用于修饰哪些程序元素</p>
<p><strong>Documented：</strong>表示所修饰的注解在被javadoc解析时，保留下来。</p>
<p><strong>Inherited：</strong>被它修饰的 Annotation 将具有继承性。</p>
<ol start="5">
<li><p>通过反射获取注解信息 —到反射内容时在讲解</p>
<ol start="6">
<li>jdk 8 中注解的新特性：可重复注解、类型注解</li>
</ol>
<p>6.1 可重复注解：① 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class</p>
<pre><code>         ② MyAnnotation的Target和Retention等元注解与MyAnnotations相同。</code></pre>
<p>6.2 类型注解：<br>ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中（如：泛型声明）。<br>ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
</li>
</ol>
<h2 id="java集合"><a href="#java集合" class="headerlink" title="java集合"></a>java集合</h2><p>一、集合框架的概述</p>
<p>1.集合、数组都是对多个数据进行存储（针对内存层面）操作的结构，简称 Java容器。</p>
<p>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt,.jpg,.avi，数据库中）</p>
<p>2.1 数组在存储多个数据方面的特点：</p>
<ul>
<li><p>一旦初始化以后，其长度就确定了。（长度确定）</p>
</li>
<li><p>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了。（类型确定）</p>
<ul>
<li>比如：String[] arr;int[] arr1;Object[] arr2;</li>
</ul>
</li>
</ul>
<p>2.2 数组在存储多个数据方面的缺点：</p>
<ul>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。 </li>
</ul>
<p>二、集合框架 （两个接口 Collection 和 Map，两个并列）</p>
<ul>
<li><p>Collection接口：单列集合，用来存储一个一个的对象</p>
<ul>
<li>List接口：存储有序的、可重复的数据。  –&gt;“动态”数组<ul>
<li>ArrayList、LinkedList、Vector （主要实现类）</li>
</ul>
</li>
<li>Set接口：存储无序的、不可重复的数据   –&gt;像高中讲的“集合”<ul>
<li>HashSet、LinkedHashSet、TreeSet</li>
</ul>
</li>
</ul>
</li>
<li><p>Map接口：双列集合，用来存储一对(key - value)一对的数据   –&gt;高中函数：y = f(x)，不同的key可以指向</p>
<p> 同一个value</p>
<ul>
<li>HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List接口框架</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">    |----List接口：存储有序的、可重复的数据。  --&gt;“动态”数组,替换原有的数组</span><br><span class="line">        |----ArrayList：作为List接口的主要实现类；线程不安全的，效率高；底层使用Object[] elementData存储</span><br><span class="line">        |----LinkedList：对于频繁的插入、删除操作，使用此类效率比ArrayList高；底层使用双向链表存储</span><br><span class="line">        |----Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用Object[] elementData存储</span><br></pre></td></tr></table></figure>

<p><strong>面试题：ArrayList、LinkedList、Vector 三者的异同</strong></p>
<p>相同点：三个类都实现了List接口，存储数据的特点相同，存储有序的、可重复的数据。</p>
<p>不同点：见上面👆</p>
<p><strong>ArrayList的源码分析：</strong>这里分为jdk7和jdk8</p>
<p>jdk 7情况下：</p>
<ul>
<li>ArrayList list = new ArrayList();//底层创建了长度是10的Object[]数组elementData</li>
<li>list.add(123);//elementData[0] = new Integer(123);</li>
<li>…</li>
<li>list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容。</li>
<li>默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</li>
<li>结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity)</li>
</ul>
<p>jdk 8中ArrayList的变化：</p>
<ul>
<li>ArrayList list = new ArrayList();//底层Object[] elementData初始化为{}.并没有创建长度为10的数组</li>
<li>list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData[0]</li>
<li>…</li>
<li>后续的添加和扩容操作与jdk 7 无异。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</span><br></pre></td></tr></table></figure>

<p><strong>LinkedList的源码分析：</strong></p>
<p>LinkedList list = new LinkedList(); 内部声明了Node类型的first和last属性，默认值为null</p>
<ul>
<li>list.add(123);//将123封装到Node中，创建了Node对象。</li>
</ul>
<p><strong>Vector的源码分析：</strong>jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组。</p>
<ul>
<li>在扩容方面，默认扩容为原来的数组长度的2倍。（不重要）</li>
</ul>
<p>set接口：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set接口的框架：</span><br><span class="line">|----Collection接口：单列集合，用来存储一个一个的对象</span><br><span class="line">     |----Set接口：存储无序的、不可重复的数据   --&gt;高中讲的“集合”</span><br><span class="line">          |----HashSet：作为Set接口的主要实现类；线程不安全的；可以存储null值</span><br><span class="line">          |----LinkedHashSet：作为HashSet的子类；遍历其内部数据时，可以按照添加的顺序遍历，对于频繁的遍历操作，LinkedHashSet效率高于HashSet.</span><br><span class="line">          |----TreeSet：可以按照添加对象的指定属性，进行排序。</span><br></pre></td></tr></table></figure>

<h3 id="Map的实现类的结构："><a href="#Map的实现类的结构：" class="headerlink" title="Map的实现类的结构："></a>Map的实现类的结构：</h3><p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20220102223958792.png" alt="image-20220102223958792"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|----Map:双列数据，存储key-value对的数据   ---类似于高中的函数：y &#x3D; f(x)</span><br><span class="line">     |----HashMap:作为Map的主要实现类；线程不安全的，效率高；存储null的key和value</span><br><span class="line">          |----LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历。</span><br><span class="line">               原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素。</span><br><span class="line">               对于频繁的遍历操作，此类执行效率高于HashMap，可以使用LinkedHashMap</span><br><span class="line">     |----TreeMap:保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序或定制排序，底层使用红黑树。</span><br><span class="line">     |----Hashtable:作为古老的实现类；线程安全的，效率低；不能存储null的key和value</span><br><span class="line">          |----Properties:常用来处理配置文件。key和value都是String类型</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap的底层：数组+链表  （jdk7及之前）</span><br><span class="line">              数组+链表+红黑树 （jdk 8）</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">面试题：</span><br><span class="line">1. HashMap的底层实现原理？</span><br><span class="line">2. HashMap 和 Hashtable的异同？</span><br><span class="line">3. CurrentHashMap 与 Hashtable的异同？（暂时不学）</span><br></pre></td></tr></table></figure>

<p>Map结构的理解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map中的key:无序的、不可重复的，使用Set存储所有的key  ---&gt; key所在的类要重写equals()和hashCode() （以HashMap为例）</span><br><span class="line">Map中的value:无序的、可重复的，使用Collection存储所有的value ---&gt;value所在的类要重写equals()，</span><br><span class="line"></span><br><span class="line">一个键值对：key-value构成了一个Entry对象。</span><br><span class="line">Map中的entry:无序的、不可重复的，使用Set存储所有的entry</span><br></pre></td></tr></table></figure>

<p>三、HashMap的底层实现原理？以jdk7为例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashMap map &#x3D; new HashMap():</span><br><span class="line">在实例化以后，底层创建了长度是16的一维数组Entry[] 名字叫table。</span><br><span class="line">      ...然后可能已经执行过多次put...</span><br><span class="line">      map.put(key1,value1):</span><br><span class="line">      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。</span><br><span class="line">      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1</span><br><span class="line">      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：</span><br><span class="line">      如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2</span><br><span class="line">      如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：</span><br><span class="line">      如果equals()返回false:此时key1-value1添加成功。----情况3</span><br><span class="line">      如果equals()返回true:使用value1替换value2。说明此时的put方法有修改的功能了。</span><br><span class="line"></span><br><span class="line">补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。</span><br><span class="line"></span><br><span class="line">      在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jdk8 相较于jdk7在底层实现方面的不同：</span><br><span class="line">1. new HashMap():底层没有创建一个长度为16的数组</span><br><span class="line">2. jdk 8底层的数组是：Node[],而非jdk7里面的Entry[]</span><br><span class="line">3. 首次调用put()方法时，底层创建长度为16的数组 </span><br><span class="line">4. jdk7底层结构只有：数组+链表。jdk8中底层结构：数组+链表+红黑树。</span><br><span class="line">  4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</span><br><span class="line">  4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8 且当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储。</span><br><span class="line">    DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</span><br><span class="line">    DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75</span><br><span class="line">    threshold：扩容的临界值，&#x3D;容量*填充因子：16 * 0.75 &#x3D;&gt; 12</span><br><span class="line">    TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8</span><br><span class="line">    MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型的使用</p>
<p>1.jdk 5.0新增的特性</p>
<p>2.在集合中使用泛型：</p>
<p>总结：</p>
<p>① 集合接口或集合类在jdk5.0时都修改为带泛型的结构。</p>
<p>② 在实例化集合类时，可以指明具体的泛型类型</p>
<p>③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p>
<p>比如：add(E e)  —&gt;实例化以后：add(Integer e)</p>
<p>④ 注意点：<strong>泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</strong></p>
<p>⑤ 如果实例化时，没有指明泛型的类型。<strong>默认类型为java.lang.Object类型</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();<span class="comment">//jdk5新特性    </span></span><br><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//jdk7新特性：类型推断</span></span><br></pre></td></tr></table></figure>

<p>ORM（对象关系映射），数据库中的一张表对应一个java类，体现的是万事万物皆对象。</p>
<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型方法：在方法中出现了泛型结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型都无所谓。</p>
<p>泛型方法可以声明为是静态的，只要在调用的时候指明是什么类型的就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">//这是错误的写法，</span></span><br><span class="line">  <span class="comment">//这不是泛型方法，编译器会误认为是不是还有一个类叫做 E</span></span><br><span class="line">  <span class="comment">//E 与上面的 T 没有关系，并且</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> list&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E&lt;&gt; arr)</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//正确的方法，如果是要声明泛型方法，需要在 public 和 List&lt;E&gt; 之间，写好&lt;E&gt;,这才是泛型方法。</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">copyFromArrayToList</span><span class="params">(E&lt;&gt; arr)</span></span>&#123; </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//静态泛型方法,其中 list&lt;E&gt; 是返回类型。</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">list&lt;E&gt; <span class="title">copyFromArrayToList_1</span><span class="params">(E&lt;&gt; arr)</span></span>&#123; </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;&gt;();</span><br><span class="line">  Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  List&lt;Integer&gt; list = order.copyFromArrayToList(arr);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="1-流的分类"><a href="#1-流的分类" class="headerlink" title="1. 流的分类"></a>1. 流的分类</h3><p>按照数据单位不同分为：<strong>字节流和字符流</strong></p>
<p>按照数据流的流向分为：<strong>输入流和输出流</strong></p>
<p>按照流的角色分为：<strong>节点流和处理流</strong></p>
<p>节点流：直接作用在文件上</p>
<p>处理流：是在节点流的基础上进行包裹的流。</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20210906192257236.png" alt="image-20210906192257236"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对于文本文件(.txt,.java,.c,.cpp)，使用字符流处理</span><br><span class="line">2. 对于非文本文件(.jpg,.mp3,.mp4,.avi,.doc,.ppt,...)，使用字节流处理</span><br></pre></td></tr></table></figure>

<p>但是：如果是文本文件，只是想复制一下，使用字节流也行，但是不要读出来，但是即使是复制，去处理非文本文件，也不能使用字符流。</p>
<p>缓冲流：是处理流的一种，主要是为了提高速度。</p>
<p>对象流：不仅可以存储基本数据类型数据，还可以把对象写入到数据源中，也可以把对象从数据源中还原回来</p>
<p><strong>序列化：</strong>用ObjectOutputStream类保存基本类型数据或对象的机制</p>
<p><strong>反序列化：</strong>用ObjectInputStream类读取基本类型数据或对象的机制</p>
<p>举例：自己写的一个类Person</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person需要满足如下的要求，方可序列化</span><br><span class="line">1.需要实现接口：Serializable</span><br><span class="line">2.当前类提供一个全局常量：serialVersionUID</span><br><span class="line">3.除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</span><br></pre></td></tr></table></figure>

<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>此部分主要是了解网络编程，详细见代码</p>
<h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><p>复习反射需要的材料（反射一节的ppt、反射代码、和此笔记）</p>
<p>本节主要的是<strong>获取Class实例，创建运行时类的对象、调用运行时类的结构</strong></p>
<h3 id="1-Java反射机制概述"><a href="#1-Java反射机制概述" class="headerlink" title="1. Java反射机制概述"></a>1. Java反射机制概述</h3><h4 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h4><p>​        反射是被视为<strong>动态语言</strong>的关键，是因为 Java 文件要进行两个阶段的“洗礼”，第一个编译阶段是生成  .java 文件编译为 .class 文件，此时还不能确定某一类的对象，只有在运行时才能确定是哪个。体现了动态性。反射可以获取对象的任何信息。</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201124193827032.png" alt="image-20201124193827032"></p>
<p>反射的意思就是 通过类的对象，能了解到类的信息。就是反射。</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201127142743534.png" alt="image-20201127142743534"></p>
<h4 id="动态语言-与-静态语言"><a href="#动态语言-与-静态语言" class="headerlink" title="动态语言 与 静态语言"></a>动态语言 与 静态语言</h4><p><strong>动态语言</strong>：在运行时可以改变其结构的语言，例如新的函数、对象、甚至代码可以 被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是<strong>在运行时代码可以根据某些条件改变自身结构。</strong> </p>
<p><strong>静态语言</strong>：运行时结构不可改变，如Java、C、 C++。</p>
<p>虽然Java不是动态语言，但是Java可以成为“<strong>准动态语言</strong>”，也就是说它有动态性，可以利用反射的机制来体现。</p>
<h4 id="Java反射机制研究与应用"><a href="#Java反射机制研究与应用" class="headerlink" title="Java反射机制研究与应用"></a>Java反射机制研究与应用</h4><p>反射可以干什么？</p>
<ul>
<li>在运行时判断任意一个对象所属的类 </li>
<li>在运行时构造任意一个类的对象 </li>
<li>在运行时判断任意一个类所具有的成员变量和方法 </li>
<li>在运行时获取泛型信息 </li>
<li>在运行时调用任意一个对象的成员变量和方法 </li>
<li>在运行时处理注解 </li>
<li>生成动态代理</li>
</ul>
<p>总之一句话：就是可以获取类的任何信息。</p>
<p>关于反射相关的API</p>
<ul>
<li>java.lang.Class:代表一个类，（一个类也是一个类）</li>
<li>java.lang.reflect.Method:代表类的方法</li>
<li>java.lang.reflect.Field:代表类的成员变量</li>
<li>java.lang.reflect.Constructor:代表类的构造器</li>
</ul>
<h3 id="2-理解Class类并获取Class实例"><a href="#2-理解Class类并获取Class实例" class="headerlink" title="2. 理解Class类并获取Class实例"></a>2. 理解Class类并获取Class实例</h3><h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>Class是用来描述类的类，比如每个类都有属性，都有方法等等，所以又抽象出一个类。Class类是反射的源头。</p>
<img src="https://gitee.com/dlutlgy/window_typora/raw/master/images/image-20201127144332468.png" alt="image-20201127144332468" style="zoom: 80%;" />



<p>因为 Object 类是所有类的父类，要想得到每个类的信息，getClass()方法就声明在了 Object 类中。</p>
<p>​        对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个类而言，JRE 都为其保留一个不变的 Class 类型的对象。一个 Class 对象包含了特定某个结构的有关信息。</p>
<ul>
<li>Class 本身也是一个类 </li>
<li>Class 对象只能由系统建立对象 </li>
<li>一个加载的类在 JVM 中只会有一个 Class 实例 </li>
<li>一个Class对象对应的是一个加载到 JVM 中的一个 .class 文件 </li>
<li>每个类的实例都会记得自己是由哪个 Class 实例所生成 </li>
<li>通过 Class 可以完整地得到一个类中的所有被加载的结构 </li>
<li>Class 类是 Reflection 的根源，针对任何你想动态加载、运行的类，唯有先获得相应的 Class 对</li>
</ul>
<h4 id="获取Class类的实例-（四种方法）"><a href="#获取Class类的实例-（四种方法）" class="headerlink" title="获取Class类的实例 （四种方法）"></a>获取Class类的实例 （四种方法）</h4><p>获取Class类的实例的四种方法，其中前三种方法比较重要，经常用到，最后一种不需要掌握。</p>
<p> 方式一：调用运行时类的属性：.class</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br></pre></td></tr></table></figure>

<p>方式二：通过运行时类的对象,调用getClass()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(); <span class="comment">// 此时Person类为运行时类</span></span><br><span class="line">Class clazz2 = p1.getClass();<span class="comment">//.getclass 是在object里面造的</span></span><br><span class="line">System.out.println(clazz2);</span><br></pre></td></tr></table></figure>

<p>方式三：调用Class的 静态方法 ：forName(String classPath)。这里必须写 类的全类名，因为同一个module下可能有多个person（使用的比较多）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz3 = Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz3+<span class="string">&quot;打印3&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>方式四：使用类的加载器：ClassLoader  (了解)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class clazz4 = classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz4);</span><br></pre></td></tr></table></figure>



<h3 id="3-类的加载-与ClassLoader的理解（了解）"><a href="#3-类的加载-与ClassLoader的理解（了解）" class="headerlink" title="3. 类的加载 与ClassLoader的理解（了解）"></a>3. 类的加载 与ClassLoader的理解（了解）</h3><h4 id="类的加载过程-（了解）"><a href="#类的加载过程-（了解）" class="headerlink" title="类的加载过程 （了解）"></a>类的加载过程 （了解）</h4><p>当程序主动使用某个类时，如果该类还未被加载到内存中，则系统会通过 如下三个步骤来对该类进行初始化。</p>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201127152144541.png" alt="image-20201127152144541"></p>
<ul>
<li>加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时 数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问 入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的 过程需要类加载器参与。</li>
<li>链接：将Java类的二进制代码合并到JVM的运行状态之中的过程。<ul>
<li>验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 </li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存 都将在方法区中进行分配。 </li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。</li>
</ul>
</li>
<li>初始化<ul>
<li>执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译期自动收集类中 所有类变量的赋值动作和静态代码块中的语句合并产生的。（类构造器是构造类信息的，不是构造该类对象的构造器）。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类 的初始化。</li>
<li>虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步。</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/dlutlgy/images_for_typora/raw/master/images/image-20201125121333135.png" alt="image-20201125121333135"></p>
<h4 id="类加载器的作用："><a href="#类加载器的作用：" class="headerlink" title="类加载器的作用："></a>类加载器的作用：</h4><ul>
<li>类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口。 </li>
<li>类缓存：标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器 中，它将维持加载（缓存）一段时间。不过 JVM 垃圾回收机制可以回收这些Class对象。</li>
</ul>
<h4 id="类的加载器的种类："><a href="#类的加载器的种类：" class="headerlink" title="类的加载器的种类："></a>类的加载器的种类：</h4><p>引导类加载器、扩展类加载器、系统类加载器</p>
<ul>
<li>引导类加载器：是C、C++编写的，是JVM自带的加载器，<strong>主要负责Java平台核心库</strong>，用来加载核心类库。</li>
<li>扩展类加载器：负责jre/lib/ext目录下的jar包或指定目录下的jar包</li>
<li>系统类加载器：自己定义的类都是有系统类加载器进行加载</li>
</ul>
<h3 id="4-创建运行时类对象（重点）"><a href="#4-创建运行时类对象（重点）" class="headerlink" title="4. 创建运行时类对象（重点）"></a>4. 创建运行时类对象（重点）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.根据全类名获取对应的Class对象 </span></span><br><span class="line">String name = <span class="string">&quot;atguigu.java.Person&quot;</span>; </span><br><span class="line">Class clazz = <span class="keyword">null</span>; </span><br><span class="line">clazz = Class.forName(name); </span><br><span class="line"><span class="comment">//2.调用指定参数结构的构造器，生成Constructor的实例 </span></span><br><span class="line">Constructor con = clazz.getConstructor(String.class,Integer.class); </span><br><span class="line"><span class="comment">//3.通过Constructor的实例创建对应类的对象，并初始化类属性 </span></span><br><span class="line">Person p2 = (Person) con.newInstance(<span class="string">&quot;Peter&quot;</span>,<span class="number">20</span>); </span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure>

<h3 id="5-获取运行时类的完整结构"><a href="#5-获取运行时类的完整结构" class="headerlink" title="5. 获取运行时类的完整结构"></a>5. 获取运行时类的完整结构</h3><p>具体内容在代码中体现。</p>
<h3 id="6-调用运行时类的指定结构"><a href="#6-调用运行时类的指定结构" class="headerlink" title="6. 调用运行时类的指定结构"></a>6. 调用运行时类的指定结构</h3><p>主要是调用运行时类中指定的结构：属性、方法、构造器。</p>
<p>具体内容在代码中体现。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2>
    </div>

    
    
    


    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>Dlutlgy
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://dlutlgy.top/2021/08/13/Java/" title="Java语言">http://dlutlgy.top/2021/08/13/Java/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Java%E5%9F%BA%E7%A1%80/" rel="tag"># Java基础</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="prev" title="设计模式">
                  <i class="fa fa-chevron-left"></i> 设计模式
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/08/13/MySQL%E5%9F%BA%E7%A1%80/" rel="next" title="MySQL基础">
                  MySQL基础 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dlutlgy</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">191k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:54</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script> 

<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>















  








  

  
<script>
NexT.utils.loadComments('#valine-comments', () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: "/2021/08/13/Java/",
    }, {"enable":true,"appId":"QYi7IEQIz9YMSxsX95Id72rn-gzGzoHsz","appKey":"up4HJAyGMxTrtvP0bHO2fwTi","placeholder":"ヾﾉ≧∀≦)o来啊，快活啊!","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"lang":null,"visitor":true,"comment_count":true,"recordIP":true,"serverURLs":null,"enableQQ":true,"requiredFields":["nick"]}
    ));
  }, window.Valine);
});
</script>





</body>
</html>
